<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法—KMP]]></title>
    <url>%2F2018%2F09%2F19%2F%E7%AE%97%E6%B3%95%E2%80%94KMP%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演. 初步涉及KMP时,有些蒙蔽,还好遇到了 阮一峰 的讲解,才啃下来.博文图来自资料链接. 资料来源如下 从头到尾彻底理解KMP（2014年8月22日版） 如何更好的理解和掌握 KMP 算法? - 海纳的回答 - 知乎 字符串匹配的KMP算法 阮一峰 KMP暴力搜索 搜索字符串时最常用的是暴力搜索, 一个字符一个字符去比较,第一位相同,比较第二位 遇到不同字符,目标字符指针后移一位,重复. 直到遇到模式字符终止符.返回目标字符指针位置. 以下是暴力搜素的C语言一个实现版本 12345678910111213141516171819202122232425262728int ViolentMatch(char* s, char* p)&#123; int sLen = strlen(s); int pLen = strlen(p); int i = 0; int j = 0; while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; if (s[i] == p[j]) &#123; //①如果当前字符匹配成功（即S[i] == P[j]），则i++，j + i++; j++; &#125; else &#123; //②如果失配（即S[i]! = P[j]），令i = i - (j - 1) j = 0 i = i - j + 1; j = 0; &#125; &#125; //匹配成功，返回模式串p在文本串s中的位置，否则返回-1 if (j == pLen) return i - j; else return -1;&#125; 对暴力搜索而言,整个流程上改进空间不大,主要集中在当搜索过程.见示例 可以看到整个搜索过程,最明显的一个缺陷是,搜索到模式字符串的中间很长一段了,遇到一个坏字符,目标字符串指针移位1.模式字符还是要从头开始比较,模式字符在上一轮坏字符之前的比较相当于白做了. KMP算法 当空格与D不匹配时，前面六个字符是”ABCDAB”已知。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置” j 移回已经比较过的位置，而是继续把它向后移。 经过KMP处理六个字符已知字符串”ABCDAB”后,可以得到一个表格,对应模式字符串每一位可前移的位数.如图 于是整个过程优化如下. 但空格与D失配,其前一位 (B-&gt;2),所以 j=2 但空格与C依旧失配.其前一位 (B-&gt;0),所以 j=0 对应c代码变化如下 最主要的变化是引入next[]数组(方便). 因为c语言数组元素由0开始,上文的表格右移一位.0位填充-1.得到next数组. 12345678910111213141516171819202122232425262728int KMP(char * t, char * p)&#123; int sLen = strlen(s); int pLen = strlen(p); int i = 0; int j = 0; while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else &#123; //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] //next[j]即为j所对应的next值 j = next[j]; &#125; &#125; //匹配成功，返回模式串p在文本串s中的位置，否则返回-1 if (j == pLen) return i - j; else return -1;&#125; 部分匹配表(Partial Match Table),next[]数组 这里大量摘录了如何更好的理解和掌握 KMP 算法? - 海纳的回答 - 知乎的答案. 上文提及的表格即部分匹配表. 字符串的前缀和后缀。 前缀: 如果字符串A和B，存在A=BS，其中S是任意的非空字符串，那就称B为A的前缀。例如，”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。 后缀: 后缀A=SB， 其中S是任意的非空字符串，那就称B为A的后缀，例如，”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。 要注意的是，字符串本身并不是自己的后缀。 PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度,如图 这里换一组字符串“abababca”说明next数组求法 求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。 具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行字符串搜索(KMP)。 在任一位置，能匹配的最长长度(j值)就是当前位置的next值。如下图所示。 如图 c语言实现 123456789101112131415161718192021void GetNext(char* p,int next[])&#123; int pLen = strlen(p); next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1) &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) &#123; ++k; ++j; next[j] = k; &#125; else &#123; k = next[k]; &#125; &#125;&#125; 流程(部分): next[6]=4 p[6] != p[4]; k = next[4] = 2 p[6] != p[2]; k = next[2] = 0 p[6] != p[0]; k = next[0] = -1 k == -1; ++k; ++j; next[7]=k=0; …… 回到字符串”ABCDAB”,得到的next数组如下 next[]数组改进 当 j 沿着next[]数组回溯时,可能产生一种情况是:连续几次回溯到的字符相同,即连续几次比较了模式字符串里相同的字符. 如上一节流程部分. p[4] p[2] p[0]都为元素a,实际只需要与 p[6] 比较一次即可. 未避免这种情况,可以对next[]数组回溯链上,连续相同的字符合并,直接取前一个字符对应位置next[]数组的值.由此产生的数组叫nextval数组. c代码实现: 1234567891011121314151617181920212223242526272829void GetNextval(char* p,int next[])&#123; int pLen = strlen(p); next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1) &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) &#123; ++k; ++j; // if(p[k]==p[j]) &#123; next[j] = next[k]; &#125; else &#123; next[j] = k; &#125; &#125; else &#123; k = next[k]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—编译LineageOS源码]]></title>
    <url>%2F2018%2F07%2F29%2FAndroid%E7%AC%94%E8%AE%B0%E2%80%94%E7%BC%96%E8%AF%91LineageOS%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[资料来源如下 记录下编译LINEAGEOS的过程 Ubuntu 16.04 LTS 下编译 LineageOS 源码 Build for klte 编程环境 Ubuntu16.04 导语 记录编译LineageOS 15.1的过程,备忘. 编译LineageOS源码准备 硬件上 大于100G的硬盘剩余空间.SSD加速有奇效. 推荐i7+8G以上配置.(4代i7+16G+SSD编译时间2.5h参考) 软件 google官方的教程是ubuntu版本为14.04,这里使用16.04 全翻墙的环境,下载的话源码大约20GB. 其他 足够耐心,相信大半问题都是网络导致的. 以下默认科学上网良好情况下进行. 编译环境 依赖组件 123sudo apt install -y bc bison build-essential curl flex gcc-multilib git git-core gnupg gperf g++-multilib libesd0-dev libgl1-mesa-dev liblz4-tool libncurses5-dev libreadline6-dev \libsdl1.2-dev libwxgtk3.0-dev libxml2 libxml2-utils libx11-dev lib32ncurses5-dev lib32z1-dev lzop pngcrush schedtool squashfs-tools \unzip xsltproc zip zlib1g-dev 额外组件，可能会使用. 1sudo apt install imagemagick libbz2-dev libssl-dev lzma ncftp bash-completion LineageOS 14.1以上需要openjdk-8,这里是LineageOS 15.1.直接安装且不需要配置环境变量. 1sudo apt install -y openjdk-8-jdk 安装完成后输入java -version,返回1.8即正确安装. 安装repo repo是google用来管理android源码的工具,基于git实现.android源码的代码量级,直接使用git….你可以试试…. repo实际上是个python2的脚本. 下载并设置环境变量 12345mkdir -p ~/bincurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repoecho "export PATH=~/bin:$PATH" &gt;&gt; ~/.bashrcsource ~/.bashrc ps 实在下载不下来,手动拖下来. 或者转清华源. 初始化 LineageOS 存储库 设置git 设置邮箱 12git config --global user.email "you@example.com"git config --global user.name "Your Name" 生成SSH key 添加到 github (LineageOS代码现在托管在github)过程自行google吧. 初始化存储 新建目录 1mkdir -p ~/lineage-15.1 初始化LineageOS的repo 命令 1repo init -u https://github.com/LineageOS/android.git -b lineage-15.1 Enable color display in this user account (y/N)? y ubuntu16即使设置了终端使用http代理,但git还是需要手动设置才能通过代理访问网络(本地http代理端口为80) 1git config --global http.proxy "localhost:80" 这里可能因为网络或其他原因失败,删除 lineage-15.1/.repo文件夹,重新初始化即可. 同步源码 同步命令 1repo sync -f -j4 -c --no-clone-bundle 注解:-f : 强制-j4 : 4线程,梯子良好情况下,更多线程无意义.–no-clone-bundle : 忽略 clone 失败的信息 源码大约20G,国内的网络环境下需要很长一段时间了. 如果遇到同步失败,网络没问题情况下,执行repo sync即可,已经下载的数据不会再次重复. 同步设备代码(这里是Galaxy S5 代号 klte ) 命令 12source build/envsetup.shbreakfast klte 执行后会同步 S5 对应的设备文件,大约1G. 获取设备vendor文件 通过设备adb获取.确保手机已经连接电脑，然后进入 ~/android/system/device/&lt;厂商&gt;/&lt;设备&gt; 目录。然后执行： 1./extract-files.sh 或者在TheMuppets获取. 手动下载添加. 或者在LineageOS/.repo/local_manifests/roomservice.xml最后添加 1&lt;project name="TheMuppets/proprietary_vendor_samsung" path="vendor/samsung" remote="github"/&gt; 执行repo sync会将三星的所有设备vendor文件同步到本地 编译 设置ccache,这里设置缓存50G 123sudo apt install ccache -yecho export USE_CCACHE=1 &gt;&gt; ~/.bashrcprebuilts/misc/linux-x86/ccache/ccache -M 50G 设置 jack 使用更多的内存 命令 12export ANDROID_JACK_VM_ARGS="-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4G"source ~/.bashrc 有时需要重启jack 12out/host/linux-x86/bin/jack-admin kill-serverout/host/linux-x86/bin/jack-admin start-server 编译变量 带root export WITH_SU=true 设置编译变量 . ./build/envsetup.sh 编译 命令 12crootbrunch klte 之后是相当漫长的等待了.i7 16G SSD 2.5h. 结束 在OUT文件夹中,有编译完成的ROM.lineage-15.1-20180729-UNOFFICIAL-klte.zip ROM的其他修改及优化,待续.]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android随手记—Attempt to invoke interface method ''on a null object reference]]></title>
    <url>%2F2018%2F07%2F27%2FAndroid%E9%9A%8F%E6%89%8B%E8%AE%B0-Attempt%20to%20invoke%20interface%20method%20''on%20a%20null%20object%20reference%2F</url>
    <content type="text"><![CDATA[编程环境 Android Studio 3.1.2 问题 myprivacy测试中一些应用在进入第二个activity时时常闪退,爆出空对象错误. 1Attempt to invoke interface method 'boolean android.view.inputmethod.InputConnection.finishComposingText()' on a null object reference 但本身Activity跳转之间并没有输入控件. 过程 Google到了,类似故障. https://github.com/facebook/react-native/issues/18884 解决 关闭 Android Studio的Advanced Profiling即可,非代码错误 备注 无]]></content>
      <categories>
        <category>Android随手记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初入树莓派4----自建无污染DNS]]></title>
    <url>%2F2018%2F06%2F26%2F%E5%88%9D%E5%85%A5%E6%A0%91%E8%8E%93%E6%B4%BE4----%E8%87%AA%E5%BB%BA%E6%97%A0%E6%B1%A1%E6%9F%93DNS%2F</url>
    <content type="text"><![CDATA[自建无污染DNS GFW ISP 还有无良的第三方,搞的上个网 DNS 被污染的不成样子. 需求 国内/国外分流,国内网站交给国内DNS,国外的交给墙外无污染DNS. 对CDN友好,访问百度,我在广州,你DNS分配个青岛的地址要闹那样. 带有DNS缓存,加速解析. 跨平台(小),出门不能一直带着路由器啊. 方案 国内/国外分流 分流可使用ChinaDNS. 无污染DNS 墙外DNS,但udp-53端口,基本被劫持.需要特别方式规避. 非标准DNS端口 例如 opendns的udp-5353端口 tcp-443端口 DNS over HTTPS ,支持最好的是google-dns及 Cloudflare-dns,其中google-dns比较麻烦,还需要自行寻找可用的google ip地址. DNS over TLS ,与上一个类似. DNSCrypt ,支持此项的公共DNS很多,与此被干扰的也比较厉害. ss/ssr-vpn-v2ray 等代理解析dns. 一直可用的中科大DNS 北方还好. 对CDN友好选择支持EDNS的上游DNS,国内主流都支持了,除了114. 带有DNS缓存,这个用的较多的 dnsmasq ,当作下游DNS. 跨平台(大雾),一般都在路由器搞搞. 最终定型 dnsmasq(可选) + overture + 上游加密DNS(可选) overture DNS分流净化器,go语言编写,解决chinadns不稳定而编写. 得益于go的跨平台能力,基本通吃. 已经支持DNS缓存 支持tcp / udp DNS查询 比chinadns更加稳定. 实际上如果只需要一个纯净DNS,只使用overture就足够了. 当需要广告过滤时,添加dnsmasq. overture可使用 非标准dns端口查询dns,解决上游DNS污染问题.非标准端口被大量干扰或dns查询全程保密,才需要使用DNSCrypt DNS over HTTPS等额外措施. 实施 下载最新releases 解压 以win-64为例,打开配置文件 1234567891011121314151617181920212223242526272829303132333435363738&#123;"BindAddress": ":53",//本地监听端口"PrimaryDNS": [//主DNS (国内) 可设置多组 &#123; "Name": "DNSPod", "Address": "119.29.29.29:53",//腾讯DNS还可以 支持EDNS "Protocol": "udp",//UDP查询 TCP查询 "SOCKS5Address": "", "Timeout": 6, "EDNSClientSubnet": &#123;//EDNS支持 "Policy": "auto",//disable 关闭 auto启用 "ExternalIP": ""//EDNS查询用IP ,设置则使用此IP &#125; &#125;],"AlternativeDNS": [//无污染DNS 可设置多组 &#123; "Name": "OpenDNS",//OpenDNS "Address": "208.67.222.222:5353",//非标准dns端口 "Protocol": "udp",//走udp "SOCKS5Address": "", "Timeout": 6, "EDNSClientSubnet": &#123;//edns只支持udp so 选择了udp的非标准端口 "Policy": "auto", "ExternalIP": "" &#125; &#125;],"OnlyPrimaryDNS": false,//只启用主DNS?"RedirectIPv6Record": false,//重定向 IPV6 DNS ?"IPNetworkFile": "./ip_network_sample",//ip文件"DomainFile": "./domain_sample",//域名文件"DomainBase64Decode": true,//域名文件使用Base64编码?"HostsFile": "./hosts_sample",//host文件"MinimumTTL": 0,//dns的 ttl设置,0禁用"CacheSize" : 500,//域名缓存的数量.按照实际使用习惯配置"RejectQtype": [255]&#125; 保存文件 启动exe即可 windows 下可以使用 nssm 包装成windows的server,做到开机启动. linux 下,各种脚本为所欲为.]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python—分析日志]]></title>
    <url>%2F2018%2F06%2F26%2Fpython%E2%80%94%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[分析日志需求 简单分析日志文件中两个时间差. 计算平均值,中位数,方差等. 图形化展示. 分析 用到的功能 系统io,只需要按行读入即可,当然需要指定gbk编码 科学计算的函数库 简单的画图库 python库 系统的 io 库即可 numpy 库,大材小用 matplotlib.pyplot,大材小用 示例 按行读入 123456789with open(path,encoding='gbk') as f: for number, line in enumerate(f): #去空格 line = line.strip().replace(' ','') #匹配字符串 try: ln1 = line.index(str1) except ValueError as e: ln1 = 1 得到一个list 统计 12345print("数量",len(time))print("平均值",np.mean(time))print("最大值",np.max(time))print("最小值",np.min(time))print("方差",np.var(time)) 画图 1234567#格式化转化为时间for ts in x : tx.append(datetime.datetime.fromtimestamp(ts/1000))plt.plot(tx,time) plt.title('len%d, mean%d, max%d, min%d' % (len(time),np.mean(time),np.max(time),np.min(time))) # 添加图形标题plt.show()]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法—查找]]></title>
    <url>%2F2018%2F06%2F03%2F%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演. 资料来源如下 算法第四版 查找 基于符号表的抽象来组织查找有关内容.分为 key-value ,有时又称字典. 分别介绍 二叉查找树 红黑树 及 散列表 3种经典的实现. 符号表 定义: 存储键值对的数据结构,支持put插入 及 get查找操作. API: 1234567void put(Key key,Value val)Value get(Key key)void delete(Key key)boolean contains(Key key)boolean isEmpty()int size()Iterable&lt;Key&gt; keys() 规则 没有重复key key不能为空 value不能为空 删除操作即使实现. key为不可变类型数据. 成本 使用比较次数来统计成本. 内循环不进行比较时,统计数组访问次数. 其他 有序符号表 额外API 1234main()max()floor(Key key)select(int k) 无序符号表 经典的基于链表实现. 二叉查找树BST 数据结构:结点 一个唯一key 对应value 一条左链接 一条右链接 一个节点计数器(该节点的子节点总数) get方法表中存在对应方法即返回对应值,否则返回空.代码:递归实现 实现get(Node x,Key key) 查找Key 对应值,没有返回null 对比 x 与 key 值. 根据结果返回 get(x.right,key) or get(x.left,key) get由传入根节点调用 get(Node x,Key key) put方法存在则更新值,不存在则插入新值.代码:递归实现 实现Node put(Node x,Key key,Value val) x为空,则创建新节点并插入key val 对比x key 值 x = key,则更新值. 根据结果返回 put(x.right,key,val) or put(x.left,key,val) 更新节点计数器 put传入根节点 调用Node put(Node x,Key key,Value val) 分析 如同union-find问题,二叉树生长的方式及平均深度对查找及插入的影响很大.二叉查找树性能非常依赖于 key分布足够随机. 有序符号表 最大最小 传入节点左链接是否为空? 返回传入节点 : 递归调用min(x.left) 传入节点左链接是否为空? 返回传入节点 : 递归调用mam(x.right) 向上/下取整 递归 传入节点左链接 为空.返回 null 传入节点左链接 = key-value 返回 传入节点 传入节点左链接 &lt; key-value 返回 递归传入左链接 传入节点左链接 &gt; key-value 递归传入右链接 判断返回值t 为空? 不为空返回 t 为空返回传入节点. 递归调用. 排名 与节点计数器有关. key = 传入节点,返回左子树节点总数. key &lt; 传入节点,返回 递归左子树. key &gt; 传入节点,返回 递归右子树. 删除最大/最小键 删除最大/最小值,因其子链接均为空,无妨. 删除 -二叉树中间呢? 查找到要删除的节点 保存 父链接 左右子链接. 选择右子树,查找最小节点.(不断选择左子树,直到遇到左子链接为空元素) 将 右子树最小元素 移植到 已删除元素位置. 处理 右子树最小元素 右子链接(直接链接到父节点) 可能存在性能问题. 范围查找 首先遍历操作 递归要不要简单 x为空? 返回 过程处理. 不为空, 递归左节点 递归右节点. 在过程处理中进行过滤操作. 因二叉树数值相对有序,舍弃掉不存在想要值的子树. 平衡查找树 只使用二叉树而保持树生长的平衡,代价很高. so,对节点的基础数据结构动一些手脚,引入 2-3 树. 最大的变化在于插入新元素.但随之带来的完美平衡的 2-3 树,让数据结构复杂度很值. 节点可以保存2个key,3个子链接.代表]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法—优先队列&堆排序&排序应用]]></title>
    <url>%2F2018%2F06%2F02%2F%E7%AE%97%E6%B3%95-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%26%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演. 资料来源如下 算法第四版 前言 优先队列是一种抽象数据结构.支持删除最大元素及插入元素. 有很多不同的实现方式,最经典的是基于二叉堆的实现. 排序的逻辑: 将数组输入优先队列 通过优先队列 取最大元素 直到取完为止,排序完成. 但是请注意,优先队列的应用远远不止于此. 优先队列 概念: 一种抽象数据模型,有两个必须支持的操作 删除最大元素 插入元素. API定义 12345678Key delMax()//返回并 删除最大元素void insert(Key v)//插入元素void MaxPQ()//初始化优先队列void MaxPQ(int max)//初始化max容量优先队列void MaxPQ(Key[] a)//初始化 a[]的优先队列Key Max()//返回最大值boolean isEmpty()//是否为空int size()//优先队列大小 最重要的的方法是delMax()及 insert() 后面重要的改进都是针对这两个方法. 实现方式 有序数组 每进来一个元素,就进行一次排序. delMax() 1, insert() 看排序算法.大于线性. 无需数组 添加新元素不操作,删除最大元素再查找. delMax() N, insert() 1. 二叉堆 使用二叉堆来实现优先队列. 平衡了delMax() 及 insert() delMax() logN, insert() logN`. 二叉堆 基于二叉堆实现的优先队列 delMax() logN, insert() logN`. 这里使用数组而不是指针表示二叉树. 数组中位置k的节点,父节点位置 为[k/2],子节点位置 [2k] 及 [2k+1].数组0 位置不启用. 一个大小为N的完全二叉树,高度为 lgN . 父节点值大于两个子节点值,当此条件全部节点满足时,称为 堆有序. API 重点! 123swim()//上浮sink()//下沉` 上浮: 某个节点大于其父节点,将此节点向上浮动直到到达正确位置. 下沉: 某个节点小于其子节点,将此节点向下下沉,直到到达正确位置. 代码实现较容易,不再累赘. 实现 insert() : 将元素插入数组末尾,上浮至正确位置,堆恢复有序. delMax() : 删除根节点,将数组最后一个元素迁移至根节点,下沉至正确位置,堆恢复有序. 与之相对的,查找删除最小元素.一切相同. 堆排序 逻辑 堆构造 : 将数组使用转化为二叉堆表示. 下沉排序: 依次取出 最大/最小 元素,下沉恢复堆有序,直到最后一个元素为止. 有趣的是,堆排序 完全不需要额外空间. 堆构造 上浮构造,类似优先队列的insert(). 由左向右,遍历整个数组,一个一个插入新元素,同时恢复堆有序.保证待插入元素左侧,一直处于堆有序,直到全部插入为止. 下沉构造,类似delMax(),由右向左,不断将新元素下沉方式,保证带插入元素,右侧堆有序. 上浮构造,是一个有序堆,从0 开始生长到N,下沉构造则利用了数组的每个位置已经是一个子堆根节点,只需要扫描一般的元素即可 下沉构造.无需多言,递归的取根节点,不断恢复堆有序.直到排序完成. 分析 堆排序是目前已知的唯一可以同时最优的利用空间和时间啊的算法. 但!,堆缓存的利用率太低,总是比较位置相差很远的元素.缓存未命中几率远远大于其他排序. 排序应用 快速排序是目前最快的通用排序算法. 库函数有实现时,才考虑自行编写. 嗯,排序部分,结束…😂…]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法—排序]]></title>
    <url>%2F2018%2F06%2F02%2F%E7%AE%97%E6%B3%95%E2%80%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演. 资料来源如下 算法第四版 选择排序 步骤 寻找数组内最小的元素 与未排列的第一个元素交换位置. 重复1 2 知道数组排列完成. 代码 内循环 比较当前元素与已知最小元素 外循环 交换元素位置 性质 运行时间与输入无关..数组有序无序不影响时间. 数据移动最少.交换次数 与 数组长度 为线性关系. 长度为N的数组 , 选择排序 N2/2 次比较,及N次交换. 分析 最直观的排序算法. 无法利用数组的初始状态进行优化.(后续重点) 冒泡排序 步骤 遍历未排列数组,比较两个相邻元素,依照规则 交换/不交换位置. 重复1,直到完成数组排序. 代码 内循环 冒泡整个未排序数组 外循环 控制内循环 冒泡范围 分析 可能是效率最差的 实际效率与选择排序差不多. 插入排序 步骤 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素,比较已排序序列,找到新元素位置 将新元素插入到该位置后 重复步骤直到排序完成. 代码 取出新元素 内循环查找新元素位置 插入新元素 外循环控制 性质 随机数组N, 平均需要 ~ N2/4 次比较及 ~N2/4 次交换. 最坏 N2/2 次比较 N2/2 次交换 最好 N-1 次比较 0 次交换(已经排序好的….😂) 分析 考虑了数组的初始状态,对于大多数元素有序的数组,插入排序可能是最快的. 但对于随机数组 还不够. 优化 查找新元素位置: 二分法查找.而不是遍历. 插入新元素时,算法第四版 建议,内循环改为类似冒泡方式,将大元素右移 希尔排序 对插入排序分析时,有这样的结论: 对于大多数元素有序的数组,插入排序时间最快,时间为线性级别.将任意输入的数组 大多数元素有序,然后最后使用 插入排序. 插入排序对于 随机数组的瓶颈 在于,一个元素到达正确位置,一次只能移动一位.那么一次可以移动多位,交换至很远位置,可以改善插入排序的性能. 思路: 将数组等间隔 h 分裂,进行插入排序.拆分后的子数组,插入排序成本较低,进行插入排序. 完成后,原数组的有序性增加 插入排序成本降低,之后再进行颗粒度更细的拆分-排序.一级一级的降低 插入排序成本.直到最后进行 h=1的插入排序. 步骤 对数组进行间隔 h 的插入排序. 依照递增序列,取 h 值,直到 h = 1,为止,排序完成. 代码 内循环为 间隔 h 的插入排序 外循环为 计算 h 值的递增序列. 性质 希尔排序的性质并不容易概括,实际上没有完整概括. 目前可以证明的:希尔排序的运行时间 达不到 N2 级别. 分析 考虑了数组初始状态.是如今提到的排序算法中,第一个可以适用与大容量数组排序的. h 递增序列的选择,会很大程度上影响希尔排序效果.实际工程中适用那种,需要自行选择. 嵌入式系统中没有快排等库函数可选时,首选希尔排序.之后再考虑其他排序算法. 归并排序 归并排序的实现与插入/希尔/选择排序不同. 归并排序依赖于 归并操作. 归并 : 将两个有序数组 合并 为1个有序数组. 自顶向下 递归 实际上是一个 sort 的递归调用. 将数组分为 两个子数组 对子数组调用 调用sort 再对第二层子数组 调用 sort 直到最终子数组元素个数为1.递归返回 开始执行 merge()操作. 自底而上 迭代 直接归并 子元素为1 的各个数组到 子元素为2的数组. 再归并子元素为2 的各个数组 到子元素为4的数组. 最后 可能存在 数组元素不相等,但是不影响归并. 直到归并的数组元素为 N. 实际上 两者执行的过程是一样的,只是调用的角度不同. 性质 空间复杂度不是最优. 时间复杂度 NlogN 空间复杂度 N 优化 原理相同,对小的子数组 使用其他高效排序,再归并. 快速排序 应用最为广泛. 原地排序 时间成本 NlogN 但是! 坑不少… 原理 对于数组中 某个元素 都进行切分操作,大于/小于 该元素的所有元素 都在 一边. 将数组切分为2个子数组. 递归,直到切分子数组元素个数为1,完成排序. 与归并排序 在数组分解上 一致. 步骤 取出数组中某个元素 作为切分元素. 对数组执行切分. 对子数组执行 1 2 直到子数组元素个数为1.递归. 坑 原地切分,创建大量新对象性能上不可接受 保证访问不越界. 慎重处理最大最小元素. 相同元素谨慎处理. 性能改进 切分元素对性能影响及其重要. 最糟糕情况: 大部分元素有序,使用极值去切分. 为避免这种情况,快排之前,将输入数组乱序处理. 对于大型数组 取切分元素时 考虑去3 选 1. 小数组 使用切换到插入排序. 重复元素 一分为二,对于存在大量重复元素的数组,无效的比较次数较多. 改为 三取样切分 三切分取样 切分时,不再一分为二,改为 &lt; = &gt;.三部分 三项切分的信息量最优. 对于存在大量重复元素的数组,三切分取样,直接将时间 由 NlogN 降低到了 N .]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法— union-find]]></title>
    <url>%2F2018%2F05%2F31%2F%E7%AE%97%E6%B3%95%E2%80%94union-find%2F</url>
    <content type="text"><![CDATA[记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演. 资料来源如下 算法第四版 问题描述 白话文: 一堆网点,随机相连,设计一个算法快速检查两个点是否联通. 物理对应: 闲的一堆金属触点,随机用导线连接,快速查找两个点电路通不通. 精确描述: 定义如下API: 12345UF(int N) ;//初始化 N 个点void union(int p,int q)//连接p qint find(int p)//N个点的分量标识符boolean conneted(int p ,int q)//p q联通返回trueint count()//连通分量数量 设计算法的任务分解为 定义数据结构高效表示连通. 高效实现API方法. 实现算法 叙述原理,不拘泥于代码 quick-find 第一印象,所谓连通两个点,类似物理上的通路,表示两个点的id的值 相同即可. p q 连通,则标识量置为相同值. 分析 非常直观 find conneted 非常快. union随着需要连接的节点数量而增大,每次执行 union 都需要遍历整个网格.时间复杂度平方. 大型网格union成本不可接收. 改进 从标识量入手,降低 union 复杂度,即使意味着 find conneted 等成本上升. 平衡各个方法成本. quick-union 肯定要对标识量下手了,极端一点,将标识量 改为类似树木生长的实现,每个连通拥有一个根元素.conneted 判断两个节点的根元素是否相同.union 连通 即将两个连通的根元素 链接.find 直接返回根节点. 这样 union 的复杂度降低,找到根节点,新建一个链接即可完成. 分析 逻辑上也比较好理解,类似 连通节点,用绳子串起来了. union 的时间复杂度 降低到了线性级别. 但 find 的成本在最糟糕情况下到了 平方 级别. 最糟糕生长情况,从上到下,一个深度只有一个节点. 改进 由导致 find 最糟糕情况入手,避免这种情况.关注点在 树生长的过程. 加权quick-union 我们的目标 控制树的生长,即控制树生长的深度,尽力减少平均深度. 主要做法: union 时,区分大小树,(节点多的树为大),小树只能链接到大树.代码上 要增加一个 数组来标识 一个连通的节点数. 分析 可以很好控制 树生长的高度. 各个方法的时间复杂度,平衡很好. 但是还不是最完美. 改进 继续改进 union 时操作,控制树生长的高度. 路径压缩的加权quick-union 对 union 操作似乎无法继续改进. 但是从直觉上考虑,要控制树的深度,最直接的情况就是所有节点直接连接到根节点. so,在 find 操作中 加入这个转换,将所有节点 直接 连接到根节点. 分析 这是我们目前可以找到的最优解. 但不是所有操作都可以在场数级别. 总结 完整详细定义问题,找到解决问题所必须的抽象操作并定义 API 对于搜索类操作,改进算法的一个方面是: 增加一个数据点可以访问的维度.不限于周围元素,通过某种对应关系,拓展维度.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vscode系列-python]]></title>
    <url>%2F2018%2F05%2F24%2FVscode%E7%B3%BB%E5%88%97-python%2F</url>
    <content type="text"><![CDATA[环境 vscode 1.20.x ubuntu 备注: 转载自用VSCode写python的正确姿势 前言 写嵌入式的c语言太难搞了,受够了盗版 sourceinsight 艰难的代码提示和补全之后,尝试换一款编辑器. 跨平台,支持多种语言,自由度高. vim 和 Emacs 命令行 有一点学习成本. 最后选定了 vscode 业余写点 python 和 java 写写 markdown 博客等等 (看pdf也行…). 注意vscode首先是个编辑器,其他的功能都是通过 插件 + 后端 实现的. 需求 代码补全&amp;语法检查 pip安装flake8,在配置文件配置一下就可以使用. 代码格式化 pip安装yapf,在配置文件配置一下就可以使用. 编译&amp;运行 vscode官方python插件 安装 当然是python3了.不否认python2还在很多库中使用,但是面向未来,学习还是以最新为主. windows / Linux 下 python3 和 vscode 安装不需多言. python插件 打开VScode，Ctrl+p 输入 “ext install python”，搜索时间可能会比较长 下载微软Microsoft出品的Python,全局翻墙最佳,要不然外网服务器,你懂的 重新加载后,直接F5即可运行. flake8 命令行 1pip install flake8 文件-&gt;首选项-&gt;用户设置，在settings.json文件中输入 1"python.linting.flake8Enabled": true yapf 命令行 1pip install yapf 文件-&gt;首选项-&gt;用户设置，在settings.json文件中输入 1"python.formatting.provider": "yapf" 结语 没了,vscode对前端和高级语言支持真的很好.基本上手即用.]]></content>
      <categories>
        <category>linux笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android随手记—AndroidStudio启动0xc0000005]]></title>
    <url>%2F2018%2F05%2F05%2FAndroid%E9%9A%8F%E6%89%8B%E8%AE%B0-AndroidStudio%E5%90%AF%E5%8A%A80xc0000005%2F</url>
    <content type="text"><![CDATA[编程环境 Android Studio 3.1.2 问题 升级win10 到了4月份更新1803,启动AS给我来了个 0xc0000005 过程 一切正常升级,除了自己手贱把 Windows Defender 升级到1803 额外的安全全部打开.. 解决 万能的stackoverflow 给了答案.问题就在于 Windows Defender 下的 ALSR 好像是内存随机化..(具体意义不太明确) https://stackoverflow.com/questions/47500401/android-studio-cannot-be-initialized-0xc0000005 翻译成中文: Windows Defender -&gt; 应用与程序控制 -&gt;Exploit Protection -&gt;程序设置 -&gt;添加程序自定义 找到android stuido安装目录下的 /bin/studio64.exe 一定要完整目录.编辑 找到两个ASLR相关项.强制化ASLR 和 自下而上ASLR ,替换系统设置,关掉.重启AS. 备注 win10高级选项 别乱动…]]></content>
      <categories>
        <category>Android随手记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python—生成测试文件]]></title>
    <url>%2F2018%2F04%2F29%2Fpython%E2%80%94%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[需要一些原始数据,简单记录 12345678910111213141516171819#!/usr/bin/env python#-*- coding:utf-8 -*-import osimport randomimport stringdef getWhitList_Size(ListSize): numCount=ListSize i=0 filePath="List.txt" with open(filePath, "w", encoding="GBK") as f: while i&lt;numCount: f.write(''.join(random.choices(string.ascii_uppercase + string.digits, k=6))) f.write("\n") i=i+1getWhitList_Size(50000) python文件操作: 其他语言也大同小异. open write close 核心是 随机生成字符串 1''.join(random.choices(string.ascii_uppercase + string.digits, k=6)) random.choices(population, weights=None, *, cum_weights=None, k=1)从population集群中随机抽取K个元素 weights是相对权重列表 cum_weights是累计权重 两个参数不能同时存在.(注:random.choices是python3.6后新增方法) string.ascii_uppercase + string.digits 是string包下代表大写字母和字符串的集合.]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux笔记—共享内存]]></title>
    <url>%2F2018%2F04%2F19%2Flinux%E7%AC%94%E8%AE%B0%E2%80%94%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[共享内存 即多进程之间直接对读写同一段内存.相比较管道及消息队列,显而易见的好处是速度快,所有的IPC方法中效率最高.但共享内存并未提供同步机制,需要自行实现. 原理 顾名思义，共享内存就是说两个不同的进程A、B可以共同享有一块内存区域 整个处理流程是 进程A第一次访问该页中的数据时, 生成一个缺页中断. 内核读入此页到内存并更新页表使之指向此页. 进程B访问同一页面而出现缺页中断,内核只将进程B的页表登记项指向次页即可. 进程A.B 即可访问同一段内存. 使用 shmget函数shmget被用来开辟/初始化一段共享内存.其他进程使用相同的key 通过 shgat 获取同一段共享内存.，只有shmget函数才直接使用信号量键,所有其他的信号量函数使用由semget函数返回的信号量标识符. 函数原型 1int shmget(key_t key, size_t size, int shmflg); key : 与信号量的semget函数一样，使用共享内存key（非0整数）shmget函数成功时返回一个与key相关的共享内存标识符(非负整数),用于多进程的共享.调用失败返回-1.size : 开辟的共享内存大小(字节).shmflg : 权限控制,与IPC_CREAT做或操作,控制其他进程对共享内存权限. 0644即代表其他进程只有读的权限. shmat函数用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间 函数原型 1void *shmat(int shm_id, const void *shm_addr, int shmflg); shm_id: 由shmget函数返回的共享内存标识.shm_addr: 指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址.shm_flg: 标志位，通常为0. shmdt函数将共享内存从当前进程中分离,使该共享内存对当前进程不再可用. 函数原型: 1int shmdt(const void *shmaddr); shmaddr: shmat函数返回的地址指针，调用成功时返回0，失败时返回-1. shmctl函数控制共享内存. 函数原型 1int shmctl(int shmid, int cmd, struct shmid_ds *buf) shm_id: shmget函数返回的共享内存标识符 command: 要采取的操作,以下三个值 ： IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值. IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值 IPC_RMID：删除共享内存段 buf: 结构指针,指向共享内存模式和访问权限的结构. 1234567shmid_ds结构至少包括以下成员：struct shmid_ds&#123; uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode;&#125;; 系统限制及规避大小 linux默认限制共享内存总大小由 SHMMAX 值确定.默认值未32MB 读取 1cat /proc/sys/kernel/shmmax 当超过系统限制时 提示 unable to attach to shared memory. 规避 直接修改/proc.无需重启 1echo "2147483648" &amp;gt; /proc/sys/kernel/shmmax 可以将命令写入启动脚本 /etc/rc.local中.保证重启生效 使用 sysctl 命令修改 1sysctl -w kernel.shmmax=2147483648 可以将此参数插入到 /etc/sysctl.conf 启动文件中 1echo "kernel.shmmax=2147483648" &amp;gt;&amp;gt; /etc/sysctl.conf 永久生效. 数量 与大小类似的,共享内存创建的总数量由 SHMMNI 参数确定. 读取 1cat /proc/sys/kernel/shmmni 默认情况下是 4096. 一般不需要修改. 同一进程多次shmat shmat即挂载共享内存到进程的进程空间. 当同一进程多次调用shmat 挂载同一共享内存时,shamat每次返回的地址都不同,相当于在进程的线性空间中存在多个实际指向同一块共享内存.直到最后进程线性空间消耗殆尽. 解决:需要在挂载共享内存前,判断申请的共享内存指针是否为空,为 NULL ,则第一次加载此共享内存.否则不再重复加载. 123456void* p = NULL;/*其他操作*/if (NULL == p)&#123; p = shmat(shmid,p,0666);&#125; 多个进程相同key多次创建共享内存 共享内存创建有大小之分.key相同情况下,容量小的共享内存会获得之前创建的大的共享内存的内容.有可能导致之前创建共享内存的进程崩溃. 解决 在shmage使用IPC_EXCL标记.现行判断共享内存是否已创建.如果已创建则挂载,没有创建返回失败后,再创建. 123456Shmid = Shmget(key, size,IPC_CREATE|IPC_EXCL); if (-1 != shmid) &#123; /*错误处理*/ Shmid = Shmget(key, size,IPC_CREATE);&#125; 不通过key 标记同一块共享内存.shmget使用 kry = IPC_PRIVATE ,linux会忽略key值,直接新建一块共享内存.返回标识,通过管道/文件方式共享给其他进程使用. 共享内存删除 调用shmctl 删除共享内存后,共享内存并不会立刻被系统清理. 首先共享内存的 shmid_ds结构中的 shm_nattch 减一.该共享内存从调用shmctl的进程剥离.但 shm_nattch 不为 0 的情况下,即仍然有别进程连接的情况下.共享内存并不会立刻清除. 只有在 shm_nattch 为 0 ,没有任何进程连接的情况下,系统才会清理 这段共享内存. 该段共享内存被任何连接的进程执行 shmctl 删除操作后, 新的进程将无法连接到该段共享内存. 与之对应的 Shmdt ,只是将共享内存由 调用的进程空间剥离.不会影响其他进程连接到该段共享内存. 应用 多进程共享数据.以链表为例. 有两种方式: 开辟一段共享内存,之后存入整个链表.将共享内存连接到各个进程. 优点: 对原有代码改动少. 缺点: 封装链表操作时,各个进程头节点偏移量不同,不能简单的通过 *p-&gt;next 访问. 有共享内存大小限制. 每一个链表节点对应一个共享内存.开辟同等数量的共享内存. 优点 可以随用随创,相对节省内存. 链表节点next 存储相对链表头节点偏移即可,访问操作相对单一共享内存容易. 缺点 受限于 linux 默认 4096的总数量限制.且总数不易更改. 开辟新链表节点相对复杂. 实际使用中第一种较为常见. 同步 与共享内存类似的信号量,也是跨进程的.信号量是比较一种比较方便配合共享内存同步的方式.]]></content>
      <categories>
        <category>linux笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android随手记—Rxjava2]]></title>
    <url>%2F2018%2F04%2F14%2FAndroid%E9%9A%8F%E6%89%8B%E8%AE%B0-Rxjava2%2F</url>
    <content type="text"><![CDATA[背景 编程环境 Android Studio 3.2 解除订阅 CompositeDisposable: 得到一个Disposable实例时 调用CompositeDisposable.add()添加到订阅 生命周期结束 CompositeDisposable.clear() 可快速解除.]]></content>
      <categories>
        <category>Android随手记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题汇总—Android]]></title>
    <url>%2F2018%2F04%2F07%2F%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB-Android%2F</url>
    <content type="text"><![CDATA[资料来源如下 常用的Android开发的一些技能点以及BAT公司面试题汇集 感觉自己白学了////😂//// 一道一道的找答案.. Android面试题Android面试题除了Android基础之外，更多的问的是一些源码级别的、原理这些等。所以想去大公司面试，一定要多看看源码和实现方式，常用框架可以试试自己能不能手写实现一下，锻炼一下自己。 一、Android基础知识点 四大组件是什么 四大组件的生命周期和简单用法 Activity之间的通信方式 Activity各种情况下的生命周期 横竖屏切换的时候，Activity 各种情况下的生命周期 Activity与Fragment之间生命周期比较 Activity上有Dialog的时候按Home键时的生命周期 两个Activity 之间跳转时必然会执行的是哪几个方法？ 前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。 Activity的四种启动模式对比 Activity状态保存于恢复 fragment各种情况下的生命周期 Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？ 如何实现Fragment的滑动？ fragment之间传递数据的方式？ Activity 怎么和Service 绑定？ 怎么在Activity 中启动自己对应的Service？ service和activity怎么进行数据交互？ Service的开启方式 请描述一下Service 的生命周期 谈谈你对ContentProvider的理解 说说ContentProvider、ContentResolver、ContentObserver 之间的关系 请描述一下广播BroadcastReceiver的理解 广播的分类 广播使用的方式和场景 在manifest 和代码中如何注册和使用BroadcastReceiver? 本地广播和全局广播有什么差别？ BroadcastReceiver，LocalBroadcastReceiver 区别 AlertDialog,popupWindow,Activity区别 Application 和 Activity 的 Context 对象的区别 Android属性动画特性 如何导入外部数据库? LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。 谈谈对接口与回调的理解 回调的原理 写一个回调demo 介绍下SurfView RecycleView的使用 序列化的作用，以及Android两种序列化的区别 差值器 估值器 Android中数据存储方式 二、Android源码相关分析 Android动画框架实现原理 Android各个版本API的区别 Requestlayout，onlayout，onDraw，DrawChild区别与联系 invalidate和postInvalidate的区别及使用 Activity-Window-View三者的差别 谈谈对Volley的理解 如何优化自定义View 低版本SDK如何实现高版本api？ 描述一次网络请求的流程 HttpUrlConnection 和 okhttp关系 Bitmap对象的理解 looper架构 ActivityThread，AMS，WMS的工作原理 自定义View如何考虑机型适配 自定义View的事件 AstncTask+HttpClient 与 AsyncHttpClient有什么区别？ LaunchMode应用场景 AsyncTask 如何使用? SpareArray原理 请介绍下ContentProvider 是如何实现数据共享的？ AndroidService与Activity之间通信的几种方式 IntentService原理及作用是什么？ 说说Activity、Intent、Service 是什么关系 ApplicationContext和ActivityContext的区别 SP是进程同步的吗?有什么方法做到同步？ 谈谈多线程在Android中的使用 进程和 Application 的生命周期 封装View的时候怎么知道view的大小 RecycleView原理 AndroidManifest的作用与理解 三、常见的一些原理性问题 Handler机制和底层实现 Handler、Thread和HandlerThread的差别 handler发消息给子线程，looper怎么启动？ 关于Handler，在任何地方new Handler 都是什么线程下? ThreadLocal原理，实现及如何保证Local属性？ 请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系 请描述一下View事件传递分发机制 Touch事件传递流程 事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？ View和ViewGroup分别有哪些事件分发相关的回调方法 View刷新机制 View绘制流程 自定义控件原理 自定义View如何提供获取View属性的接口？ Android代码中实现WAP方式联网 AsyncTask机制 AsyncTask原理及不足 如何取消AsyncTask？ 为什么不能在子线程更新UI？ ANR产生的原因是什么？ ANR定位和修正 oom是什么？ 什么情况导致oom？ 有什么解决方法可以避免OOM？ Oom 是否可以try catch？为什么？ 内存泄漏是什么？ 什么情况导致内存泄漏？ 如何防止线程的内存泄漏？ 内存泄露场的解决方法 内存泄漏和内存溢出区别？ LruCache默认缓存大小 ContentProvider的权限管理(解答：读写分离，权限控制-精确到表级，URL控制) 如何通过广播拦截和abort一条短信？ 广播是否可以请求网络？ 广播引起anr的时间限制是多少？ 计算一个view的嵌套层级 Activity栈 Android线程有没有上限？ 线程池有没有上限？ ListView重用的是什么？ Android为什么引入Parcelable？ 有没有尝试简化Parcelable的使用？ 四、开发中常见的一些问题 ListView 中图片错位的问题是如何产生的? 混合开发有了解吗？ 知道哪些混合开发的方式？说出它们的优缺点和各自使用场景？（解答：比如:RN，weex，H5，小程序，WPA等。做Android的了解一些前端js等还是很有好处的)； 屏幕适配的处理技巧都有哪些? 服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？ 动态布局的理解 怎么去除重复代码？ 画出 Android 的大体架构图 Recycleview和ListView的区别 ListView图片加载错乱的原理和解决方案 动态权限适配方案，权限组的概念 Android系统为什么会设计ContentProvider？ 下拉状态栏是不是影响activity的生命周期 如果在onStop的时候做了网络请求，onResume的时候怎么恢复？ Bitmap 使用时候注意什么？ Bitmap的recycler() Android中开启摄像头的主要步骤 ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化？ 点击事件被拦截，但是想传到下面的View，如何操作？ 微信主页面的实现方式 微信上消息小红点的原理 CAS介绍（这是阿里巴巴的面试题，我不是很了解，可以参考博客: CAS简介）]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vscode系列—c语言]]></title>
    <url>%2F2018%2F03%2F24%2FVscode%E7%B3%BB%E5%88%97-c%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[环境 vscode 1.20.x ubuntu 前言 写嵌入式的c语言太难搞了,受够了盗版 sourceinsight 艰难的代码提示和补全之后,尝试换一款编辑器. 跨平台,支持多种语言,自由度高. vim 和 Emacs 命令行 有一点学习成本. 最后选定了 vscode 业余写点 python 和 java 写写 markdown 博客等等 (看pdf也行…). 注意vscode首先是个编辑器,其他的功能都是通过 插件 + 后端 实现的. 需求 代码补全 最重要的c语言的结构体补全!!!. 结构体补全曾经深深折磨这我,直到遇到了clang…. 顺带着解决了语法检查,clang的语法检查很是好用. 插件: C/C++ Clang Command Adapter 语法检查 常规clang足矣,但还不够. clang是编译器,但有些错误编译器还是无能为力,祭出Cppcheck,C/C++代码缺陷静态检查工具. 插件: cppcheck 代码格式化 眼瞅着clang 配套的clang-format . 插件: Clang-Format 函数跳转 微软官方c/c++插件就行了,但官方插件自带代码补全和语法检查,不怎么好,一定要关掉否则会与clang冲突. 插件: C/C++ for Visual Studio Code 安装 上文书说到,vscode实现编辑器以外的功能都需要插件+后端的形式 so 一般的安装步骤如下: 安装后端,如clang 、cppcheck 等. 安装对应插件 修改配置文件(json格式) 最后针对处理头文件等. 代码补全/语法检查 代码补全/语法检查都依赖于后端clang,而ubunt自带的clang 3.8版本,而clang最新的稳定版本为5.0,这里选择5.0版本. 参考 &gt; https://apt.llvm.org/ 安装clang-5.0 修改ubuntu源 /etc/apt/source.list 添加llvm官方源 12deb http://apt.llvm.org/trusty/ llvm-toolchain-trusty-5.0 maindeb-src http://apt.llvm.org/trusty/ llvm-toolchain-trusty-5.0 main 添加llvm源的 密钥 1wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add - 更新软件列表,这样就可以安装5.0版本了 1sudo apt-get update 安装clang5.0 1sudo apt-get install clang-5.0 lldb-5.0 或者安装全部llvm root用户下(太多偷个懒) 1apt-get install clang-5.0 clang-tools-5.0 clang-5.0-doc libclang-common-5.0-dev libclang-5.0-dev libclang1-5.0 libclang1-5.0-dbg libllvm-5.0-ocaml-dev libllvm5.0 libllvm5.0-dbg lldb-5.0 llvm-5.0 llvm-5.0-dev llvm-5.0-doc llvm-5.0-examples llvm-5.0-runtime clang-format-5.0 python-clang-5.0 libfuzzer-5.0-dev 完整安装需要良好的网络,llvm大概300M,等下就好. 验证 命令行输入 clang-5.0 不会提示无此命令即可. clang ubuntu自带版本3.8 1sudo apt-get install clang clang插件及配置 插件名 C/C++ Clang Command Adapter,在vscode中搜索下载即可.网络环境限制还可以在vscode官网下载vsix格式的文件,离线安装. 安装完成后,进入重头戏,也是初次上手vscode最难适应的地方. 进入vscode的设置 setting.json ,分为 用户区设置 和 工作区设置. 用户区设置,是用户自定义全局设置,覆盖vscode默认设置,每个工程都有效. 工作区设置,是针对本工程的个性化设置,只在本工程生效. 简易是将clang等设置 保存在用户区,工作区保存追对 clang 的头文件设置. 用户区设置 12345"clang.executable": "clang-5.0","clang.completion.triggerChars": [ ".", ":", "&gt;"], clang.executable : 后端clang的路径,这里是 clang-5.0 ,也可以写入 clang 的安装目录. clang.completion.triggerChars : 触发代码补全的输入,常用的 . : &gt;. 工作区设置 12345678910111213141516"clang.cflags": [ "-std=c99", "-I$&#123;cwd&#125;", "-I/usr/include", "-I/usr/include/c++/5", "-I/usr/include/x86_64-linux-gnu/c++/5", "-I/usr/include/c++/5/backward", "-I/usr/lib/gcc/x86_64-linux-gnu/5/include", "-I/usr/local/include", "-I/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed", "-I/usr/include/x86_64-linux-gnu", "-I/usr/include", "-I$&#123;workspaceRoot&#125;", "-I$&#123;workspaceRoot&#125;/Include", "-I$&#123;workspaceRoot&#125;/Libs/Cjson/Include" ], clang.cflags : &quot;-std=c99&quot; clang语法检查时 c/c++ 语言标准,要兼容历史项目,这就选的 c99 ,新项目简易 直接 c11.clang进行代码补全/语法检查的头文件路径, 格式是 -I路径 ,支持直接和间接路径(${workspaceRoot}). 头文件一定要写全,否则一直会有错误提示. 保存后,代码补全/语法检查 全部如上图所示. 语法检查 这里特指 cppcheck 安装cppcheck 我没有追求最新,直接通过ubuntu官方源安装 1sudo apt-get install cppcheck 安装完成,执行 cppcheck 命令,不提示无此命令即可. cppcheck插件及配置 搜索安装 cppcheck 同样配置分为用户区和工作区.工作区对应头文件设置. 用户区 12345"cppcheck.cppcheckPath": null,"cppcheck.standard": [ "c99", ],"cppcheck.language": "c", cppcheck.cppcheckPath : null时,会使用 cppcheck 命令指向的版本,也可以使用自定义路径. cppcheck.standard : cppcheck 检查时 c/c++版本,历史原因我这里还是 c99. cppcheck.language : 前置检查时 以 c 或者 c++ 检查.我这里都是 c 项目,填写 c . 工作区 12345678910111213141516"cppcheck.includePaths": [ "$&#123;cwd&#125;", "/usr/include", "/usr/include/c++/5", "/usr/include/x86_64-linux-gnu/c++/5", "/usr/include/c++/5/backward", "/usr/lib/gcc/x86_64-linux-gnu/5/include", "/usr/local/include", "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed", "/usr/include/x86_64-linux-gnu", "/usr/include", "$&#123;workspaceRoot&#125;", "$&#123;workspaceRoot&#125;/Include", "$&#123;workspaceRoot&#125;/Code/APP/Code/Libs/Cjson/Include"],"cppcheck.force": true cppcheck.includePaths : 头文件路径,这里没有 -I ,直接输入路径即可.支持直接和间接路径. cppcheck.force : 强制检查所有枚举所有可能配置,有多个项目同时在工作,这里我放到工作区了,如果代码量小的工程建议放在用户区,作为全局配置. 使用 左下角,点击cppcheck 如图 3个选择 分析当前打开文件 分析工作区所有文件 其他…没用过.. 函数跳转 直接使用微软的 C/C++ for Visual Studio Code 即可. 官方的很强大,带代码补全和语法检查,,可惜表现不太好.函数跳转很好用. 配置 搜索安装 C/C++ for Visual Studio Code 不用安装后端了,对应的配置就稍微麻烦了. 在项目根目录下 查找 .vscode文件夹,进入.应该由 setting.json文件,对应工作区设置. 新建c_cpp_properties.json ,写入以下内容. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&#123; "configurations": [ &#123; "name": "Mac", "includePath": [ "/usr/include", "/usr/local/include", "$&#123;workspaceRoot&#125;" ], "defines": [], "intelliSenseMode": "clang-x64", "browse": &#123; "path": [ "/usr/include", "/usr/local/include", "$&#123;workspaceRoot&#125;" ], "limitSymbolsToIncludedHeaders": true, "databaseFilename": "" &#125;, "macFrameworkPath": [ "/System/Library/Frameworks", "/Library/Frameworks" ] &#125;, &#123; "name": "Linux", "includePath": [ "/usr/include/c++/5", "/usr/include/x86_64-linux-gnu/c++/5", "/usr/include/c++/5/backward", "/usr/lib/gcc/x86_64-linux-gnu/5/include", "/usr/local/include", "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed", "/usr/include/x86_64-linux-gnu", "/usr/include", "$&#123;workspaceRoot&#125;", "$&#123;workspaceRoot&#125;/Include" ], "defines": [], "intelliSenseMode": "clang-x64", "browse": &#123; "path": [ "/usr/include/c++/5", "/usr/include/x86_64-linux-gnu/c++/5", "/usr/include/c++/5/backward", "/usr/lib/gcc/x86_64-linux-gnu/5/include", "/usr/local/include", "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed", "/usr/include/x86_64-linux-gnu", "/usr/include", "$&#123;workspaceRoot&#125;", "$&#123;workspaceRoot&#125;/Include" ], "limitSymbolsToIncludedHeaders": true, "databaseFilename": "" &#125; &#125;, &#123; "name": "Win32", "includePath": [ "C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/include", "$&#123;workspaceRoot&#125;" ], "defines": [ "_DEBUG", "UNICODE", "_UNICODE" ], "intelliSenseMode": "msvc-x64", "browse": &#123; "path": [ "C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/include/*", "$&#123;workspaceRoot&#125;" ], "limitSymbolsToIncludedHeaders": true, "databaseFilename": "" &#125; &#125; ], "version": 3&#125; 我们只关注linux下的设置,将常用头文件路径添加到 includePath 和 &quot;browse&quot;-&gt;&quot;path&quot;下.可以不用手工添加,项目文件下,光标 指向提示找不到的 include 头文件 ,会有 💡 提示添加路径到path中,搞定! 至此代码跳转应该可以使用了. ctrl 悬浮提示,点击跳转.还有其他快捷键爽翻天. 特别提醒 上文提到 C/C++ for Visual Studio Code 会与 clang 的代码提示和语法检查冲突,所以一定要记得在用户区设置关闭自带. 用户区设置 123"C_Cpp.autocomplete": "Disabled","C_Cpp.errorSquiggles": "Disabled","C_Cpp.formatting": "Disabled", 关闭自动补全 错误提示 和 代码格式化. 代码格式化 使用clang-5.0 配套的 clang-format-5.0即可. clang-format可以通过配置文件控制很多格式化细节,推荐使用. 安装clang-format 进行过 安装clang-5.0 后,执行如下命令即可. 1sudo apt-get install clang-format-5.0 ubuntu官方源 为3.8版本,也可以安装使用. 1sudo apt-get install clang-format 最好与clang版本保持一致. clang-format配置 这里使用配置文件形式详细自定义格式化.(也可以直接使用自带的几种格式,同样够用) 用户区设置 12"clang-format.assumeFilename": ".clang-format","clang-format.executable": "clang-format-5.0", clang-format.assumeFilename : 制定格式化的标准,这里是通过文件 .clang-format 来配置.还可以留空通过clang-format.fallbackStyle指定 LLVM, Google, Chromium, Mozilla, WebKit 之一为格式化标准. clang-format.executable : clang-format路径,这里安装的是 clang-format-5.0. 指定通过.clang-format文件为格式化标准后,在项目根目录下 新建 .clang-format 文件. 每个版本的 clang-format 都有对应的详细定制说明.5.0版本对应说明 官方有几个风格实例: Linux Kernel style 123456BasedOnStyle: LLVMIndentWidth: 8UseTab: AlwaysBreakBeforeBraces: LinuxAllowShortIfStatementsOnASingleLine: falseIndentCaseLabels: false 效果如下: 123456789101112131415161718192021222324void test()&#123; switch (x) &#123; case 0: case 1: do_something(); break; case 2: do_something_else(); break; default: break; &#125; if (condition) do_something_completely_different(); if (x == y) &#123; q(); &#125; else if (x &gt; y) &#123; w(); &#125; else &#123; r(); &#125;&#125; Visual Studio style 123456UseTab: NeverIndentWidth: 4BreakBeforeBraces: AllmanAllowShortIfStatementsOnASingleLine: falseIndentCaseLabels: falseColumnLimit: 0 效果如下: 123456789101112131415161718192021222324252627282930void test()&#123; switch (suffix) &#123; case 0: case 1: do_something(); break; case 2: do_something_else(); break; default: break; &#125; if (condition) do_somthing_completely_different(); if (x == y) &#123; q(); &#125; else if (x &gt; y) &#123; w(); &#125; else &#123; r(); &#125;&#125; 最后是我的自定义配置(中文说明),从网上收集+官方文档. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# 配置以什么语言format当前文件# CPP: C, C++, Objective-C, ObjectiveC++;Language: Cpp#在llvm的配置基础上加定制配置BasedOnStyle: LLVM #someLongFunction(argument1,# argument2);AlignAfterOpenBracket: Align# true: 表示对齐连续的紧跟注释（连续行使用双斜杠注释，包括在函数体内），多用于Model定义、property说明、私有成员变量说明；AlignTrailingComments: true#对齐连续赋值运算符AlignConsecutiveAssignments : true#若true，则对齐连续声明.AlignConsecutiveDeclarations : true#换行符选项 左对齐AlignEscapedNewlines: Left#水平对齐二目运算符和三目运算符的操作数AlignOperands : true# true：允许较短(一般只有一行，多为内联C函数)的Function在一行显示,如“int f() &#123; return 1; &#125;”，规定设为false；AllowShortFunctionsOnASingleLine: false#true: 允许较短的if判断在一行显示，否则换行显示（没有自动加花括号）；AllowShortIfStatementsOnASingleLine: true#??? true 允许较短的循环（while、for）在一行显示，否则换行显示（没有自动加花括号）；AllowShortLoopsOnASingleLine: true#true：允许只有Break语句的case标签在一行显示，false：不允许（自动换行显示）, 规范为不允许AllowShortCaseLabelsOnASingleLine: false#true：允许将较长的literal－String字符串分割成多行显示；AlwaysBreakBeforeMultilineStrings: falseBreakBeforeBraces: Allman#连续行的缩进长度（通常缩进＋设置值）， 一般用于首参数小于后续参数的method名字、多行的String－literalsContinuationIndentWidth: 4#设置代码的最大长度（回自动对代码长度进行换行显示，并对注释自动换行；当长度加大的时候，AllowAllParametersOfDeclarationOnNextLine＝true失效）ColumnLimit: 100#如果为真（true）, 分析最常见的格式化文件中“&amp;”和“\*”的对齐方式。pointeralignment则仅作为后备。DerivePointerAlignment: true#true: 将switch的case标签从switch表达式缩进一级；否则将switch表达式对齐；IndentCaseLabels: true#缩进字符长度IndentWidth: 4#所有位置的指针星号（＊）或取地址符号（&amp;）对齐位置：Left、Middle、Right，当作为乘号时候居中 （规范为Right）PointerAlignment: Right#整个文件任意位置最大能够保持的连续空行数（如果超过MAX值，减少到Max行，小于不管；）MaxEmptyLinesToKeep: 2#true:在赋值运算符之前添加一个空格，否则去掉；(规范为添加)SpaceBeforeAssignmentOperators: true#是否在括号之前添加一个空格，Never：任何情况都不添加；ControlStatements：只在控制结构（for、if、while）的地方添加空格；AlWays: 除开在function－like的的宏定义之外在任何地方都需要添加空格；（规范为ControlStatements）SpaceBeforeParens: ControlStatements#在紧跟注释之前所留空格数，一般建议为2个空格SpacesBeforeTrailingComments: 2UseTab: Never# 格式兼容C++11Standard: Cpp11#当前配置生效开关，true：打开，false：关闭DisableFormat: false 编译/调试 待续 结语 至此,vscode 编写c语言的体验就十分完整了.跨平台一致化的体验真的很好.推荐还在苦恼 c 编辑器的可以一试. 下一篇vscode的 python 配置.]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题汇总—java]]></title>
    <url>%2F2018%2F03%2F07%2F%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB-java%2F</url>
    <content type="text"><![CDATA[资料来源如下 常用的Android开发的一些技能点以及BAT公司面试题汇集 感觉自己白学了////😂//// 一道一道的找答案.. java面试题汇总熟练掌握java是很关键的，大公司不仅仅要求你会使用几个api，更多的是要你熟悉源码实现原理，甚至要你知道有哪些不足，怎么改进，还有一些java有关的一些算法，设计模式等等。 一、java基础面试知识点 java中==和equals和hashCode的区别 关系操作符 ==： 基本数据类型，== 判断的是左右两边操作数的值是否相等 引用数据类型，== 判断的是左右两边操作数的内存地址是否相同,是否是同一个对象。 equals方法 基类Object中的实例方法 本质是期望比较 对象的内容 hashCode方法,基类Object中的实例方法,返回一个int类型 hash值. 重写上述两个方法,必须保证hashCode与equals的结果一致性,内容相同的对象,hash值相同,比较返回 true hash值为确定对象在哈希表中位置的标识. int、char、long各占多少字节数 int 4字节 char 2个字节 long 8个字节 int与integer的区别 int为java的内置基本类型 integer 为int的包装类 探探对java多态的理解 类之间存在继承关系,子类可以重写父类相同的方法名. 调用时 子类直接调用自己实现的同命方法. String、StringBuffer、StringBuilder区别 String 是不可变对象,所有操作都会生成新的String对象 StringBuffer StringBuilder 为可变对象. StringBufferd 线程安全 StringBuilder 线程不安全,但是单线程性能好 什么是内部类？内部类的作用 内部类主要定义在类的内部 成员内部类 作为外部类的成员，可以直接使用外部类的所有成员和方法，即使是private 外部类要访问内部类的所有成员变量或方法，则需要通过内部类的对象来获取 成员内部类不能含有 static 的变量和方法 局部内部类 指内部类定义在方法和作用域内，就是在外部类的方法中定义的内部类就是局部内部类 局部内部类由于是在方法中定义的，其作用域也是在方法内部中，方法外执行到，则被JVM回收。局部内部类的实例化也只能在方法中进行 局部内部类方法中想要使用局部变量，该变量必须声明为 final 类型 静态内部类 修饰为static的内部类 直接引用 外部类.内部类 实例化: 外部类.内部类 对象 = new 外部类.内部类() 匿名内部类 局部内部类一种 没有名称,只能使用new声明new &lt;类或接口&gt; &lt;类的主体&gt; 使用最多的实例(创建线程):123456789101112public class Demo &#123; public static void main(String[] args) &#123; Thread t = new Thread() &#123; public void run() &#123; for (int i = 1; i &lt;= 5; i++) &#123; System.out.print(i + " "); &#125; &#125; &#125;; t.start(); &#125;&#125; 内部类能独立地继承自一个类（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。 抽象类和接口区别 抽象类是对事物的抽象,接口是对行为的抽象 抽象类的意义 更利于代码的维护和重用 抽象类与接口的应用场景 接口是为了使用它规范的某一个行为 抽象类是为了使用这个类属性和行为 抽象类是否可以没有方法和属性？ 可以 接口的意义 补足多重继承关系. 赋予多态更多的实现方式 泛型中extends和super的区别 &lt;? super T&gt; 代表泛型T及其父类 ?的下界 &lt;? extends T&gt; 代表泛型T及其子类 ?的上界 频繁往外读取内容的，适合用上界Extends。 经常往里插入的，适合用下界Super。 父类的静态方法能否被子类重写 否 静态方法与对象无关 进程和线程的区别 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。 线程是进程的一个实体, 是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序 健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 final，finally，finalize的区别 final 修饰符 修饰类标识无法再被继承 finally 用于错误处理 finalize 析构函数,但调用后 资源回收时间由 jvm决定 序列化的方式(待考) 序列化，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地 Json,Serializable,Parcelable,ObjectOutputStream Serializable 和Parcelable 的区别 Serializable是java api，Parcelable是Android api; Serializable过程需要大量的I/O操作,开销大,效率低 Parcelable过程不需要大量的I/O操作,开销小,效率高 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？ 可以被继承,但不能被重写,静态方法和静态属性是属于类. 静态内部类的设计意图 静态内部类可以独立存在，又希望只被外部类使用，private修饰的时候不被同一个包下的其他类使用。 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。 静态内部类的作用： 只是为了降低包的深度，方便类的使用， 静态内部类适用于包含类当中，但又不依赖与外在的类，不能使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。 在创建静态内部类的时候，不需要外部类对象的引用。 非静态内部类有一个很大的优点：可以自由使用外部类的所有变量和方法 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用 见上内部类 谈谈对kotlin的理解 代码量下降 语法糖 与java 100%兼容 函数式编程 闭包和局部内部类的区别 string 转换成 integer的方式及原理 二、java深入源码级的面试题（有难度） 哪些情况下的对象会被垃圾回收机制处理掉？ 讲一下常见编码方式？ utf-8编码中的中文占几个字节；int型几个字节？ 静态代理和动态代理的区别，什么场景使用？ Java的异常体系 谈谈你对解析与分派的认识。 修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？ Java中实现多态的机制是什么？ 如何将一个Java对象序列化到文件里？ 说说你对Java反射的理解 说说你对Java注解的理解 说说你对依赖注入的理解 说一下泛型原理，并举例说明 Java中String的了解 String为什么要设计成不可变的？ Object类的equal和hashCode方法重写，为什么？ 三、数据结构 常用数据结构简介 并发集合了解哪些？ 列举java的集合以及集合之间的继承关系 集合类以及集合框架 容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 Java容器类） List,Set,Map的区别 List和Map的实现方式以及存储方式 HashMap的实现原理 HashMap数据结构？ HashMap源码理解 HashMap如何put数据（从HashMap源码角度讲解）？ HashMap怎么手写实现？ ConcurrentHashMap的实现原理 ArrayMap和HashMap的对比 HashTable实现原理 TreeMap具体实现 HashMap和HashTable的区别 HashMap与HashSet的区别 HashSet与HashMap怎么判断集合元素重复？ 集合Set实现Hash怎么防止碰撞 ArrayList和LinkedList的区别，以及应用场景 数组和链表的区别 二叉树的深度优先遍历和广度优先遍历的具体实现 堆的结构 堆和树的区别 堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？ 什么是深拷贝和浅拷贝 手写链表逆序代码 讲一下对树，B+树的理解 讲一下对图的理解 判断单链表成环与否？ 链表翻转（即：翻转一个单项链表） 合并多个单有序链表（假设都是递增的） 四、线程、多线程和线程池 开启线程的三种方式？ 线程和进程的区别？ 为什么要有线程，而不是仅仅用进程？ run()和start()方法区别 如何控制某个方法允许并发访问线程的个数？ 在Java中wait和seelp方法的不同； 谈谈wait/notify关键字的理解 什么导致线程阻塞？ 线程如何关闭？ 讲一下java中的同步的方法 数据一致性如何保证？ 如何保证线程安全？ 如何实现线程同步？ 两个进程同时要求写或者读，能不能实现？如何防止进程的同步？ 线程间操作List Java中对象的生命周期 Synchronized用法 synchronize的原理 谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解 static synchronized 方法的多线程访问和作用 同一个类里面两个synchronized方法，两个线程同时访问的问题 volatile的原理 谈谈volatile关键字的用法 谈谈volatile关键字的作用 谈谈NIO的理解 synchronized 和volatile 关键字的区别 synchronized与Lock的区别 ReentrantLock 、synchronized和volatile比较 ReentrantLock的内部实现 lock原理 死锁的四个必要条件？ 怎么避免死锁？ 对象锁和类锁是否会互相影响？ 什么是线程池，如何使用? Java的并发、多线程、线程模型 谈谈对多线程的理解 多线程有什么要注意的问题？ 谈谈你对并发编程的理解并举例说明 谈谈你对多线程同步机制的理解？ 如何保证多线程读写文件的安全？ 多线程断点续传原理 断点续传的实现 并发编程有关知识点（这个是一般Android开发用的少的，所以建议多去看看）：平时Android开发中对并发编程可以做得比较少，Thread这个类经常会用到，但是我们想提升自己的话，一定不能停留在表面，,我们也应该去了解一下java的关于线程相关的源码级别的东西。 学习的参考资料如下： Java 内存模型 java线程安全总结 深入理解java内存模型系列文章 线程状态： 一张图让你看懂JAVA线程间的状态转换 锁： 锁机制：synchronized、Lock、Condition Java 中的锁 并发编程： Java并发编程：Thread类的使用 Java多线程编程总结 Java并发编程的总结与思考 Java并发编程实战—–synchronized 深入分析ConcurrentHashMap]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结]]></title>
    <url>%2F2018%2F01%2F22%2F2017%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2016 找到了兴趣-Android开始正式学习。 搭建了自己的blog，虽然周围人没人关注，有一篇日子的阅读量过了1万，还是很惊喜的 嵌入式工作没用找到满意的，只能说等春招 Andoid的实习，这段时间努力提高自己， 放弃了考研 心情走过了类似抑郁的经历，对体制种种各有看法，是对是错，让时间见证 2017 希望有自己的收入，经济相对自由一点 谈一段恋爱，遇到合适的女孩吧 Android的路上，顺利一点吧 不给自己设定限制，走一步再走一步 2017 工作了,有了一点自己的收入 有喜欢的人,却很无力的选择遗忘 在从事android以外的工作,2018准备转行. 2018 迟到的终结 转行android,补足基础. 日常迁移到linux下,熟悉python,提升效率. 博客不要断,记清楚自己的目标 体制重重,守护好家人,除此之外,别无他求. 保持自己对环境的体察,珍惜剩下的时间. 要记得 有过的梦想,即使已经遥不可及,不等于要违背自己的底线.]]></content>
      <categories>
        <category>随</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python—函数式编程]]></title>
    <url>%2F2018%2F01%2F19%2Fpython%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[函数式编程 纯函数式编程没有变量,一个函数只要输出确定,输出就是确定的,称为没有副作用.使用变量的函数内部由于变量状态不确定性,有副作用. 函数式编程另一个特点是允许函数本身作为参数传入,也可以直接返回另外一个函数. python对函数式编程提供有限支持.(还使用变量 so不是纯函数式编程语言)高阶函数 python中函数本身也可以赋值给变量,变量可以指向函数 函数的参数可以传入另一个函数,这种函数称为高阶函数. map/reduce map()接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回 示例 1list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]) # list所有数字转为字符串 reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算 示例12345678910&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; def char2num(s):... digits = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;... return digits[s]...&gt;&gt;&gt; reduce(fn, map(char2num, '13579'))13579 filter filter()接收一个函数和一个序列。filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 filter()函数返回的是一个 惰性序列 Iterator，也就是一个惰性序列,需要用list()函数获得所有结果并返回list 示例123456789def is_odd(n): return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) # 只保留奇数def not_empty(s): return s and s.strip()list(filter(not_empty, ['A', '', 'B', None, 'C', ' '])) # 删除空字符 sorted sorted()函数接收一个key函数来实现自定义的排序.第三个参数reverse=True决定正序倒序. 示例: 1234567891011121314151617181920212223242526272829 &gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'],key=str.lower) ['about', 'bob', 'Credit', 'Zoo'] &gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) ['Zoo', 'Credit', 'bob', 'about'] ``` ### 返回函数* 将函数作为结果返回.(很随便😂)* 闭包（Closure）:相关参数和变量都保存在返回函数.* **note:**返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用* 示例(坑): ```py def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fs f1, f2, f3 = count() &gt;&gt;&gt; f1() 9 &gt;&gt;&gt; f2() 9 &gt;&gt;&gt; f3() 9 返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9 一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变 示例:123456789def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs 匿名函数 不显式定义的函数. python中是 lambda 但与java不同. python中lambda限制，只能有一个表达式，不用写return，返回值就是该表达式的结果 匿名函数不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数 示例1f = lambda x: x * x 装饰器 代码运行期间,动态增加功能方式称为装饰器(Decorator) 示例 12345678910111213def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper@logdef now(): print('2015-3-25')&gt;&gt;&gt; now()call now():2015-3-25 如示例,装饰器 接受一个函数作为参数,并返回原函数.在原函数定义时,以 @ xxx作为标记.示例1 为2层,如果打印文本可以自定义. 示例 123456789101112131415def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator@log('execute')def now(): print('2015-3-25')&gt;&gt;&gt; now()execute now():2015-3-25 打印可自定义 又加上了一层. 如上两种定义后,函数对象的名称等发生了变化,so,终极版 Python内置的functools.wraps 会将原始函数的__name__等属性复制到wrapper()函数中. 示例12345678910111213141516171819import functools# 不带参数def log(func): @functools.wraps(func) def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper# 带参数def log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 偏函数 functools.partial的作用是把一个函数的某些参数设置默认值，返回一个新的函数. 示例: 1234import functoolsint2 = functools.partial(int, base=2)int2('1000000') 注意: 仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值 由于python 中函数也可以最为参数传入,so,参数固定成某一个函数也可. 同理: *args 和 **kw 也可以. 简化函数调用.]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python—高级特性]]></title>
    <url>%2F2018%2F01%2F19%2Fpython%E2%80%94%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[高级特性 代码精炼 python代码量越少,开发效率越高.切片 取list或tuple的部分元素 示例 12L[0:3] #0到3,但结果不包括索引3L[:3] #0可省略 12L[-2:] #-2到0 但不包括索引0L[-2:-1] #-2 123L[:10:2] #前10 每隔2个取一个L[::5] #所有,每隔5个取一个L[:] #原样复制 对tuple取切片,结果依然是tuple. 字符串可以看作一个list,每个字符占一位. 迭代 迭代很随便…太随便了… list tuple不多说了 dict字典也可以迭代,因为无序,输出的顺序不一定相同.默认迭代的是key 但value 也可以迭代,key value也可以同时迭代 12for value in d.values()for k, v in d.items() 上文书中说的,字符串可以当作list,所以也可以迭代. 问题来了,如何判断可迭代对象?collections模块的Iterable类型判断 123&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代True 类似c/java的带下标循环实现?Python内置的enumerate函数,把一个list变成索引-元素对 12for i, value in enumerate(['A', 'B', 'C']): print(i, value) 列表生成式 用来生成list 示例: [1x1, 2x2, 3x3, …, 10x10] 12[x * x for x in range(1, 11)] [m + n for m in 'ABC' for n in 'XYZ'] #两层 for可以同时循环两个甚至多个变量,dict的items()可以同时迭代key和value 123d = &#123;'x': 'A', 'y': 'B', 'z': 'C' &#125; # 多个变量[k + '=' + v for k, v in d.items()] # 生成list[s.lower() for s in L] # 全部小写 生成器 generator 依照某种算法不断循环生成数据,而不是一次性生成完.节省大量空间. 创建generator 把列表生成式的[]改成() 1g = (x * x for x in range(10)) 调用next(g)可获取下一个值.最常用for n in g:代入for循环.也没有抛出错误. 定义一个包含yield关键字的函数. 1234567def fib(max):n, a, b = 0, 0, 1while n &lt; max: yield b a, b = b, a + b n = n + 1return 'done' 变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 用for循环调用generator时，拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中. 迭代器 可以被for循环的对象统称为可迭代对象：Iterable使用isinstance()判断一个对象是否是Iterable对象 1isinstance(&#123;&#125;, Iterable) 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator 表示一个惰性计算的序列 Iterator甚至可以表示一个无限大的数据流isinstance()判断一个对象是否是Iterator对象 1isinstance((x for x in range(10)), Iterator) 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 Python的for循环本质上就是通过不断调用next()]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python—面向对象]]></title>
    <url>%2F2018%2F01%2F19%2Fpython%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象 类 方法 实例 封装 继承 多态 类和实例 示例 12345678910class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score))bart = Student('Bart Simpson', 59) 定义类的关键词与java一样 class 括号内为继承的父类.没有父类时,选择 object 作为基类.(object是所有类的基类) 变量比较特殊,不像java中有单独字段.python 类中变量定义是在__init__方法 方法的声明和函数类似. def 方法名 (参数) 类中 第一个参数必须是self,意为创建的实例自身.方法中调用类中其他变量都要通过 self.xxx 访问. 一些必须实现的属性在__init__方法中定义.如示例.第一个参数是 self 之后是具体变量值,在方法内 使用self访问类中定义的变量. Python允许对实例变量绑定任何数据,so just do it😈 访问限制 类似java private 字段的python实现 属性的名称前加上两个下划线 __ 该属性就成为了类的私有属性,只能在实例的内部访问.(self.xxx) 获取/修改,使用 get/set 获取或修改对应属性.(一般在set中可以添加类型检查) 类似__xxx__的变量，双下划线开头，并且以双下划线结尾的，是特殊变量.特殊变量是可以直接访问的，不是private变量.也最好不要定义__xxx__变量名 以下划线开头的实例变量名，例如_name.可以在外部访问的，但是，约定俗成,请直接忽视. 特例: 双下划线开头的实例变量不能直接访问是因为Python解释器对外把__name变量改成了_Student__name.仍然可以通过_Student__name来访问__name变量. 一个错误设置示例: 12345678&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.get_name()'Bart Simpson'&gt;&gt;&gt; bart.__name = 'New Name' # 设置__name变量！&gt;&gt;&gt; bart.__name'New Name'&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name'Bart Simpson' 如同示例,外部代码直接赋给 bart.__name 不会影响实例中原有属性,只会新增一个属性.究其原因,实例中的属性已经被解释器重命名为了bart._Student__name. 继承和多态 继承和多态概念与java类似.不多语了. 那么重点来了: python本身是动态语言,体现在变量/类等各个方面,自由度极高.在继承上,亦是如此. java中定义一个su方法,调用model类实例实现的run方法.su方法可传入的只有 model类或其子类的实例 但python中 只要是定义了 run方法(别管内容/功能一样不一样)类的实例,都可以作为参数传入 su 方法. java中对类的类型的处理,相当于照猫🐱画虎🐯,传入的起码要是个猫科动物. python 中对类的类型处理,额头写个王字,哪怕传入具体对象是个猫头鹰🦉,也当作猫科处理了. note:判断一个变量是否是某个类型可以用isinstance()12&gt;&gt;&gt; isinstance(a, list)True 获取对象信息 * 让我想起了java反射..不过能获取的信息要全多了.type() 示例: 12345678&gt;&gt;&gt; type(123)&lt;class 'int'&gt;&gt;&gt;&gt; type(a)&lt;class '__main__.Animal'&gt;&gt;&gt;&gt; type(123)==type(456)True 判断对象类型 由变量指向函数或者类，也可以用type()判断 type返回对应的Class类型,可直接 == 类型判断 判断一个对象是否是函数: 12345678&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():... pass...&gt;&gt;&gt; type(fn)==types.FunctionTypeTrue&gt;&gt;&gt; type(abs)==types.BuiltinFunctionTypeTrue isinstance() 示例: 12345&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True 判断继承关系,一打一个准. 能用type()判断的基本类型也可以用isinstance()判断 总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。 dir() 示例: 12&gt;&gt;&gt; dir('ABC')['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill'] 获得一个对象的所有属性和方法.直接返回一个字符串list. 配合getattr()、setattr()以及hasattr()，可以直接操作一个对象的状态. 示例: 12345678910111213&gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？False&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？True&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'19&gt;&gt;&gt; obj.y # 获取属性'y'19 不存在的属性，会抛出AttributeError的错误,可以传入一个default参数，如果属性不存在，就返回默认值. 12&gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404404 也可以获得对象的方法 123456789&gt;&gt;&gt; hasattr(obj, 'power') # 有属性'power'吗？True&gt;&gt;&gt; getattr(obj, 'power') # 获取属性'power'&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81 只有在不知道对象信息的时候，才会去获取对象信息.谨记,谨记. 实例属性和类属性 类似java类中静态变量 与 普通变量区别. 类的属性,直接在类的cclass中声明. 12class Student(object): name = 'Student' 访问时,类的属性会被实例的同名属性覆盖,但不会被修改,互相独立. 删除实例属性后，再使用相同的名称，访问到的将是类属性]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python—模块]]></title>
    <url>%2F2018%2F01%2F19%2Fpython%E2%80%94%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[模块 模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。 涉及到概念 包(Package) 和 模块(Module) 创建自己的模块时，要注意： 模块名要遵循Python变量命名规范，不要使用中文、特殊字符； 模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。 使用模块 示例 1234567891011121314151617181920#!/usr/bin/env python3# -*- coding: utf-8 -*-' a test module '__author__ = 'Michael Liao'import sysdef test(): args = sys.argv if len(args)==1: print('Hello, world!') elif len(args)==2: print('Hello, %s!' % args[1]) else: print('Too many arguments!')if __name__=='__main__': test() 注释: 第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行 第2行注释表示.py文件本身使用标准UTF-8编码； 第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释 第6行使用author变量把作者写进去 重点if __name__==&#39;__main__&#39;: Python解释器把一个特殊变量name置为main，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试. 作用域 Python中，是通过_前缀 标记 private note: python中语法没有限制 _开头的变量/函数! 安装第三方模块 pip命令 1pip install xxx 或者在文件中自定义路径.]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python—基础]]></title>
    <url>%2F2018%2F01%2F19%2Fpython%E2%80%94%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据类型 整数 浮点数 字符串 字符串以单引号 ‘ 或 “ 包括. 转义字符 \ 依然有效. r’’表示此字符串默认不转移. /n有效, 可用 开头 … 替换布尔 只有True 和 Flase and or not 3种常用操作 常量 通常都为大写表示. 除法有两种 / 或 /// 结果可能为浮点, // 结果为整数(地板除) 其他 None 空值,不为0.谨记 动态语言,so,变量的类型无所谓. 浮点数精度无限,但超过限制直接表示为 inf 字符编码 简而言之 文件使用utf-8就对了. utf-8 属于万国码的简化,低位与 ASCII 兼容. python字符串编码 py3中默认是 Unicode 万国码. ord()获取字符的整数表示，chr()把编码转换为字符. Python对bytes类型的数据用带b前缀的单引号或双引号表示 x = b&#39;ABC&#39; 以Unicode表示的str通过encode()方法可以编码为指定的bytes 1234'ABC'.encode('ascii')b'ABC''中文'.encode('utf-8')b'\xe4\xb8\xad\xe6\x96\x87' 对应的decode()方法 1234&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')'中文' 可以传入errors=’ignore’忽略错误的字节 1b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore') len(),str计算字符.bytes计算字节 开头,第一行,可执行文件(windows会忽视注释)第二行,以utf-8处理文件.12#!/usr/bin/env python3# -*- coding: utf-8 -*- 字符串格式化 占位符与c基本相同 %d %s %x %f 12print('%2d-%02d' % (3, 1))print('%.2f' % 3.1415926) 需要 % 时, %% format() 12&gt;&gt;&gt; 'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125)'Hello, 小明, 成绩提升了 17.1%' list tuplelist 列表 示例, = [ , , ] 可变 有序 1classmates = ['Michael', 'Bob', 'Tracy'] 索引以 0 开始,可以倒序 -n 当然越界都是 IndexError 错误 .len(),list元素个数. .append(x) 末尾添加 .insert(i,x) 对应索引处插入 .pop(i) 删除i对应元素,为空则删除末尾元素. 替换i位置,直接赋值. list的元素可以为一个list.多重数组. tuple 元组 示例= ( , , ) 不可变 有序 更安全,其他与list相同 1t = (1, 2) t = (1,)声明一个元素元组,比较特殊. 条件判断 示例 123456if true : print("1")elif true : print("2")else : print("3") if 条件可简写,if x x非零数值、非空字符串、非空list 则为true 提及用户输入 input() input默认返回字符串,如需要其他类型 int()转换. 循环 示例 与c相同 12for x in names: print(x) 示例 与c相同 12while n &gt; 0: print(n) break 跳出此层循环 continue 跳出本轮循环 dict 和 setdict 字典,使用键值对储存数据,索引极快,空间换时间. 对应其他语言的 map 示例: {‘’: ,’’: ,…} 123d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;d['Michael']95 key 必须为不可变对象,整数、字符串等 一个key对应一个value key不存在 in判断 12&gt;&gt;&gt; 'Thomas' in dFalse get()获取 12d.get('Thomas') # 返回空d.get('Thomas', -1) # 不存在? 返回-1: ; pop()删除 1d.pop('Bob') set key的集合,但不存在value 无序、不重复、元素为不可变对象 创建set需要一个list 示例 set([ , , …]) 123&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; .add(key)/.remove(key)]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python—n函数]]></title>
    <url>%2F2018%2F01%2F19%2Fpython%E2%80%94n%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数常用 参数数量不对 TypeError错误 参数类型错误，TypeError的错误，并且给出错误信息 int()转换为int类型 float() bool() str() 函数名为一指向函数对象的引用,可以将变量指向函数,再调用 123&gt;&gt;&gt; a = abs # 变量a指向abs函数&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数1 定义函数 示例 12345def my_abs(x): if x &gt;= 0: return x else: return -x def 函数名(参数) : 函数体 return 没有return 则返回 None import 包含模块,java一样 空函数 pass 语句. 12def nop(): pass 示例 返回多个参数 123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 返回的是一个tuple .. 按位置赋值给变量 函数参数 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数 默认参数 示例: 1234def power(x, n=2):...power(5) power(5, 2) power(n=3,5) 默认参数必须指向不变对象 多个参数时，变化大的参数在前，变化小的参数在后。变化小的参数就可以作为默认参数。 多个默认参数，可以按顺序提供默认参数 也可以不按顺序提供。当不按顺序提供部分默认参数时，需要把参数名写上 enroll(&#39;Adam&#39;, &#39;M&#39;, city=&#39;Tianjin&#39;) 坑 默认参数 不可变性 每次调用均会改变其值. 可变参数 示例: 123456789def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sumnums = [1, 2, 3]calc(*nums) #相同calc(1, 2, 3) 传入的参数个数可变,传入组装成了tuple 当作c语言指针吧😂 传入数组的地址 命名关键字参数 示例: 1234def person(name, age, *, city, job): print(name, age, city, job)person('Jack', 24, city='Beijing', job='Engineer') 命名关键字参数需要一个特殊分隔符，后面的参数被视为命名关键字参数 函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符* 12def person(name, age, *args, city, job): print(name, age, args, city, job) 如果没有可变参数，就必须加一个作为特殊分隔符。如果缺少，Python解释器将无法识别位置参数和命名关键字参数 关键字参数 示例 12345678def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw)extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;person('Jack', 24, city=extra['city'], job=extra['job'])#相同extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;person('Jack', 24, **extra) 关键字参数在函数内部组装为一个dict 函数内部获得是 dict的拷贝,修改对原值无影响. 可以传入任意不受限制的关键字参数 递归函数 python 不含尾递归优化,注意层级,否则非常容易堆栈溢出.]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux笔记—Linux文件夹操作]]></title>
    <url>%2F2018%2F01%2F18%2Flinux%E7%AC%94%E8%AE%B0%E2%80%94Linux%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[linux下文件夹相关操作 参考 http://blog.csdn.net/u011118014/article/details/43232693 打开文件夹,遍历访问每个文件切换到文件夹路径下 调用 chdir 即可1chdir(&quot;/info&quot;); 打开文件夹 源码,打开文件夹返回对应文件夹的DIR结构体 12345DIR *dir; dir = opendir(pcDirName);if (NULL == dir)&#123; continue ;&#125; DIR结构体 123456789101112struct __dirstream &#123; void *__fd; char *__data; int __entry_data; char *__ptr; int __entry_ptr; size_t __allocation; size_t __size; __libc_lock_define (, __lock) &#125;;typedef struct __dirstream DIR; 保存文件夹相关内容,无需深究 源码,遍历文件 12345678910struct direct *ent;while (NULL != (ent = readdir(dir)))&#123; /*如果 指向 . ..*/ if (0 == strcmp(ent-&gt;d_name, &quot;.&quot;) \ || 0 == strcmp(ent-&gt;d_name, &quot;..&quot;) \ || 4 == ent-&gt;d_type)&#123; continue; &#125; /*遍历*/&#125; dirent结构体 12345678struct dirent&#123; long d_ino; /* inode number 索引节点号 */ off_t d_off; /* offset to this dirent 在目录文件中的偏移 */ unsigned short d_reclen; /* length of this d_name 文件名长 */ unsigned char d_type; /* the type of d_name 文件类型 */ char d_name [NAME_MAX+1]; /* file name (null-terminated) 文件名，最长255字符 */&#125; dirent指向目录和目录中某个具体文件,但还是桥梁作用,访问文件具体内容还需要通过d_name找到stat结构体支援. 源码,获取stat结构体 12stat f_stat;sdwRet = stat(ent-&gt;d_name, &amp;f_stat); stat结构体是指向文件的结构体 123456789101112131415struct stat &#123; mode_t st_mode; //文件访问权限 ino_t st_ino; //索引节点号 dev_t st_dev; //文件使用的设备号 dev_t st_rdev; //设备文件的设备号 nlink_t st_nlink; //文件的硬连接数 uid_t st_uid; //所有者用户识别号 gid_t st_gid; //组识别号 off_t st_size; //以字节为单位的文件容量 time_t st_atime; //最后一次访问该文件的时间 time_t st_mtime; //最后一次修改该文件的时间 time_t st_ctime; //最后一次改变该文件状态的时间 blksize_t st_blksize; //包含该文件的磁盘块的大小 blkcnt_t st_blocks; //该文件所占的磁盘块&#125;; 之后愉快访问吧]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android随手记—Android M闪退小记]]></title>
    <url>%2F2017%2F11%2F23%2FAndroid%E9%9A%8F%E6%89%8B%E8%AE%B0-Android%20M%E9%97%AA%E9%80%80%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[编程环境 Android Studio 3.0.1 问题 MyPrivacy 在android M上闪退,在模拟器中复现.提示1android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want? 过程 进入第二个Activity应用设置时,才出现,而且 7.1无问题.模拟器复现,抓log. 解决 log的意思是启动activity的context不是 activity. 对应代码 123Intent intent = new Intent(MyApplicantion.getContext(), AppSettingActivity.class);intent.putExtra(&quot;PackageName&quot;, AppId);MyApplicantion.getContext().startActivity(intent); 需要对intent声明 FLAG_ACTIVITY_NEW_TASK 1intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 备注 网上的原因分析: 因为standard模式的Activity默认会进入启动它的Activity所属的任务栈中，但是由于非Activity类型的context（ApplicationContext）并没有所谓的任务栈，所以就出现问题了。需要指定Activity为FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候，就会为它创建一个新的任务栈了。–android开发艺术探究]]></content>
      <categories>
        <category>Android随手记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android随手记—ScrollView]]></title>
    <url>%2F2017%2F11%2F12%2FAndroid%E9%9A%8F%E6%89%8B%E8%AE%B0-ScrollView%2F</url>
    <content type="text"><![CDATA[编程环境 Android Studio 3.0 问题 横屏模式下,显示内容被遮挡 过程 Google😂 解决 ScrollView 只允许嵌套一个子布局.超出范围部分会自动增加滚动条 备注 ScrollView 只能添加竖直方向滚动条.]]></content>
      <categories>
        <category>Android随手记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—Rxjava2]]></title>
    <url>%2F2017%2F11%2F06%2FAndroid%E7%AC%94%E8%AE%B0%E2%80%94Rxjava2%2F</url>
    <content type="text"><![CDATA[资料来源如下给初学者的RxJava2.0教程(demo代码来源) http://www.jianshu.com/u/c50b715ccaeb 编程环境 Android Studio 2.2.3 在Gradle配置:12compile &apos;io.reactivex.rxjava2:rxjava:2.0.1&apos;compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos; 观察者模式 在Eventbus中亦涉及了相关概念,比较简单.包括Observable(被观察者)、Observer(观察者)、subscribe().事件由Observable(被观察者)开始发出,通过subscribe()最终被传递到Observer(观察者).而整个过程中你是站在Observer(观察者)的位置,也就是事件的末尾,观察Observable(被观察者). 上图 demo 123456789101112131415161718192021222324252627Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onComplete(); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;subscribe&quot;); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, &quot;&quot; + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;error&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;complete&quot;); &#125; &#125;); 事件由emitter.onNext(1);开始,最终被public void onNext(Integer value)相应.被观察者事件发送结束调用emitter.onComplete();,同时观察者最终以public void onComplete()相应. * note: 上下游以.subscribe建立连接后,事件才会开始发送.Observable(被观察者) Observer(观察者) ObservableEmitterObservableEmitter： Emitter意为发射器,事件发送.onNext(T value)、onComplete()和onError(Throwable error)分别对应next事件、complete事件和error事件。 Observer中onNext(Integer value)、onError(Throwable e)、onComplete()对应接受next事件、complete事件和error事件 被观察者发送complete事件和error事件后,观察者接受后不再继续响应事件,即使被观察者还在发送事件.complete事件和error事件互斥. 在Observer中,调用Disposable.dispose(),切断管道.被观察者继续发送,但观察者不再响应. subscribe 建立Observable(被观察者) Observer(观察者)之间的管道.有多个重载. 重载 1234567891011public final Disposable subscribe() &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) &#123;&#125; public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123;&#125;public final void subscribe(Observer&lt;? super T&gt; observer) &#123;&#125; 重载说明 不带参数 : 观察者不关心任何事件(有卵用😵) 只带onNext : 观察者只响应next事件. 其他类似….演绎推理…. 最后一个是传入完整的Observer对象.(demo就是🙃) 操作符 基于Rxjava的观察者模式可以拆分大多数的业务逻辑,即使再增加很多功能整体也不会过于混乱. 但Rxjava的强大并不局限在拆分逻辑.由被观察者到观察者的整个事件传递过程,基于Rxjava我们可以任意拆分 合并 转换 事件、切换线程等. * note: 操作符搭配 Lambda 表达式食用更佳 🤣创建 产生并发送 Obserable 事件. 仅常用,详细在 RxJava 2.x 使用详解(二) 创建操作符 .creat 前面demo中已经实际使用过了 用于产生一个 Obserable 被观察者对象,demo如上所示. .just 对于简单的几个数据,直接使用just发送即可,无需创建 Obserable 对象.just最多可以接收 10 个参数. demo 12Observable.just(&quot;test&quot;,&quot;test2&quot;) .subscribe(str -&gt; Log.i(&quot;tag&quot;, str)); 相当于顺序调用onNext(“test”)和onNext(“test2”)，最后调用onComplete方法。 .fromArray 功能与just类似但fromArray来接收任意长度的数据数组,也可以直接传入数组fromArray(new int[]{1, 2, 3}) demo 12Observable.fromArray(1, 2, 3, 4, 5) .subscribe(integer -&gt; Log.i(&quot;tag&quot;, String.valueOf(integer))); fromArray不支持直接传入list进，list会被当作一个整体发送. .fromIterable 功能与fromArray类似,但是可以接收 list 类型,遍历可迭代数据集合. demo12345678List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;c&quot;);Flowable.fromIterable(list).subscribe( s -&gt; Log.i(&quot;tag&quot;, s)); .timer 指定一段时间间隔后发送数据(一次性),不太常用. 线程切换 默认事件传递的双方在同一线程工作. demo 12345observable.subscribeOn(Schedulers.newThread()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .observeOn(Schedulers.io()) .subscribe(consumer); 方法: .subscribeOn() : 指定被观察者发送事件线程,仅第一次调用时有效! .observeOn() : 指定观察者/流变换(对发送的事件处理🖖)线程,多次调用,多次切换有效 参数: Schedulers.io() : 适用于io密集型操作,网络通信、磁盘操作等. Schedulers.computation() : CPU密集操作,需要大量CPU计算的操作. Schedulers.newThread() : 创建新线程. AndroidSchedulers.mainThread() : Android主线程,通常为更新UI等. 过滤 对 Obserable 事件筛选. 仅常用,详细在RxJava 2.x 使用详解(三) 过滤操作符 .filter 基本过滤操作符,按照任意自定规则过滤. 组合转换.map 处理前后事件数量之比1:1,事件变换前后顺序不变 map作用是对Observable发送的每一个事件,应用处理变换函数,再继续像下游发送.中间过程可以转换事件类型、改变事件内容等等.只需要变换后的事件类型与下游接收的类型匹配即可. demo 123456789101112131415161718Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return &quot;This is result &quot; + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125; &#125;); 这里是把int类型转换为了string类型,与观察者接收的类型匹配即可. .flatMap 处理前后事件数量之比 1:n,事件变换前后顺序不保证 flatMap,通俗点就是把Observable发送的事件拆散变换再,继续像下游发送.1个Observable事件可拆成任意个.只需要变换后的事件类型与下游接收的类型匹配即可. demo 12345678910111213141516171819202122Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125; &#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123; final List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(&quot;I am value &quot; + integer); &#125; return Observable.fromIterable(list).delay(10,TimeUnit.MILLISECONDS); &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125; &#125;); 这里是flatMap把一个int类型事件拆成了3个String类型,运行结果看,最终事件到达顺序与onNext(1);onNext(2);的发送顺序无关 .concatMap 处理前后事件数量之比 1:n,事件变换前后顺序按顺序 与flatMap作用相同,只是保证了事件严格按顺序达到下游. demo 就不上了,直接替换flatMap的位置就好. .zip 处理前后事件数量之比 n:1,事件变换前后顺序严格按顺序 zip.最常见的压缩文件格式,在这里也是类似的意思,zip可以严格按照顺序合并多个 不同类型 Observable发送的事件.总的发送事件数量与上游Observable发送最少的那个数量相同. demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); Thread.sleep(1000); Log.d(TAG, &quot;emit 2&quot;); emitter.onNext(2); Thread.sleep(1000); Log.d(TAG, &quot;emit 3&quot;); emitter.onNext(3); Thread.sleep(1000); Log.d(TAG, &quot;emit 4&quot;); emitter.onNext(4); Thread.sleep(1000); Log.d(TAG, &quot;emit complete1&quot;); emitter.onComplete(); &#125; &#125;).subscribeOn(Schedulers.io()); Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; Log.d(TAG, &quot;emit A&quot;); emitter.onNext(&quot;A&quot;); Thread.sleep(1000); Log.d(TAG, &quot;emit B&quot;); emitter.onNext(&quot;B&quot;); Thread.sleep(1000); Log.d(TAG, &quot;emit C&quot;); emitter.onNext(&quot;C&quot;); Thread.sleep(1000); Log.d(TAG, &quot;emit complete2&quot;); emitter.onComplete(); &#125; &#125;).subscribeOn(Schedulers.io()); Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(Integer integer, String s) throws Exception &#123; return integer + s; &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;onSubscribe&quot;); &#125; @Override public void onNext(String value) &#123; Log.d(TAG, &quot;onNext: &quot; + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;onError&quot;); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125; &#125;); 这里两个事件发送在同一线程中.当两个事件发送不再同一线程时,情况类似,不过当异步时,数量较少的事件发送完成,发送Complete事件后,通道随即被切断. .Concat 处理前后事件数量之比 n:1,事件变换前后顺序严格按顺序 Concat,可以严格按照顺序合并 相同类型 Observable发送的事件. Backpressure * 被翻译为背压…(如此文不达意的直译,能忍?往下都是因为原文..😈) 其实概念有够简单:将整个事件产生/传递/处理的过程想象为一条河流由上而下, Backpressure 指的是上游产生的事件太快,远远超过了下游的处理速度,以至于缓冲区溢出.上游来了洪水,下游径流量不够,以至于中间河道跨过了堤岸,溢出. Flowable基础 Rxjava 1.x中需要自行通过操作符处理,到了2.0中,则有了专门对付发洪水上游的被观察者- Flowable .我们常用的 observable 在2.x中一般用于不涉及 Backpressure 的情况.而对应与 observable 的 Observer ,改为了 Subscriber . demo 12345678910111213141516171819202122232425262728293031323334353637383940Flowable&lt;Integer&gt; upstream = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); Log.d(TAG, &quot;emit 2&quot;); emitter.onNext(2); Log.d(TAG, &quot;emit 3&quot;); emitter.onNext(3); Log.d(TAG, &quot;emit complete&quot;); emitter.onComplete(); &#125; &#125;, BackpressureStrategy.ERROR); //增加了一个参数 Subscriber&lt;Integer&gt; downstream = new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, &quot;onSubscribe&quot;); s.request(Long.MAX_VALUE); //注意这句代码 &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, &quot;onNext: &quot; + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, &quot;onError: &quot;, t); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125; &#125;; upstream.subscribe(downstream); 注意两个地方 Flowable创建时比 observable 多了一个参数.(参数作用下节说明) Subscriber中调用了 s.request . Flowable 与 Observable 最大的不同就是 Flowable再次发送事件需要等待 Subscriber 中调用 .request .request() 实质上是下游告知上游自己的处理能力,使得上游根据下游处理能力发送事件.多次调用,上游表示处理能力的数字会叠加,上游每发送一个事件,该数字减一,到0抛出异常 上下游在同一线程时,下游没有或没有及时调用 .request ,上游会抛出异常 异步线程时,下游即使没有调用 .request 会有128个事件的缓存区.上游可继续发出事件,缓存区超出128个事件后,抛出异常. Flowable拓展* 这里对 Flowable 多的参数进行说明. 参数 BackpressureStrategy.BUFFER : 默认缓存区128,这个参数极大拓展了缓存区,使得 Flowable 表现与 Observable 差不多. BackpressureStrategy.DROP : 128缓存区满了,就丢弃上游事件,直到下游处理了一个事件,缓存区 -1 ,再允许存入新的上游事件. BackpressureStrategy.LATEST : 永远保存最后达到的128个上游事件,上游有新的事件到达满载的缓存区时,丢弃第一个存入缓存区的上游事件. 对于不是由我们编写的 Flowable 也可以通过 interval 操作符来加工. 12Flowable.interval(1, TimeUnit.MICROSECONDS) .onBackpressureDrop() //加上 Backpressure 策略 对应上文,指定参数有3,意思同上. onBackpressureBuffer() onBackpressureDrop() onBackpressureLatest()]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android随手记—Glide加载Drawable对象]]></title>
    <url>%2F2017%2F11%2F04%2FAndroid%E9%9A%8F%E6%89%8B%E8%AE%B0-Glide%E5%8A%A0%E8%BD%BDDrawable%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[编程环境 Android Studio 3.0 问题 Glide是一个通用的图片缓存框架,但是在MyPrivacy显示appIcon时,传入 一个Drawable对象,提示类型不匹配. (注意: 这里是直接传入Drawable对象,不是经过 R.xx 引用 !) 过程 查阅资料后,确认Glide不支持直接加载传入的Drawable对象,转换为bitDrawable类型也不可. 解决思路来自 https://github.com/bumptech/glide/issues/588 不支持直接加载,但Glide的.error(Icon)错误时显示 .placeholder(Icon)占位符,支持Drawable对象 解决 不再直接加载 .load 传入空字符串, 通过 .placeholder 简洁加载. demo 12345678910Drawable Icon ＝ ｘｘｘ；RequestOptions options = new RequestOptions() .error(Icon) .placeholder(Icon); Glide.with(context) .load(&quot;&quot;) .apply(options) .into(imageView); 备注 placeholder 在Glide 4.x版本中,移入了 RequestOptions 对象中.]]></content>
      <categories>
        <category>Android随手记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux笔记—qemu运行linux]]></title>
    <url>%2F2017%2F09%2F10%2Flinux%E7%AC%94%E8%AE%B0%E2%80%94qemu%E8%BF%90%E8%A1%8Clinux%2F</url>
    <content type="text"><![CDATA[ubuntu16.04 使用busybox编译最小文件系统，使用qemu运行起来。 内容来自 奔跑吧linux内核第6章 这里将输入代码过程集合到了几个.sh文件,不做重复的工作 ! 当然网好是前提,最好挂代理. 安装工具 首先需要安装qemu gcc, ubuntu16.04中自带的gcc版本较低,这里我们安装书中推荐的gcc-arm-linux-gnueabi 1sudo apt-get install qemu libncurses5-dev gcc-arm-linux-gnueabi build-essential 下载busybox源码 书中推荐版本是1.24,但最新版本已经到了busybox-1.27.2.这里我们使用最新版1wget https://busybox.net/downloads/busybox-1.27.2.tar.bz2 解压到 busybox 文件夹1tar -jxvf busybox-1.27.2.tar.bz2 下载linux内核源码 还是以配套的4.0源码为例,(提醒:内核解压后大约占800MB,请预留出足够空间)1wget https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.0.tar.gz 解压到linux文件夹1tar -jxvf linux-4.0.tar.gz 编译最小文件系统* 别问我最小文件系统是什么,我也有点😵,但是先用起来. 首先利用 busybox 手工编译一个最小文件系统。在busybox文件夹下 1234export ARCH=ARMexport CROSS_COMPILE=arm-linux-gnueabi-make menuconfigmake install 进入menuconfig后,配置静态编译 123Busybox Settings ---&gt;Build Options ---&gt;[*] Build BusyBox as a static binary (no shared libs) 然后 make install 编译完成。编译完成后,把 busybox 根目录下面的_install 目录拷贝到 linux-4.0 下。 进入_install 目录，创建 etc、dev 等目录。 1234mkdir etcmkdir devmkdir mntmkdir -p etc/init.d/ 在_install /etc/init.d/目录下创建 文件名rcS 的文件，写入以下内容： 123456789mkdir –p /procmkdir –p /tmpmkdir -p /sysmkdir –p /mnt/bin/mount -amkdir -p /dev/ptsmount -t devpts devpts /dev/ptsecho /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev –s 同时使用 chmod +x rcS修改rcS的可执行权限. 在_install /etc 目录创建文件名 fstab 的文件，并写入以下内容。 12345proc /proc proc defaults 0 0tmpfs /tmp tmpfs defaults 0 0sysfs /sys sysfs defaults 0 0tmpfs /dev tmpfs defaults 0 0debugfs /sys/kernel/debug debugfs defaults 0 0 在_install /etc 目录创建文件名 inittab 的文件，并写入如下内容。 1234::sysinit:/etc/init.d/rcS::respawn:-/bin/sh::askfirst:-/bin/sh::ctrlaltdel:/bin/umount -a –r 在_install/dev 目录下创建如下设备节点，以root权限执行 123cd _install/dev/sudo mknod console c 5 1sudo mknod null c 1 3 .sh(配合chmod +x使用) build.sh: 编译busybox 1234export ARCH=ARMexport CROSS_COMPILE=arm-linux-gnueabi-make menuconfigmake install creat.sh: _install文件夹下处理 123456789101112131415161718192021222324252627282930313233343536rm -rf etc rm -rf dev rm -rf mnt mkdir etcmkdir devmkdir mntmkdir -p etc/init.d/echo &quot;mkdir -p /procmkdir -p /tmpmkdir -p /sysmkdir -p /mnt/bin/mount -amkdir -p /dev/ptsmount -t devpts devpts /dev/ptsecho /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -s&quot; &gt; etc/init.d/rcSchmod +x etc/init.d/rcSecho &quot;proc /proc proc defaults 0 0tmpfs /tmp tmpfs defaults 0 0sysfs /sys sysfs defaults 0 0tmpfs /dev tmpfs defaults 0 0debugfs /sys/kernel/debug debugfs defaults 0 0&quot; &gt; etc/fstabecho &quot;::sysinit:/etc/init.d/rcS::respawn:-/bin/sh::askfirst:-/bin/sh::ctrlaltdel:/bin/umount -a -r&quot; &gt; etc/inittabcd dev/sudo mknod console c 5 1sudo mknod null c 1 3 编译内核 编译内核 12345cd linux-4.0export ARCH=armexport CROSS_COMPILE=arm-linux-gnueabi-make vexpress_defconfigmake menuconfig 配置 initramfs，在 initramfs source file 中填入_install。另外需要把 Default kernel command string 清空。 12345General setup ---&gt;[*] Initial RAM filesystem and RAM disk (initramfs/initrd) support(_install) Initramfs source file(s)Boot options --&gt;()Default kernel command string 配置 memory split 为“3G/1G user/kernel split”以及打开高端内存。 123Kernel Features ---&gt;Memory split (3G/1G user/kernel split) ---&gt;[ *] High Memory Support 开始编译 kernel 12make bzImage -j4 ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-make dtbs 运行 QEMU 来模拟 4 核 Cortex-A9 的 Versatile Express 开发平台。 1qemu-system-arm -M vexpress-a9 -smp 4 -m 1024M -kernel arch/arm/boot/zImage -append &quot;rdinit=/linuxrc console=ttyAMA0 loglevel=8&quot; -dtb arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic .sh(配合chmod +x) build.sh : 编译内核 123456export ARCH=armexport CROSS_COMPILE=arm-linux-gnueabi-make vexpress_defconfigmake menuconfigmake bzImage -j4 ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-make dtbs run.sh : 运行arm内核 1qemu-system-arm -M vexpress-a9 -smp 4 -m 1024M -kernel arch/arm/boot/zImage -append &quot;rdinit=/linuxrc console=ttyAMA0 loglevel=8&quot; -dtb arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographicyun]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Linux</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux笔记——看门狗内核API文档翻译]]></title>
    <url>%2F2017%2F08%2F23%2Flinux%E7%AC%94%E8%AE%B0%E2%80%94%E7%9C%8B%E9%97%A8%E7%8B%97%E5%86%85%E6%A0%B8API%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[wdt第二弹，内核API，勉强翻译下来了，还需要进一步整理 看门狗定时器驱动内核API 最后更新时间 2013.2.12 Wim Van Sebroeck &#x77;&#105;&#x6d;&#x40;&#105;&#103;&#117;&#97;&#x6e;&#97;&#x2e;&#98;&#x65; 介绍 本文档没有描述看门狗设备或驱动。也不涉及那些在用户空间调用的API，对应在 Documentation/watchdog/watchdog-api.txt （也就是上一篇） 本文档描述的是，利用看门狗子系统框架方式进行看门狗驱动编写时所使用到的API。看门狗子系统框架提供了所有与用户空间交互的接口，不需要每次编写重复的代码。这意味这驱动程序只需要提供几个不同的操作函数，就可以控制WDT了。 API 每一个想要使用看门狗核心子系统的驱动程序都必须包含#include&lt;linux/watchdog.h&gt;(编写驱动程序是不得不做的工作)。linux/watchdog.h包含以下两个注册/卸载函数： 12extern int watchdog_register_device(struct watchdog_device *);extern void watchdog_unregister_device(struct watchdog_device *); 注册函数将wdt设备注册进wdt子系统，函数的参数是一个指向struct watchdogdevice的结构体。当注册成功时返回0.注册失败返回一个负值。 卸载函数是将wdt设备从wdt子系统卸载，函数参数是一个指向struct watchdogdevice的结构体 看门子系统包含了注册时间调整机制（原文是 an registration deferral mechanism 一种延期机制？上下文不太对啊），允许在开机阶段，你可以按照你设定的尽可早的注册一个看门狗设备。 struct watchdogdevice 这里粘贴的是linux4.1里定义的watchdog_device，原文的watchdog_device更长但跟源码对不起来，所以这里就以内核4.1里定义的为准了😑：123456789101112131415161718192021 struct watchdog_device &#123;int id;struct cdev cdev;struct device *dev;struct device *parent;const struct watchdog_info *info;const struct watchdog_ops *ops;unsigned int bootstatus;unsigned int timeout;unsigned int min_timeout;unsigned int max_timeout;void *driver_data;struct mutex lock;unsigned long status;/* Bit numbers for status flags */#define WDOG_ACTIVE 0 /* Is the watchdog running/active */#define WDOG_DEV_OPEN 1 /* Opened via /dev/watchdog ? */#define WDOG_ALLOW_RELEASE 2 /* Did we receive the magic char ? */#define WDOG_NO_WAY_OUT 3 /* Is &apos;nowayout&apos; feature set ? */#define WDOG_UNREGISTERED 4 /* Has the device been unregistered */&#125;; 包含以下字段： id：由watchdog_register_device函数注册。id 0是一个特殊的，id 0 有/dev/watchdog0 cdev（动态主设备号，次设备号0） 和 /dev/watchdog miscdev。id 在调用到watchdog_register_device时自动注册。 NOTE看源码，wdt子系统是基于misc子系统的，注册wdt设备调用的是misc_register(&amp;watchdog_miscdev);而misc设备主设备号只能为10,这里结论有冲突，等待解决中。。。 parent：在调用watchdog_register_device函数前，设置父设备（或者设置为null） info：指向watchdog_info结构体的指针，watchdog_info提供了看门狗本身的一些附加信息（像是看门狗独有的名称之类的） ops：指向watchdog_ops结构体的指针，watchdog_ops是看门狗支持操作(函数)的集合。 bootstatus:启动后设备状态(与看门狗WDIOF* 标志位一同开启) timeout:看门狗超时的时间(秒为单位).如果设置了WDOGACTIVE 启用了看门狗,在这个时间长度后,用户空间还没有发送心跳包,看门狗会将系统复位重启. mintimeout:可设置的看门狗最小超时时间 maxtimeout:可设置的看门狗最大超时时间 driverdata:指向看门狗设备私有数据的指针,这个data只能由watchdog_set_drvdata 和 watchdog_get_drvdata routines函数访问. struct mutex lock; 原文档没有🙄 status:这个字段包含了许多状态位,提供有关设备的额外信息(例如:看门狗的活动状态\限制,现在nowayout 位设置与否)(括号里翻译是否准确存疑) struct watchdog_ops watchdogops 1234567891011121314 struct watchdog_ops &#123;struct module *owner;/* mandatory operations */int (*start)(struct watchdog_device *);int (*stop)(struct watchdog_device *);/* optional operations */int (*ping)(struct watchdog_device *);unsigned int (*status)(struct watchdog_device *);int (*set_timeout)(struct watchdog_device *, unsigned int);unsigned int (*get_timeleft)(struct watchdog_device *);void (*ref)(struct watchdog_device *);void (*unref)(struct watchdog_device *);long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);&#125;; 你一开始定义的看门狗的module owner是非常重要的,module owner 在使用看门狗时会同时锁定看门狗设备.(这样避免了在卸载模块时/dev/watchdog依然是打开状态引起的系统崩溃) 某些函数是必须实现的,其他是可选的,必须实现的函数如下: start :指向看门狗设备启动函数的指针.这个函数参数为一个 struct watchdogdevice,成功返回0,失败返回负数. stop :通过这个函数关闭看门狗设备.这个函数参数为一个 struct watchdogdevice,成功返回0,失败返回负数. 一些硬件看门狗设备只能启动,没有关闭选项.对应这些设备的驱动,不用实现 stop ,如果驱动程序没有关闭设备功能,看门狗核心层会在设备关闭后设置 WDOG_HW_RUNNING 并调用驱动程序的 keepalive pings功能. 如果看门狗驱动没有实现stop 必须设置max_hw_heartbeatms 不是所有的硬件看门狗都有相同的功能,这就是为什么会有可选函数了,只有但这项功能被硬件看门🐶支持时,才编写对应函数. ping:这是看门狗驱动实现的喂狗函数,这个函数的参数时一个指向struct watchdogdevice的指针.函数执行成功返回0,失败返回负数. 大多数的硬件不支持直接喂狗的特殊功能,一般是直接重启硬件看门狗. 看门狗子系统的核心层也是这样做的:但定期喂狗的操作转发到硬件看门狗时,核心层在 ping 实现时调用喂狗函数,但喂狗函数没有实现时,使用 start 对应函数 ( WDIOC_KEEPALIVE对应的 ioctl命令只有在i看门狗info里的WDIOF_KEEPALIVEPING被设置为1后才会生效 ) status: 这个函数用来检查看门狗设备的状态,通过看门狗的WDIOF*状态标志位报告.WDIOF_MAGICCLOSE and WDIOF_KEEPALIVEPING由看门狗核心层报告.没有必要在驱动程序中报告.此外如果驱动程序没有实现该函数,看门狗核心层会返回 struct watchdogdevice中的bootstatus状态位. set_timeout:这个函数设置和检查 超时时间的变化,返回0表示成功,返回-EINVAL表示超出范围,返回-EIO表示无法写入看门狗.设置成功后,函数应该将设定的超时时间写入看门狗.(或许与通过接口获取的超时时间不同,因为看门狗的分辨率不一定能到1s). 实现了max_hw_heartbeat_ms的驱动将硬件看门狗心跳值设置为超时时间和max_hw_heartbeat_ms之间的最小值.Those drivers set the timeout value of the watchdog_device either to the requested timeout value (if it is larger than max_hw_heartbeat_ms), or to the achieved timeout value. 如果看门狗驱动程序没有执行任何操作,但设置了watchdogdevice.timeout,此回掉函数忽略. 如果没有设置 set_timeout,但设置了WDIOF_SETTIMEOUT,看门狗架构会将 watchdog_device中timeout值更新为请求的值. 如果使用了pretimeout feature (WDIOF_PRETIMEOUT),那么set_timeout 必须同时检查 pretimeout 是否有效 ,设置相应定时器. 这些操作在核心层没有races无法完成,所以必须在驱动中完成. setpretimeout:这个函数支持检查/改变看门狗中pretimeout值(pretimeout详情见wdt用户层api翻译).这个函数是可选支持的,因为不是所有的看门狗都支持这个功能.pretimeout 不是绝对时间,其数值是在超时时间之前几秒发生. 返回0表示执行成功,返回-EINVAL,表示超出范围,返回-EIO表示未能成功向看门狗写入. 设置pretimeou为0值,代表禁用pretimeout功能.(WDIOFPRETIMEOUT需要在看门狗的info 结构体中设置) 如果驱动没有实现任何功能,但设定了 watchdogdevice.pretimeout,此回掉函数忽略.这意味这,如果没有提供setpretimeout函数,但设定了WDIOFPRETIMEOUT,看门狗架构会将pretimeout的值更新为请求值. gettimeleft:这个函数返回复位前剩余时间. restart:此函数重启看门狗硬件,返回0表示成功,失败返回对应错误码. ioctl:如果这个函数存在,在系统进行内部ioctl命令处理前,会首先调用此函数.如果不支持ioctrl命令,应该返回 -ENOIOCTLCMD .这个函数的参数为(watchdogdevice, cmd and arg) ref和unref 已经不再被支持. The status bits should (preferably) be set with the set_bit and clear_bit alike bit-operations. The status bits that are defined are: WDOGACTIVE:这个状态位标识着从用户空间看一个看门狗设备是否被激活,如果被激活,用户空间需要执行喂狗动作 WDOG_NO_WAYOUT:这个状态位标识这nowayout的设置,如果被激活,那看门狗启动后,无法被停止. WDOG_HW_RUNNING:如果硬件看门狗运行,此状态位被置1. 当硬件看门狗不能被停止时,这个状态位必须被置1. 如果系统启动后自动启动看门狗,在看门狗打开前,必须设置此状态位. 当此状态位被置1,即使WDOGACTIVE为0.看门狗架构也会执行喂狗动作. (当你直接注册设置了 WDOG_HW_RUNNING位的看门狗设备时,执行open /dev/watchdog动作,系统会直接跳过启动操作,直接执行喂狗操作 ) 要设置WDOG_NO_WAYOUT状态位(在注册看门狗设备前)你可以: 在watchdogdevice的结构体中设置 1.status = WATCHDOG_NOWAYOUT_INIT_STATUS, 这样等同于将WDOG_NO_WAYOUT值设置为CONFIG_WATCHDOG_NOWAYOUT 使用下面的函数1static inline void watchdog_set_nowayout(struct watchdog_device *wdd, int nowayout) (note:) wdt驱动程序核心支持magic close和 nowayout功能.要使用magic close,需要在看门狗的 info中设置WDIOFMAGICCLOSE 位.开启 nowayout 会覆盖magic close. 获取或设定驱动程序特殊数据,应该使用以下两个函数: 12static inline void watchdog_set_drvdata(struct watchdog_device *wdd, void *data)static inline void *watchdog_get_drvdata(struct watchdog_device *wdd) watchdog_set_drvdata函数允许你添加向驱动程序添加特殊数据,此函数的参数为指向看门狗设备的指针,和指向需要添加数据的指针. watchdog_get_drvdata函数运行你读取驱动程序中的特殊数据,此函数的参数为指向你想读取的看门狗设备的指针. 初始化 timeout ,会用到下面的函数 123456 extern int watchdog_init_timeout(struct watchdog_device *wdd,unsigned int timeout_parm, struct device *dev); ``` * watchdog_init_timeout允许使用模块的 timeout 字段初始化 timeout ,当模块的 timeout 字段无效时,设备树中的timeout-sec也可.最好的做法是将watchdog_device_中timeout的值,设置为初始默认值,然后使用到函数的用户可以分别设置自定义值.* 重启后禁用看门狗,需要使用以下函数: static inline void watchdog_stop_on_reboot(struct watchdog_device *wdd); 1* 卸载看门狗设备时禁用看门狗,必须调用此函数,如果 nowayout 没有设置,这个函数只会停止看门狗. static inline void watchdog_stop_on_unregister(struct watchdog_device *wdd); 12 * 更改重启处理程序的优先级,(猜测是不同看门狗的优先级)调用下面的函数: oid watchdog_set_restart_priority(struct watchdog_device *wdd, int priority); 123456 * 设定优先级时,用户需要遵循以下规则 * 0:优先级最低,非常有限的重启能力 * 128:重启处理的默认选择,如果没有其他的重启处理程序可用,或者没有重启整个系统的重启处理程序可用. * 255:最高优先级,会覆盖其他所有重启处理程序* 使用pretimeout 通知功能,需要利用以下函数: void watchdog_notify_pretimeout(struct watchdog_device *wdd)``` 这个函数可以在中断上下文中调用,如果启用了watchdog pretimeout governor 框架(kbuild CONFIG_WATCHDOG_PRETIMEOUT_GOV),就会采用进入驱动程序分配好的处理程序,如果没有启用watchdog pretimeout governor 框架,watchdog_notify_pretimeout()会将信息输出到内核日志缓存.]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Linux</tag>
        <tag>翻译</tag>
        <tag>wdt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux笔记—看门狗API文档翻译]]></title>
    <url>%2F2017%2F08%2F22%2Flinux%E7%AC%94%E8%AE%B0%E2%80%94%E7%9C%8B%E9%97%A8%E7%8B%97API%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[随手翻译的文档，要看懂linux内核，内核附带的文档自然是逃不过😂，全英文配合Google翻译也得上。。。。 最后更新时间 10/05/2007 linux看门狗设备API Copyright 2002 Christer Weingel &#x77;&#105;&#110;&#x67;&#101;&#108;&#64;&#110;&#97;&#x6e;&#111;&#x2d;&#115;&#121;&#x73;&#116;&#x65;&#109;&#x2e;&#99;&#x6f;&#x6d; 本文档的一些内容来自 sbc60xxwdt ，版权属于 Copyright 2000 Jakob Oestergaard &#x6a;&#97;&#x6b;&#x6f;&#98;&#x40;&#111;&#115;&#x74;&#101;&#x6e;&#102;&#x65;&#x6c;&#100;&#46;&#x64;&#107; 本文档基于linux内核 2.4.18 介绍 你应该已经知道了，看门狗定时器（WDT）是一个硬件复位电路，在系统软件出现故障时复位系统。 通常，用户空间的定期喂狗程序通过/dev/watchdog的设备文件通知内核看门狗驱动程序。驱动收到通知，会告知硬件看门狗一切正常，硬件看门狗需要等一会再复位系统。如果用户空间通知失败（RAM错误、内核漏洞等等），通知将停止。超时后，硬件看门狗将复位系统（重启）。 linux看门狗的API是相当特殊的结构，不同的驱动程序对API的执行各不相同，有时会碰到不兼容的情况。本文档参数记录现有的情况，以供未来的驱动开发参考。最简单的API 所有驱动都支持的基本操作模式。/dev/watchdog被打开后，看门狗被激活并复位系统，除非在一小段时间内被ping通？（喂狗），这段时间被称为超时时间或间断时间。简单的喂狗的方式是向驱动程序写入一些数据，一个非常简单的实例在see samples/watchdog/watchdog-simple.c下. 更高级的驱动程序可以做到例如检查一个http服务器，在执行喂狗操作之前，做出回应。 /dev/下设备节点被关闭后，看门狗也同时被禁用，除非支持“Magic Close”（见下文），这并不是个好办法。因为如果看看门狗demo有bug导致系统崩溃，但系统不会重启。因为这样一些驱动支持”Disable watchdog shutdown on close”, CONFIG_WATCHDOG_NOWAYOUT”这样的配置选项。一旦编译内核时候启用这些选项，一旦看门狗程序激活，就不可能禁用看门狗。如果看门狗demo崩溃，系统会在超时后自动重启。看门狗驱动通常也支持nowayout module parameter，以便在运行时控制nowayout module。 Magic Close feature 如果驱动程序支持Magic Close,那么设备将不支持禁用看门狗，除非在关闭设备文件前，向/dev/watchdog下设备文件写入特定的magic 字符 ‘V’。如果用户空间的 daemon关闭了看门的设备文件，但是没有发送那个特定的字符，驱动会认为daemon进程已经被杀，并且停止了定期喂狗行为。这样会导致超时后系统重启。ioctl API 所有的驱动程序都支持ioctl API 喂狗操作使用ioctl完成 所有的驱动都要支持一个KEEPALIVE的ioctl命令，这个命令可以起到向驱动写入数据一样的作用。所以watchdog daemon的主函数循环可以这样实现1234 while (1) &#123; ioctl(fd, WDIOC_KEEPALIVE, 0); sleep(10);&#125; Setting and getting the timeout 某些驱动支持运行时通过SETTIMEOUT ioctl命令修改超时时间，这些驱动都有WDIOFSETTIMEOUT的标志位。超时时间是一个单位为秒的整数，驱动程序会返回这个变量实际设置的数值，但是由于硬件限制，返回的数值可能与设置数值不同。123int timeout = 45;ioctl(fd, WDIOC_SETTIMEOUT, &amp;timeout);printf(&quot;The timeout was set to %d seconds\n&quot;, timeout); 这个实例或许会输出”The timeout was set to 60 seconds”，如果设备超时时间为分钟。 自从2.4.18内核开始，可以使用GETTIMEOUT ioctl命令，获取超时时间。 12ioctl(fd, WDIOC_GETTIMEOUT, &amp;timeout);printf("The timeout was is %d seconds\n", timeout); Pretimeouts 一些看门狗定时器可以在系统重启前一段时间设置一个触发器。这样运行linux在系统从前记录一些重要的信息（像panic信息和kernel coredumps），具体可以通过NMT、中断等机制实现。 12pretimeout = 10;ioctl(fd, WDIOC_SETPRETIMEOUT, &amp;pretimeout); 请注意，pretimeout 时间是在 超时关闭系统 之前的秒数。不是直到发生pretimeout 事件的秒数。例如设定的超时时间是60s， pretimeout是10s。pretimeout事件会在50s时发生。pretimeout设置为0代表禁用pretimeout。 同样存在一个获取pretimeout的ioctl命令。 12ioctl(fd, WDIOC_GETPRETIMEOUT, &amp;timeout);printf(&quot;The pretimeout was is %d seconds\n&quot;, timeout); 不是所有看门狗驱动都支持 pretimeout 获取重启前秒数 一些看门狗驱动支持获取系统重启前秒数。通过WDIOCGETTIMELEFT ioctl 命令可以返回系统重启前秒数。12ioctl(fd, WDIOC_GETTIMELEFT, &amp;timeleft);printf(&quot;The timeout was is %d seconds\n&quot;, timeleft); 环境监测 所有的看门狗驱动都被要求返回更多关于系统最后一次重启的信息，像是温度、风扇转速、电源等。GETSUPPORT ioctl 的命令可以返回 设备可以支持的信息。 12struct watchdog_info ident;ioctl(fd, WDIOC_GETSUPPORT, &amp;ident); 返回的结构ident中的字段如下： 123 identity 描述watchdog driver的字符串firmware_version the firmware version of the card if availableoptions 设备支持情况的标志位 options描述了GET_STATUS 和GET_BOOTSTATUS ioctl命令可以返回那些信息。并且可以设置。（）??无法理解什么意思?? WDIOFOVERHEAT cpu过热复位系统重启因为，超过了温度限制上限。 WDIOFFANFAULT 风扇失效复位 WDIOFEXTERN1 External relay 1 外部监控电源1被触发，？？？Controllers intended for real world applications include external monitoring pins that will trigger a reset.？？（不明白什么意思） WDIOF_EXTERN2 External relay 2外部监控电源2被触发 WDIOF_POWERUNDER 电源坏了，电源带不动了机器显示欠压。 后面一点不翻了，有时间再添坑 WDIOF_CARDRESET Card previously reset the CPUThe last reboot was caused by the watchdog card WDIOF_POWEROVER Power over voltageThe machine is showing an overvoltage status. Note that if one level is under and one over both bits will be set - this may seem odd but makes sense. WDIOF_KEEPALIVEPING Keep alive ping replyThe watchdog saw a keepalive ping since it was last queried. WDIOF_SETTIMEOUT Can set/get the timeoutThe watchdog can do pretimeouts. WDIOF_PRETIMEOUT Pretimeout (in seconds), get/setFor those drivers that return any bits set in the option field, the GETSTATUS and GETBOOTSTATUS ioctls can be used to ask for the current status, and the status at the last reboot, respectively. 12int flags;ioctl(fd, WDIOC_GETSTATUS, &amp;flags); or 1ioctl(fd, WDIOC_GETBOOTSTATUS, &amp;flags); Note that not all devices support these two calls, and some only support the GETBOOTSTATUS call. Some drivers can measure the temperature using the GETTEMP ioctl. The returned value is the temperature in degrees fahrenheit. 12int temperature;ioctl(fd, WDIOC_GETTEMP, &amp;temperature); Finally the SETOPTIONS ioctl can be used to control some aspects of the cards operation. 12int options = 0;ioctl(fd, WDIOC_SETOPTIONS, &amp;options); The following options are available: WDIOS_DISABLECARD Turn off the watchdog timer WDIOS_ENABLECARD Turn on the watchdog timer WDIOS_TEMPPANIC Kernel panic on temperature trip]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Linux</tag>
        <tag>翻译</tag>
        <tag>wdt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux笔记—rtc子系统]]></title>
    <url>%2F2017%2F08%2F19%2Flinux%E7%AC%94%E8%AE%B0%E2%80%94rtc%E5%AD%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[正式开始让人崩溃的linux系列，希望自己能写完。先拿rtc开刀。 这里我尽可能记录下思维的细节，而不是仅局限于代码，希望自己能领会Linux内核开发者的想法。 内核版本：linux4.1 需要了解：简略了解字符驱动 和 Linux设备驱动模型 RTC rtc即real time clock，实时时钟。 rtc一般负责系统关机后计时，面对繁多的Linux RTC设备，内核干脆提供了一个rtc子系统，来支持所有的rtc设备。 参考资料 rtc子系统 rtc设备本质上是一个字符设备，rtc子系统在字符设备的基础上抽象与硬件无关的部分，并在这个基础上拓展sysfs和proc文件系统下的访问。 分析时候始终记住两点： rtc子系统是为了让rtc设备驱动编写更为简单，与硬件无关部分已被抽离。 rtc子系统是基于字符设备而来的。文件框架 rtc子系统的源码在 /drivers/rtc删减了很多rtc-xxx.c的驱动，只留下了ds1307作为示例，这里看到实际上代码并不多。 具体文件分析 rtc.h：定义与RTC有关的数据结构。 class.c：向内核注册RTC类，为底层驱动提供rtc_device_register与rtc_device_unregister接口用于RTC设备的注册/注销。初始化RTC设备结构、sysfs、proc。 Interface.c：提供用户程序与RTC的接口函数，其中包括ioctl命令。 rtc-dev.c：将RTC设备抽象为通用的字符设备，提供文件操作函数集。 rtc-sysfs.c：管理RTC设备的sysfs属性，获取RTC设备名、日期、时间等。 rtc-proc.c：管理RTC设备的procfs属性，提供中断状态和标志查询。 rtc-lib.c：提供RTC、Data和Time之间的转换函数。 rtc-xxx,c：RTC设备的实际驱动，此处以rtc-ds1307为例。 hctosys.c：开机时获取RTC时间。 整个文件系统框架 RTC子系统具体可分为3层： 用户层：RTC子系统向上层提供了接口，用户通过虚拟文件系统，间接调用RTC设备，具体有3种方式。 /dev/rtc RTC设备抽象而来的字符设备，常规文件操作集合。 /sys/class/rtc/rtcx 通过sysfs文件系统进行RTC操作，也是最常用的方式。 /proc/driver/rtc 通过proc文件系统获取RTC相关信息。 RTC核心层：与硬件无关，用于管理RTC设备注册/注销、提供上层文件操作的接口等。 RTC驱动：特定RTC设备的驱动程序，实现RTC核心层的回掉函数。编写RTC驱动需要按照RTC子系统的接口填写对应函数并建立映射即可。RTC核心层函数实现的过程和数量与特定硬件紧密相关。 初看linux系统的人来说，这个图够头晕的了，但是呢，实际上没那么麻烦。由浅入深，一点一点来分析。 rtc子系统分析rtc-dev rtc子系统基于字符设备，字符设备对应的肯定是rtc-dev.c了，我们的分析由rtc-dev起步。 rtc-dev.c 典型的字符设备，模块的初始化/卸载自然是 rtc_dev_init(void) 和 rtc_dev_exit(void)。设备接入，添加/删除设备 rtc_dev_add_device(struct rtc_device rtc) 和 e) void rtc_dev_del_device(struct rtc_device rtc)还有ioctl和open等函数，熟悉字符设备驱动的不用多说。 追踪一下这两组函数在哪里调用的。 rtc_dev_init(void)对应在 class.c的rtc_init(void)函数 rtc_dev_add_device对应在class.c的 rtc_device_register()函数。 rtc_dev_init(void)对应实在系统初始化时使用，对应rtc_init(void)也是在系统初始化之后调用。 rtc_dev_add_device()是在驱动匹配后调用，rtc_device_register()也是在驱动匹配后调用。打开rtc-ds1307.c&gt;-prob函数，能找到rtc_device_register()也就证实了这个思路。 接下来转入class.c class.c linux驱动模型中class.c对应类的意思，是rtc类。每个class对应都有自己核心数据结果，对应rtc类就是rtc-device rtc_device rtc_device代表 RTC设备基础的数据结构 数据结构12345678910111213141516171819202122232425262728 struct rtc_device &#123; struct device dev; struct module *owner; int id; //RTC设备的次设备号 char name[RTC_DEVICE_NAME_SIZE]; const struct rtc_class_ops *ops; struct mutex ops_lock; struct cdev char_dev; unsigned long flags; unsigned long irq_data; spinlock_t irq_lock; wait_queue_head_t irq_queue; struct fasync_struct *async_queue; struct rtc_task *irq_task; spinlock_t irq_task_lock; int irq_freq; int max_user_freq; #ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL struct work_struct uie_task; struct timer_list uie_timer; /* Those fields are protected by rtc-&gt;irq_lock */ unsigned int oldsecs; unsigned int uie_irq_active:1; unsigned int stop_uie_polling:1; unsigned int uie_task_active:1; unsigned int uie_timer_active:1; #endif &#125;; 很长？很😵对不对？只要关注一点就行_ 1234567int id; //代表是那个rtc设备 char name[RTC_DEVICE_NAME_SIZE]; //代表rtc设备的名称 const struct rtc_class_ops *ops; //rtc操作函数集，需要驱动实现 struct mutex ops_lock; //操作函数集的互斥锁 struct cdev char_dev; //代表rtc字符设备，因为rtc就是个字符设备 unsigned long flags; //rtc的状态标志，例如RTC_DEV_BUSY 上文书说到，驱动程序的prob函数里面调用了rtc_device_register()这货的类型就是rtc_device。参加驱动程序怎样调用rtc_deviceregister(),与其他核心的基本结构不同的是，驱动程序以不是以rtc-device为参数注册设备到子系统，而是注册函数会返回一个rtcdeivce的结构给驱动。 rtc_class_ops 这个是rtcdevice的一部分。 数据结构 12345678910111213141516 struct rtc_class_ops &#123; int (*open)(struct device *); //打开设备时的回调函数，这个函数应该初始化硬件并申请资源 void (*release)(struct device *); //这个函数是设备关闭时被调用的，应该注销申请的资源 int (*ioctl)(struct device *, unsigned int, unsigned long); //ioctl函数，对想让RTC自己实现的命令应返回ENOIOCTLCMD int (*read_time)(struct device *, struct rtc_time *); //读取时间 int (*set_time)(struct device *, struct rtc_time *); //设置时间 int (*read_alarm)(struct device *, struct rtc_wkalrm *); //读取下一次定时中断的时间 int (*set_alarm)(struct device *, struct rtc_wkalrm *); //设置下一次定时中断的时间 int (*proc)(struct device *, struct seq_file *); //procfs接口 int (*set_mmss)(struct device *, unsigned long secs); //将传入的参数secs转换为struct rtc_time然后调用set_time函数。程序员可以不实现这个函数，但 前提是定义好了read_time/set_time，因为RTC框架需要用这两个函数来实现这个功能。 int (*irq_set_state)(struct device *, int enabled); //周期采样中断的开关，根据enabled的值来设置 int (*irq_set_freq)(struct device *, int freq); //设置周期中断的频率 int (*read_callback)(struct device *, int data); ///用户空间获得数据后会传入读取的数据，并用这个函数返回的数据更新数据。 int (*alarm_irq_enable)(struct device *, unsigned int enabled); //alarm中断使能开关，根据enabled的值来设置 int (*update_irq_enable)(struct device *, unsigned int enabled); //更新中断使能开关，根据enabled的值来设置 &#125;; 该结构体中函数大多数都是和rtc芯片的操作有关，需要驱动程序实现。所有RTC驱动都必须实现read_time、set_time函数，其他函数可选。 参考其他的资料，class的分析如下 static int __init rtc_init(void) 调用class_create创建RTC类，创建/sys/class/rtc目录，初始化RTC类相关成员，向用户空间提供设备信息。 调用rtc-dev.c实现的rtc_dev_init();动态分配RTC字符设备的设备号。 调用rtc_sysfs_init(rtcclass)；创建/sys/class/rtc下属性文件 static void __exit rtcexit(void) 调用rtc-dev.c实现的rtc_dev_exit()；注销设备号。 调用class_destroy(rtc_class)；注销/sys/class下的rtc目录 struct rtc_device rtc_device_register(const char name, struct device dev,const struct rtc_class_ops ops,struct module *owner）_ 申请一个idr整数ID管理机制结构体，并且初始化相关成员 将设备dev关联sysfs下的rtc类 初始化rtc结构体的信号量 初始化rtc结构体中的中断 设置rtc的名字 初始化rtc字符设备的设备号，然后注册rtc设备,自动创建/dev/rtc(n)设备节点文件 注册字符设备 在/sys/rtc/目录下创建一个闹钟属性文件 创建/proc/driver/rtc目录 void rtc_device_unregister(struct rtc_device *rtc) 删除sysfs中的rtc设备,即删除/sys/class/rtc目录 删除dev下的/dev/rtc(n)设备节点文件 删除虚拟文件系统接口,即删除/proc/driver/rtc目录 卸载字符设备 清空rtc的操作函数指针rtc-&gt;ops 释放rtc的device结构体_ static void rtc_device_release(struct device dev) 卸载idr数字管理机制结构体 释放rtc结构体的内存 Rtc子系统初始化 上图 使用rtc子系统首先需要在内核编译选项中启用RTC子系统支持。 必须启用Real Time Clock 使用/dev下的设备文件对应开启CONFIG_RTC_INTF_DEV 使用/proc下的接口对应开启CONFIG_RTC_INTF_PROC 使用/sysfs下的接口对应开启CONFIG_RTC_INTF_SYSFS _系统启动后，如配置启用rtc子系统，则会首先执行rtcinit函数，创建rtc类、初始化相关成员、分配设备号等 创建rtc类后，之后调用rtc_dev_init()动态分配rtc字符设备的设备号。之后调用rtc_sysfs_init()初始化/sys/class/rtc目录中的属性文件 Rtc设备注册 Rtc设备本质上属于字符设备，依附于系统内总线。一般来说cpu内部rtc依附于platform总线，外置rtc芯片则依附于通信方式对应总线。其过程与通用字符设备相似，rtc子系统在设备注册过程中附加了prob和sysfs相关的注册和初始化操作。 上图 Rtc设备挂载后，相应总线会搜索匹配的驱动程序，驱动程序成功match后，进入驱动实现的probe函数，执行设备注册等操作。 完成总线设备注册后，probe会跳转到rtc_device_register()函数，将设备注册到rtc子系统。 Rtc设备本质属于字符设备，会调用rtc_dev_prepare()函数，初始化字符设备，设置rtc相关的file operation函数集合。 之后依次调用rtc_dev_add_device(rtc)、rtc_sysfs_add_device(rtc)、rtc_proc_add_device(rtc) ，进行注册字符设备、在/sys/rtc/目录下创建一个闹钟属性文件、创建/proc/driver/rtc目录等操作。 rtc_device_register()会将驱动实现的rtc_class_ops结构体与具体设备联系起来。 interface.c 在rtc-proc.c、rtc_sysfs和ioctl命令中，所有的操作调用的都是interface.c提供的接口，这里以ioctl的一个例子说明整个调用的过程 上图 以icotl命令RTC_RD_TIME为例，说明命令调用的流程。 RTC_RD_TIME对应的是/dev下ioctl命令，调用被转发至/rtc-dev.c rtc-dev.c-&gt;rtc_dev_ioctl(struct file *file,unsigned int cmd, unsigned long arg)函数中。RTC_RD_TIME对应的代码为err = rtc_read_time(rtc, &amp;tm); rtc_read_time是interface.c文件提供的接口之一。 interface.c-&gt;rtc_read_time(struct rtc_device rtc, struct rtc_time tm)函数中对应rtc_class_ops转发代码为err = rtc-&gt;ops-&gt;read_time(rtc-&gt;dev.parent, tm);将操作转发至匹配的rtc设备。 设备驱动这里以rtc-ds1307为例，但设备注册时通过mcp794xx_rtc_ops结构体将rtc_class_ops对应函数与驱动程序实现的函数绑定 1234567static const struct rtc_class_ops mcp794xx_rtc_ops = &#123;.read_time = ds1307_get_time,.set_time = ds1307_set_time,.read_alarm = mcp794xx_read_alarm,.set_alarm = mcp794xx_set_alarm,.alarm_irq_enable = mcp794xx_alarm_irq_enable,&#125;; 最终执行转入ds1307.c-&gt; ds1307_get_time函数，执行与硬件相关的操作。 rtc-sysfs.c 由前半部分可知，/sys/class/rtc/是在rtc-init调用rtc_sysfs_init后生成。 123void __init rtc_sysfs_init(struct class *rtc_class) &#123; rtc_class-&gt;dev_groups = rtc_groups;&#125; 这里的rtc_groups是rtc-sysfs.c中定义了这样一个attribute函数指针数组： 12345678910static struct attribute *rtc_attrs[] = &#123;&amp;dev_attr_name.attr,&amp;dev_attr_date.attr,&amp;dev_attr_time.attr,&amp;dev_attr_since_epoch.attr,&amp;dev_attr_max_user_freq.attr,&amp;dev_attr_hctosys.attr,NULL,&#125;;ATTRIBUTE_GROUPS(rtc); _在rtc_sysfs_init函数调用后绑定了sysfs节点操作函数的集合，使得设备匹配驱动程序后而生成对应的rtcn文件夹。 dev_attr_name和dev_attr_data由宏DEVICE_ATTR_RO和DEVICE_ATTR_RW生成，他们分别定义了只读的和可读可写的attribute节点。每个属性函数下都有DEVICE_ATTR_XX()宏声明，绑定到对应attribute节点。 rtc-proc.c proc文件系统是软件创建的文件系统，内核通过他向外界导出信息，下面的每一个文件都绑定一个函数，当用户读取这个文件的时候，这个函数会向文件写入信息。 rtc-proc.c中初始化了file_operations结构体： 123456static const struct file_operations rtc_proc_fops = &#123; .open = rtc_proc_open, .read = seq_read, .llseek = seq_lseek, .release = rtc_proc_release, &#125;; _RTC驱动在向RTC核心注册自己的时候，由注册函数rtc_device_resgister调用rtc_proc_add_device来实现proc接口的初始化，这个函数如下定义： 12345void rtc_proc_add_device(struct rtc_device *rtc) &#123; if (rtc-&gt;id == 0) proc_create_data(&quot;driver/rtc&quot;, 0, NULL, &amp;rtc_proc_fops, rtc); &#125; 主要是完成创建文件节点，并将文件的操作函数与节点联系起来。调用这个函数后，在/proc/driver目录下就会有一个文件rtc rtc设备访问 rtc子系统最多可以支持16个rtc设备，多个rtc设备会在/dev/和 /sys/class/rtc/下生成rtc0、rtc1…等不同节点(下文以rtcn代称)。而系统启动时会选择一个rtc设备读取计时，在/dev下有rtc文件，rtc文件指向系统选择的rtc设备对应的rtcn（一般为rtc0）。 用户层访问rtc设备有3种途径： /dev/rtcn open等字符设备操作和ioctl命令。 /sys/class/rtc/rtcn sysfs 属性，一些属性是只读。 /proc/driver/rtc 第一个rtc会占用procfs接口，在procfs下暴露更多信息。 /dev 在/dev下用户可以通过两种方式访问rtc设备，第一个是通过字符设备定义的open、read等函数（需要驱动程序实现）、另一个是通过定义的ioctl命令。第一种方式是直接打开rtc-dev.c定义的open等函数，在open等中直接调用驱动程序实现的函数。通过ioctl命令访问则是将操作转发到了interface.c定义的接口，间接调用驱动程序实现的函数。 ioctl()函数访问/dev下的设备。以下是典型函数：_ ioctl(fd,RTC_ALM_SET, &amp;rtc_tm);设置alarm中断的触发时刻，不超过24小时。第三个参数为structrtc_time结构体，读取时会忽略年月日信息。alarm中断与wakeupalarm中断只能同时使用1个，以最后一次设定为准。 ioctl(fd,RTC_ALM_READ, &amp;rtc_tm)读取alarm中断的触发时刻。 ioctl(fd,RTC_WKALM_SET, &amp;alarm);设置wakeupalarm中断的触发时刻， wakeupalarm中断的触发时刻可以在未来的任意时刻。alarm中断与wakeupalarm中断只能同时使用1个，以最后一次设定为准。 ioctl(fd,RTC_WKALM_RD, &amp;alarm);读取wakeupalarm中断的触发时刻。 ioctl(fd,RTC_IRQP_SET, tmp);设置周期中断的频率，tmp的值必须是2的幂，非Root用户无法使用64HZ以上的周期中断。 ioctl(fd,RTC_IRQP_READ, &amp;tmp);读取周期中断的频率。 ioctl(fd,RTC_SET_TIME, &amp;rtc_tm)更新RTC芯片的当前时间。 ioctl(fd,RTC_RD_TIME, &amp;rtc_tm);读取RTC硬件中的当前时间。 以open操作为例，在用户层对/dev下设备执行open会被转发至rtc_dev_open(struct inode *inode, struct file *file)函数，通过err= ops-&gt;open ? ops-&gt;open(rtc-&gt;dev.parent) : 0;判断驱动程序是否通过连接的rtc_class_ops结构体实现了open函数，驱动程序实现了open函数，则将open操作转发至驱动程序。 /sys /sys/class/rtc/rtcn下面的sysfs接口提供了操作rtc属性的方法，所有的日期时间都是墙上时间，而不是系统时间。 date: RTC提供的日期 hctosys: 如果在内核配置选项中配置了CONFIG_RTC_HCTOSYS，RTC会在系统启动的时候提供系统时间，这种情况下这个位就是1,否则为0 max_user_freq: 非特权用户可以从RTC得到的最大中断频 name: RTC的名字，与sysfs目录相关 since_epoch: 从纪元开始所经历的秒数 time: RTC提供的时间 wakealarm: 唤醒时间的时间事件。 这是一种单次的唤醒事件，所以如果还需要唤醒，在唤醒发生后必须复位。这个域的数据结构或者是从纪元开始经历的妙数，或者是相对的秒数 /proc /proc/driver/rtc下只对应第一个rtc设备，与sysfs下相比，该设备暴露更多信息 对应截图 RTC子系统测试Hwclock命令或使用测试文件。 Hwclock命令可以执行最简单的RTC测试。常用命令示例如下 hwclock #查看RTC时间 hwclock -set -date=”07/07/17 10:10” #设置硬件RTC时间（月/日/年 时:分:秒） hwclock -w #系统时间同步至RTC hwclock -s #同步RTC到系统时间 Linux内核提供了RTC子系统的测试示例文件，位于tools/testing/selftests/timers/rtctest.c，包含了基于ioctl命令的完整测试。]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Linux</tag>
        <tag>rtc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux笔记——时间子系统（一）]]></title>
    <url>%2F2017%2F08%2F15%2Flinux%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ss]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Linux</tag>
        <tag>timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核C语言中的面向对象]]></title>
    <url>%2F2017%2F07%2F11%2FLinux%E5%86%85%E6%A0%B8C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[转载自”Blog of UnicornX” (http://unicornx.github.io/) 面向对象的思想在c语言中的应用，第一次看到才知道c语言还能这么用。。。 前言 语言只是工具，重要的是思想。但是！！C语言用面向对象？？看了内核代码，真给那些写Linux、内核的大神跪了。。。 当然因为C语言的局限性，并非完全面向对象的实现，私有成员等就没有了。 封装 既类在C语言中的实现，实际上是 struct + 函数体 = 函数表结构体里不允许存在成员函数，但是换成指向函数的指针是可以滴。 示例12345struct foo_operations &#123; void (*op_a) (struct foo *, loff_t, int); void (*op_b) (struct foo *, char __user *, size_t, loff_t *); void (*op_c) (struct foo *, const char __user *, size_t, loff_t *); &#125;; 继承 这个简单点， struct 里面套 struct ，警告熟悉c语言的应该都清除。。。这里没有父类子类的严格区分，实际上是完全自由的。 示例123456struct foo &#123; int a; int b; int c; struct foo_operations ops;&#125;; 多态 这个是最有意思的，c语言中严格规定同一个.c文件/工程中不能存在重名函数，但是c语言的精华-指针给了思路，借助结构体，我函数名不变，每指向不同的结构体变量就行了。。。虽然还是很麻烦。。 示例123456struct foo a;a-&gt;ops = ops1;a-&gt;ops-&gt;op_a(a);//切换a-&gt;ops = ops2;a-&gt;ops-&gt;op_a(a); 链表 内核内大量运用链表，开始不清楚真是头晕。。 示例 123 struct list_head &#123;struct list_head *next, *prev; &#125;; 一个指向自身的结构体，包含下一个与自身的指针。使用 1234struct A_LIST &#123; data_t data; struct list_head *list;&#125;; offsetof宏 1#define offsetof(type, member) (size_t)&amp;(((type*)0)-&gt;member) offsetof是用来判断结构体中成员的偏移位置 containerof宏 123#define container_of(ptr, type, member) (&#123; \ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \ (type *)( (char *)__mptr - offsetof(type,member) );&#125;) 根据一个结构体变量中的一个域成员变量的指针来获取指向整个结构体变量的指针..链表元素常用]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—乐联网上传数据 TCP长连接总结]]></title>
    <url>%2F2017%2F06%2F11%2FAndroid%E7%AC%94%E8%AE%B0-%E4%B9%90%E8%81%94%E7%BD%91%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%20TCP%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[资料来源如下 乐联网 编程环境 Android Studio 2.2.3 导语 毕设中的乐联网部分,记录以供复习 开源在github上 https://github.com/Jasper-1024/HbuLeWei 最终效果 使用okhttp上传数据。 Tcp长连接实现方向控制 以代码为主 相关教程 okhttp入门 http://blog.csdn.net/biezhihua/article/details/50603624 乐联网 https://www.lewei50.com/dev/doc/176https://www.lewei50.com/dev/doc/155 Tcp长连接 http://ls15114843569.blog.51cto.com/11015399/1767195 简易上传 http://ls15114843569.blog.51cto.com/11015399/1767195 上传数据 API介绍 https://www.lewei50.com/dev/apiinfo/3 API测试 https://www.lewei50.com/dev/apitest/3 地址：http://www.lewei50.com/api/v1/gateway/updatesensors/你的网关号 POST方式 需要配置header头 Userkey 数据发送/返回方式JSON 12345678910[ &#123; "Name":"T1", "Value":"1" &#125;, &#123; "Name":"01H1", "Value":"96.2" &#125;] 返回格式 1234&#123; "Successful": true, "Message": null&#125; okhttp POST 传感器数据 这里使用了一个静态内部类。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 //返回数据处理 public okhttp3.Callback callback = new okhttp3.Callback() &#123; @Override public void onResponse(Call call, Response response) throws IOException &#123; //返回服务器内容 String responsedata = response.body().string(); LogUtil.d("okHttp", responsedata); &#125; @Override public void onFailure(Call call, IOException e) &#123; //异常处理 LogUtil.d("okHttp", "POST错误"); &#125; &#125;;//内部类 public static class Http &#123; public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");//POST数据，指定接收回掉 public static void postData(String sensor_name, String sensor_data, okhttp3.Callback callback) &#123; OkHttpClient client = new OkHttpClient(); final String value = "[" + " &#123;" + " \"Name\":\"" + sensor_name + "\"," + " \"Value\":\"" + sensor_data + "\"" + " &#125;" + "]"; RequestBody requestBody = new RequestBody() &#123; @Override public MediaType contentType() &#123; return MEDIA_TYPE_MARKDOWN; &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; sink.write(value.getBytes()); &#125; &#125;; Request request = new Request.Builder() .url("http://www.lewei50.com/api/V1/gateway/UpdateSensors/01") .header("userkey", "你的userkey") .post(requestBody) .build(); client.newCall(request).enqueue(callback); &#125; &#125; 实际使用 放在一个后台服务内，调用相当简单1Http.postData("PM2.5", "你的数据转为String", callback); Tcp长连接，远程控制 首先参考乐联网反向控制教程，新建一个控制器，这里以开关为例。 原理是与服务器保持一个TCP长连接，不到40s刷新一次，以此保持通道，与被控制段通信，发送控制信息。 Tcp长连接参考了@墨迹流韶的Android基于Tcp协议的Socket长链接封装 地址 tcp.lewei50.com端口号 9960心跳包间隔 1min以内 发送/接收数据格式 Json本地发送数据格式 123456789&#123; "method": "update", "gatewayNo": "你的网关号", "userkey": "你的userkey"&#125;&amp;^! 服务器发送控制命令格式，数据处理时需要去掉字符串最后的&amp;^! 12345678910111213141516&#123;"method":"send","gatewayNo":"01","userkey":"6d16ddb3c58c4e448a7e15e7acxxxxxx","f":" updateSensor","p1":"D1","p2":"1"&#125;&amp;^! 本地响应控制命令后返回数据格式 12345678910111213141516171819&#123;"method":"response","result":&#123; "successful":true, "message":"ok!", "data":[&#123; "id":"D1", "value":"1" &#125;, &#125;&amp;^! TCP连接类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class TcpSocketHelper &#123; private String mTag = "TcpSocketHelper"; private Socket socket; private boolean _connect; private ReceiveThread mReceiveThread; private boolean receiveStop; private Date lastKeepAliveOkTime; private OnRecivedListener mRecivedListener; //地址 private String mIpAddr = "http://tcp.lewei50.com"; //端口 private int mPort = 9960; /** * 开启链接socket * @param ipAddr * @param port */ public void startConnect(String ipAddr, int port)&#123; LogUtil.d(mTag, "准备链接..."); this.mIpAddr = ipAddr; this.mPort = port; InetAddress serverAddr; try &#123; socket = new Socket(ipAddr, port); LogUtil.d(mTag, "准备链接..."); _connect = true; mReceiveThread = new ReceiveThread(); receiveStop = false; mReceiveThread.start(); LogUtil.d(mTag, "链接成功..."); &#125; catch (Exception e) &#123; LogUtil.d(mTag, "链接出错..." + e.getMessage()); e.printStackTrace(); &#125; &#125; /** * 关闭链接 */ public void closeConnect()&#123; if (socket != null)&#123; try &#123; socket.close(); socket = null; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 保持心跳 */ public void KeepAlive() &#123; // 判断socket是否已断开,断开就重连 if (lastKeepAliveOkTime != null) &#123; LogUtil.d(mTag, "上次心跳成功时间:"+ DateFormat.format("yyyy-MM-dd HH:mm:ss", lastKeepAliveOkTime)); Date now = Calendar.getInstance().getTime(); long between = (now.getTime() - lastKeepAliveOkTime.getTime());// 得到两者的毫秒数 if (between &gt; 60 * 1000) &#123; LogUtil.d(mTag, "心跳异常超过40,重新连接:"); lastKeepAliveOkTime = null; socket = null; &#125; &#125; else &#123; lastKeepAliveOkTime = Calendar.getInstance().getTime(); &#125; if (!checkIsAlive()) &#123; LogUtil.d(mTag, "链接已断开,重新连接."); startConnect(mIpAddr, mPort); &#125; &#125; /** * 此方法是检测是否连接 * @return */ public boolean checkIsAlive() &#123; if (socket == null||!socket.isConnected()) return false; return true; &#125; /** * 发送数据的方法 * @param msg */ public void sendmessage(String msg) &#123; boolean isAlive = checkIsAlive(); if (!isAlive) return; LogUtil.d(mTag, "准备发送消息:" + msg); try &#123; if (socket != null &amp;&amp; socket.isConnected()) &#123; if (!socket.isOutputShutdown()) &#123; //2.得到socket读写流 OutputStream os=socket.getOutputStream(); //true:是否自动flush PrintWriter outStream=new PrintWriter(os, true); outStream.print(msg); outStream.flush(); &#125; &#125; LogUtil.d(mTag, "发送成功!"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 设置接收数据监听器 * @param mRecivedListener */ public void setmRecivedListener(OnRecivedListener mRecivedListener) &#123; this.mRecivedListener = mRecivedListener; &#125; /** * 数据接收线程 */ class ReceiveThread extends Thread&#123; @Override public void run() &#123; while (true) &#123; try &#123; sleep(2000); // 判断 Socket 是否处于连接状态 if (socket != null &amp;&amp; socket.isConnected()) &#123; // 客户端接收服务器端的响应，读取服务器端向客户端的输入流 InputStream isRead = socket.getInputStream(); // 缓冲区 byte[] buffer = new byte[isRead.available()]; // 读取缓冲区 isRead.read(buffer); // 转换为字符串 String responseInfo = new String(buffer); // 日志中输出 if(responseInfo != null&amp;&amp;!responseInfo.equals(""))&#123; LogUtil.d("TcpManager", "返回："+responseInfo); mRecivedListener.onRecived(responseInfo); &#125; lastKeepAliveOkTime = Calendar.getInstance().getTime(); KeepAlive(); continue; &#125; else &#123; if (socket != null) LogUtil.d(mTag, "链接状态:" + socket.isConnected()); &#125; &#125; catch (Exception e) &#123; LogUtil.d(mTag, "监听出错:" + e.toString()); e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 使用,包装在一个后台service中，在service中实现TcpSocketHelper的onRecived方法 1234567891011 //tcp返回信息 @Override public void onRecived(String data) &#123; LogUtil.d(&quot;okHttpService&quot;, data); //处理服务器发回的数据 &#125;TcpSocketHelper tcpSocketHelper = new TcpSocketHelper();tcpSocketHelper.startConnect(&quot;tcp.lewei50.com&quot;, 9960);//设置监听tcpSocketHelper.setmRecivedListener(this); 发送心跳包12345678String value = " &#123;" + " \"method\":\"update\"," + " \"gatewayNo\":\"01\"," + " \"userkey\":\"你的userkey\"" + " &#125;&amp;^!"; //发送数据 tcpSocketHelper.sendmessage(value); 处理数据 在service的onRecived中 本地处理完毕后，向服务器返回被控制器状态 123String value5 = "&#123;\"method\":\"response\",\"result\":&#123;\"successful\":true,\"message\":\"ok!\",\"data\":[&#123;\"id\":\"D1\",\"value \":\"1\"&#125;]&#125;&#125;&amp;^! "; tcpSocketHelper.sendmessage(value6);]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
        <tag>毕设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记-自用MVP框架]]></title>
    <url>%2F2017%2F05%2F08%2FAndroid%E7%AC%94%E8%AE%B0-%E8%87%AA%E7%94%A8MVP%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[资料来源如下 网络 编程环境 Android Studio 2.2.3 导语 转眼刚用上手的MVP又不符合需求了，还是总结一下，继续MVVM吧。 起 主要内容是转载，搭建小工程应该足够了。Android mvp 架构的自述如何更高效的使用MVP以及官方MVP架构解析 框架开源在GitHub 地址点我直达 好，我们开始吧！ MVC MVP MVVM 省略200行，详情看Android App的设计架构：MVC,MVP,MVVM与架构经验谈 再累赘属于掉书袋了，作者写的是很用心，恩，MVVM也有。 框架详解 整个框架截图 整体层次比较明确了，BaseClass 里存放基类，Model层存放数据存储有关类、Presenter层存放逻辑代码、View层存放Activity、frament等。 这个框架是由MVP在Android中应用存在的问题而搭建的，基类中代码也由此而来。 问题 presenter一直持有Activity对象导致的内存泄漏问题 使用mvp的时候，presenter会持有view，如果presenter有后台异步的长时间的动作，比如网络请求，这时如果返回退出了Activity，后台异步的动作不会立即停止，这里就会有内存泄漏的隐患。 需要一个销毁view的方法，这里是在基类中完成的。 presenter绑定和解绑繁琐 一般一个presenter对应一个Activity，一般应用内存在多个Actiivity，绑定与解绑相当繁琐。 统一在 Basepresenter 与 BaseActivity中进行，同时解决内存泄漏问题，还有其他常用内容一并添加。 presenter 与 Model 的通信问题。 presenter已经与View层 强耦合了，框架中需要解耦presenter 与 Model ，使用异步通信。Handle等都太复杂了。。。 开始没有什么好的解决办法，直到遇到了EventBus，当然EventBus也不是万能解决方案，跨进程，还是要另辟蹊径，不过EventBus足够自己写着完了。还有Rxjava，恩，还在玩着，没搞太懂。 代码 BasePresenter123456789101112 public abstract class BasePresenter&lt;Viewinterface&gt; &#123; //传入泛型 public Viewinterface mView; //绑定 public void attach(Viewinterface mView) &#123; this.mView = mView; &#125; //解绑，防止view为空是内存泄漏 public void dettach() &#123; mView = null; &#125;&#125; BaseActivity1234567891011121314151617181920212223242526272829303132 public abstract class BaseActivity &lt;Viewinterface,mPresenter extends BasePresenter&lt;Viewinterface&gt;&gt;extends AppCompatActivity &#123; //获取Presenter对象 public mPresenter mpresenter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //Presenter实例化 mpresenter = initPresenter(); //打印当前activity LogUtil.d("Activity", getClass().getSimpleName()+"onCreate"); &#125; @Override protected void onResume() &#123; //重新刷新时重新绑定view mpresenter.attach((Viewinterface) this); super.onResume(); LogUtil.d("Activity", getClass().getSimpleName()+"onResume"); &#125; @Override protected void onDestroy() &#123; //解绑presenter持有的view mpresenter.dettach(); super.onDestroy(); LogUtil.d("Activity", getClass().getSimpleName()+"onDestroy"); &#125; public abstract mPresenter initPresenter();&#125; Presenter12 public interface Presenter &#123;&#125; mPresenter12345678 public class mPresenter extends BasePresenter&lt;Viewif&gt; implements Presenter &#123; private Model mModel; public mPresenter(Viewif view) &#123; this.attach(view); this.mModel = new mModel(); &#125;&#125; BaseView 123 public interface BaseView&lt;T&gt; &#123;&#125; Viewif 123 public interface Viewif extends BaseView &#123;&#125; MainActivity12345678910111213141516 public class MainActivity extends BaseActivity&lt;Viewif, mPresenter&gt; implements Viewif&#123; Presenter presenter; //Presenter初始化 public mPresenter initPresenter() &#123; return new mPresenter(this); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; //presenter初始化 presenter = mpresenter; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; LogUtil123456789101112131415161718192021222324252627282930313233343536373839 public class LogUtil &#123; public static final int VERBOSE = 1;//啰嗦，等级最低的 public static final int DEBUG = 2;//调试 public static final int INFO = 3;//信息 public static final int WARN = 4;//警告 public static final int ERROR = 5;//错误 public static final int NOTHING = 6;//什么也不打印出来 public static final int level = VERBOSE;//LEVEL:标准 public static void v(String tag, String msg) &#123; if (level &lt;= VERBOSE) &#123;//如果大于或者等于定义的标准就打印出来 Log.v(tag, msg); &#125; &#125; public static void d(String tag, String msg) &#123; if (level &lt;= DEBUG) &#123; Log.d(tag, msg); &#125; &#125; public static void i(String tag, String msg) &#123; if (level &lt;= INFO) &#123; Log.i(tag, msg); &#125; &#125; public static void w(String tag, String msg) &#123; if (level &lt;= WARN) &#123; Log.w(tag, msg); &#125; &#125; public static void e(String tag, String msg) &#123; if (level &lt;= ERROR) &#123; Log.e(tag, msg); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—蓝牙串口(BlueTooth+EventBus)]]></title>
    <url>%2F2017%2F04%2F17%2FAndroid%E7%AC%94%E8%AE%B0-%E8%93%9D%E7%89%99%E4%B8%B2%E5%8F%A3%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88BlueTooth%2BEventBus%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) 编程环境 Android Studio 2.2.3 导语 毕设中的蓝牙部分,记录以供复习 概述最终效果 Android应用 与 Hc-05 蓝牙模块连接,单片机与 Android 端 可以通过串口正常收发数据. 预留足够灵活的接口, Android 应用中可以在任意位置获取到蓝牙数据 Activity切换时,蓝牙连接不断开. 用到的开源库/知识点资料 简介/来源 蓝牙:Android API 指南 https://developer.android.com/guide/topics/connectivity/bluetooth.html EventBus:EventBus-GitHub 是一个Android端优化的publish/subscribe消息总线,用来替代 Intent 、 Handler 、 Broadcast 等在 Actvity 、 Fragment 、 Service 等组件之间传递信息 . EventBus 可以传递一个完整的对象,简单高效, 注意 EventBus 只能在多线程之间传递消息,无法在不同进程之间传递消息 ,EventBus 3.0 以后进一步简化了传递方式,真的是很值得学习的一个开源库! 参考资料如下: EventBus 3.0初探: 入门使用及其使用 完全解析 EventBus3(3.0.0)源码解析 基础部分 蓝牙 与 EventBus 基础部分 BlueTooth 备注 : 这里使用的是 传统蓝牙 即 蓝牙4.0以前版本, 而不是 蓝牙4.0 ( ble低功耗蓝牙)及以后版本 Android 对 Bluetooth 做了很好的封装,我们可以比较轻松的在 Android Bluetooth API 上进行开发. Android中所有蓝牙API均来自 android.bluetooth 包 BlueTooth基础 BluetoothAdapter 本地蓝牙适配器BluetoothAdapter 是所有蓝牙交互的入口点, 在初始化蓝牙及蓝牙配对阶段使用1.发现其他蓝牙设备2.查询绑定（配对）设备的列表3.使用已知的 MAC 地址实例化 BluetoothDevice4.创建 BluetoothServerSocket 侦听来自其他设备的通信。 BluetoothDevice 远程蓝牙设备含有该设备的信息，例如设备的名称、地址、类和绑定状态等。 BluetoothSocket 蓝牙套接字接口（与 TCP Socket 相似）与 BluetoothDevice 配合建立远程连接,允许应用通过 InputStream 和 OutputStream 与其他蓝牙设备交换数据. 初始化蓝牙 声明蓝牙权限Android 应用使用蓝牙前都需要声明蓝牙权限一般只需要 BLUETOOTH 权限即可,但是考虑到之后有更多的需求,需要更改系统蓝牙设置,由此需要 BLUETOOTHADMIN 权限也一起声明 12345&lt;manifest ... &gt;&lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;...&lt;/manifest&gt; 蓝牙设备可用性 获取 BluetoothAdapter获取 BluetoothAdapter，需要静态 getDefaultAdapter() 方法。getDefaultAdapter() 会返回一个表示设备自身的蓝牙适配器的 BluetoothAdapter 设备不支持蓝牙 则返回 null 1234BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();if (mBluetoothAdapter == null) &#123; // 蓝牙不可用操作&#125; 开启蓝牙BluetoothAdapter 的 .isEnabled() 可以判断系统蓝牙是否开启.没有开启时 startActivityForResult() 发送包含 ACTION_REQUEST_ENABLE 的 Intent 请求系统开启蓝牙,并在 onActivityResult() 返回的数据中 RESULT_CANCELED 表示开启失败 RESULT_OK 表示开启成功,这里我们只检测开启失败情况,并提示用户 1234567891011121314if (!mBluetoothAdapter.isEnabled()) &#123; Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);&#125; protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == REQUEST_ENABLE_BT &amp;&amp; resultCode == RESULT_CANCELED) &#123; Toast.makeText(MyApplication.getContext(),R.string.Bluetooth_openfail, Toast.LENGTH_SHORT).show(); &#125; BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); if (mBluetoothAdapter == null) &#123; //设备不支持蓝牙时处理 &#125; &#125; 查询已配对的设备调用 getBondedDevices(),返回已配对设备的一组 BluetoothDevice.之后使用for循环遍历 123456789Set&lt;BluetoothDevice&gt; pairedDevices = mBluetoothAdapter.getBondedDevices();if (pairedDevices.size() &gt; 0) &#123; //重新加载bluetoothDeviceList bluetoothDeviceList.clear(); //BluetoothDevice列表循环 for (BluetoothDevice device : pairedDevices) &#123; bluetoothDeviceList.add(device); &#125; &#125; 扫描设备查找设备是非常耗费系统资源的事项，需要安排在子线程中执行，这里没有用到，由需要请参考Google官方蓝牙教程 连接设备蓝牙分主从机，链接为服务器/客户端。这里使用的是连接为客户端。 首先获取远程设备的 BluetoothDevice 对象，即在选择设备阶段的BluetoothDevice 调用 createRfcommSocketToServiceRecord(UUID) 获取 BluetoothSocket，UUID通用唯一识别码 在蓝牙中具体是什么没有很好的解释。这里的值取的是&quot;00001101-0000-1000-8000-00805F9B34FB&quot; 调用 connect() 发起连接,阻塞调用，需要在子线程中执行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//蓝牙连接子线程private class ConnectThread extends Thread &#123; private final BluetoothSocket mmSocket; //解析函数 ConnectThread(BluetoothDevice bluetoothDevice) &#123; // 使用一个中间变量 tmp // mmSocket 类型是 final BluetoothSocket tmp = null; // 获取 BluetoothSocket try &#123; // MY_UUID is the app's UUID string, also used by the server code tmp = bluetoothDevice.createRfcommSocketToServiceRecord(UUID.fromString(MyApplication.MY_UUID)); &#125; catch (IOException ignored) &#123; &#125; //赋值给 mmSocket mmSocket = tmp; &#125; public void run() &#123; // 关闭蓝牙扫描 MyApplication.getBluetoothAdapter().cancelDiscovery(); try &#123; // 通过 socket 连接到设备. connect() 会一直执行直到成功连接或者抛出异常 mmSocket.connect(); &#125; catch (IOException connectException) &#123; //无法连接到蓝牙,关闭连接并退出 try &#123; mmSocket.close(); &#125; //没有正常关闭 catch (IOException ignored) &#123; &#125; return; &#125; // Do work to manage the connection (in a separate thread) mConnectedThread = new ConnectedThread(mmSocket); mConnectedThread.start(); &#125; /** * 关闭蓝牙连接 */ void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException ignored) &#123; &#125; &#125;&#125; 管理连接获取BluetoothSocket获取 InputStream 和 OutputStream， getInputStream() 和 getOutputStream() 来处理数据传输。read(byte[]) 和 write(byte[]) 读取数据并写入到流式传输。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private class ConnectedThread extends Thread &#123; //BluetoothSocket private final BluetoothSocket mmSocket; //输入流 private final InputStream mmInStream; //输出流 private final OutputStream mmOutStream; ConnectedThread(BluetoothSocket socket) &#123; //传入BluetoothSocket，实例化mmSocket mmSocket = socket; //输入/输出流 中间变量 InputStream tmpIn = null; OutputStream tmpOut = null; // 输入输出流实例化 try &#123; tmpIn = socket.getInputStream(); tmpOut = socket.getOutputStream(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; mmInStream = tmpIn; mmOutStream = tmpOut; &#125; public void run() &#123; byte[] buffer = new byte[1024]; int bytes; // 连接成功时 while (true) &#123; try &#123; // 在InputStream读数据 bytes = mmInStream.read(); //发送数据 Events.bluetooth_Recycle bluetooth_recycle = new Events.bluetooth_Recycle(); bluetooth_recycle.s = bytes; bluetooth_recycle.bytes = String.valueOf((char) bytes); EventBus.getDefault().post(bluetooth_recycle); &#125; catch (IOException e) &#123; break; &#125; &#125; &#125; //写方法 void write(byte[] bytes) &#123; try &#123; mmOutStream.write(bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //关闭流连接 void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; EventBus 直接放链接了 http://www.jianshu.com/p/a040955194fchttp://www.jianshu.com/p/acfe78296bb5http://www.ff50.net/view/40565212977623506063.html 正文 蓝牙连接子线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 private class ConnectThread extends Thread &#123; private final BluetoothSocket mmSocket; //解析函数 ConnectThread(BluetoothDevice bluetoothDevice) &#123; // 使用一个中间变量 tmp // mmSocket 类型是 final BluetoothSocket tmp = null; // 获取 BluetoothSocket try &#123; // MY_UUID is the app's UUID string, also used by the server code tmp = bluetoothDevice.createRfcommSocketToServiceRecord(UUID.fromString(MyApplication.MY_UUID)); &#125; catch (IOException ignored) &#123; &#125; //赋值给 mmSocket mmSocket = tmp; &#125; public void run() &#123; // 关闭蓝牙扫描 MyApplication.getBluetoothAdapter().cancelDiscovery(); try &#123; // 通过 socket 连接到设备. connect() 会一直执行直到成功连接或者抛出异常 mmSocket.connect(); &#125; catch (IOException connectException) &#123; //无法连接到蓝牙,关闭连接并退出 try &#123; mmSocket.close(); &#125; //没有正常关闭 catch (IOException ignored) &#123; &#125; return; &#125; // Do work to manage the connection (in a separate thread) mConnectedThread = new ConnectedThread(mmSocket); mConnectedThread.start(); &#125; /** * 关闭蓝牙连接 */ void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException ignored) &#123; &#125; &#125;&#125; 管理连接子线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 //管理连接子线程private class ConnectedThread extends Thread &#123; //BluetoothSocket private final BluetoothSocket mmSocket; //输入流 private final InputStream mmInStream; //输出流 private final OutputStream mmOutStream; ConnectedThread(BluetoothSocket socket) &#123; //传入BluetoothSocket，实例化mmSocket mmSocket = socket; //输入/输出流 中间变量 InputStream tmpIn = null; OutputStream tmpOut = null; // 输入输出流实例化 try &#123; tmpIn = socket.getInputStream(); tmpOut = socket.getOutputStream(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; mmInStream = tmpIn; mmOutStream = tmpOut; &#125; public void run() &#123; byte[] buffer = new byte[1024]; int bytes; // 连接成功时 while (true) &#123; try &#123; // 在InputStream读数据 bytes = mmInStream.read(); //发送数据 Events.bluetooth_Recycle bluetooth_recycle = new Events.bluetooth_Recycle(); bluetooth_recycle.s = bytes; bluetooth_recycle.bytes = String.valueOf((char) bytes); EventBus.getDefault().post(bluetooth_recycle); &#125; catch (IOException e) &#123; break; &#125; &#125; &#125; //写方法 void write(byte[] bytes) &#123; try &#123; mmOutStream.write(bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //关闭流连接 void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException e) &#123; &#125; &#125;&#125; 连接蓝牙123456789//连接线程private ConnectThread mConnectThread;//管理连接进程private ConnectedThread mConnectedThread;//创建连接子线程mConnectThread = new ConnectThread(bluetoothDevice);//启动连接子线程mConnectThread.start(); 向蓝牙写入数据1234567 //发送数据String, 主线程 优先级4 非粘性事件@Subscribe(threadMode = ThreadMode.MAIN, priority = 4, sticky = false)public void onEvent(Events.bluetooth_Send bluetoothSend) &#123; String bytes = bluetoothSend.bytes; mConnectedThread.write(bytes.getBytes()); LogUtil.d(Tag, "onEvent:Send" + bluetoothSend.bytes);&#125; 接收数据处理123456 //数据转换 后台进程 优先级3 非粘性事件@Subscribe(threadMode = ThreadMode.BACKGROUND, priority = 3, sticky = false)public void onEvent(Events.bluetooth_Transformers bluetoothTransformers) &#123; int bytes = bluetoothTransformers.bytes; //处理数据&#125;]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
        <tag>毕设</tag>
        <tag>BlueTooth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网教程（三）——VPS安全加固]]></title>
    <url>%2F2017%2F04%2F08%2FVPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B3%2F</url>
    <content type="text"><![CDATA[1234更新2017.04.08 VPS日常一些安全措施2017.08.22 更新安全措施，读者反馈，没有debian的，这里加上。2017.10.30 纠正错误,排版. 导语科学上网教程系列，很久没有更新新内容了。更新常用安全措施，至少保证，不会被轻易的当作肉鸡。都是一些常用的安全措施。 系统环境：CentOS/debian 7 SSH 有两种方案 彻底关闭SSH登陆，改为密钥登陆，安全性最高，但配置较为复杂 修改SSH登陆端口，同时开放默认端口，将爆破 ssh 密码的 IP 封停密钥登陆 主要步骤在这里,有时间再更新 https://ttt.tt/104/ 修改端口 CentOS 命令 如下，以下是将 SSH 端口改为 999 端口 1sed -i &apos;s/#Port 22/Port 999/g&apos; /etc/ssh/sshd_config debian需要打开/etc/ssh/sshdconfig 文件，修改其中的port后面的数字, 1nano /etc/ssh/sshd_config 修改其中的port后面的数字，为你要ssh登陆的端口，cltrl + x保存，回车退出。 fail2ban fail2ban 是 Linux 上的一个著名的入侵保护的开源框架，它会监控多个系统的日志文件，并根据检测到的任何可疑的行为自动触发不同的防御动作。将尝试爆破 ssh 密码的 IP 封停，默认10分钟。 详细配置安装方法在如下网址，这里使用默认配置即可。 https://linux.cn/article-5067-1.html 安装 fail2banCentOS 需要提前 设置 EPEL 仓库 以 root 用户登陆，非 root 用户需要 命令前 增加 sudo 安装命令 1234//CentOSyum install fail2ban//Debian / ubuntuapt-get install fail2ban 其他命令 重启 1service fail2ban restart 验证状态 1fail2ban-client ping 返回 1Server replied: pong 设置开机自启动（debian不用前面验证完成，已加入开机启动） 1234// CentOS/RHEL 6chkconfig fail2ban on// CentOS/RHEL 7systemctl enable fail2ban 禁用Linux多余端口 关闭多余端口是永远正确的选择！只留下常用端口 和 SSR端口 配置 iptables 警告 iptables 配置不是一般的复杂，谨慎操作 清空默认规则 1iptables -F 允许22端口，给暴力破解留点空间 //doge 12iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT 允许53端口 udp ，一般用做DNS服务器，如果你不需要则忽略此条 12iptables -A OUTPUT -p udp --dport 53 -j ACCEPTiptables -A INPUT -p udp --sport 53 -j ACCEPT 允许本机访问本机 12iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPTiptables -A OUTPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT 允许真正 SSH 端口 12iptables -A INPUT -p tcp -s 0/0 --dport 999 -j ACCEPTiptables -A OUTPUT -p tcp --sport 999 -m state --state ESTABLISHED -j ACCEPT 允许 80 443 端口，http 和 https 1234iptables -A INPUT -p tcp -s 0/0 --dport 80 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPTiptables -A INPUT -p tcp -s 0/0 --dport 443 -j ACCEPTiptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT 允许 SSR端口 以888 xxx 为例 你有几个端口，就添加几个 12345iptables -A INPUT -p tcp -s 0/0 --dport 888 -j ACCEPTiptables -A OUTPUT -p tcp --sport 888 -m state --state ESTABLISHED -j ACCEPTiptables -A INPUT -p tcp -s 0/0 --dport xxx -j ACCEPTiptables -A OUTPUT -p tcp --sport xxx -m state --state ESTABLISHED -j ACCEPT CentOS 保存配置 123iptables-save &gt; /etc/sysconfig/iptables``` 重载 iptables iptables -L 12 * debian 7 保存配置 iptables-save &gt; /etc/iptables-rulesip6tables-save &gt; /etc/ip6tables-rules 1随后修改/etc/network/interfaces文件，最后加入 pre-up iptables-restore &lt; /etc/iptables-rulespre-up ip6tables-restore &lt; /etc/ip6tables-rules 1234 重启执行`iptables -L`，看到配置已生效。## 安装 CSF 防火墙* 命令 rm -fv csf.tgzwget http://download.configserver.com/csf.tgztar -xzf csf.tgzcd csfsh install.sh//使用下边的命令来验证csf正确安装并已经运行perl /usr/local/csf/bin/csftest.pl 1234567891011## autoban 补丁（8.22）推荐* 来自ss原作者@clowwindy 的补丁，ban掉那些尝试破译ss密码的ip，在此对原作者表示敬意！* 原理是同一个ip出现3次以上尝试破译ss密码会被永久ban掉，ssr也可用* 测试只在debian 7上进行，需要python环境，但是通过秋水逸冰脚本安装ssr 已经安装好了python环境。* 以下内容参考 &gt;https://plus.google.com/104980438521301094845/posts/9zypCffhdZu---* 下载脚本 wget https://raw.githubusercontent.com/Jasper-1024/shadowsocksr/manyuser/utils/autoban.py 12 * ssr运行 python autoban.py &lt; /var/log/shadowsocksr.log 1234 查看哪些ip试图连接破解ssr密码。原版ss将log文件路径替换即可。 * 自动ban ip 编辑/etc/init.d/rc.local，加入 python /root/autoban.py &lt; /var/log/shadowsocksr.log nohup tail -F /var/log/shadowsocksr.log | python /root/autoban.py &gt;log 2&gt;log &amp;```保存退出即可。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—仿绿色守护嗜睡模式通知]]></title>
    <url>%2F2017%2F03%2F07%2FAndroid%E7%AC%94%E8%AE%B0%E2%80%94%E4%BB%BF%E7%BB%BF%E8%89%B2%E5%AE%88%E6%8A%A4%E5%97%9C%E7%9D%A1%E6%A8%A1%E5%BC%8F%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) Android Training Notifying the User Android API 通知 【Android】状态栏通知Notification、NotificationManager详解 编程环境 Android Studio 2.2.3 导语 OneTapDoze遇到的第一个难题，顺带记录Android 通知相关内容 最终效果 绿色守护进入doze模式后，会在通知栏创建一个计时通知 如下图 退出doze模式后，会指示进入doze和退出doze的时间段。 我们要仿照的样式就是这样，进入退出doze，对应创建通知的代码都在doze模式改变的Broadcast中。 基础部分创建通知 行文前：Android每次版本几乎都会有通知API的改动，不同版本之间通知兼容性很是问题，为此我们使用support_v7 库中的NotificationCompat.Builder代替Notification.Builder二者使用方式相同 涉及到的两个类 NotificationManager Notification (support库中对应NotificationCompat) NotificationManager 状态栏通知的管理类，负责发通知、清除通知等 NotificationManager 是一个系统Service，必须通过 getSystemService()方法来获取 Notification 具体的状态栏通知对象，可以设置icon、文字、提示声音、振动等参数 一个Builder对象至少包含三个方面 一个小图标，通过setSmallIcon()方法设置。 通知标题，通过setContentTitle()方法设置。 详细文本，通过setContentText()方法设置。 简单示例 创建通知构建器 代码 123456Notification notification = new NotificationCompat.Builder(this) .setContentTitle("这是通知标题") .setContentText("这是通知内容") //这里使用的是应用图标，一般没人这么干，就是为了方便 .setSmallIcon(R.mipmap.ic_launcher) .build(); 发布通知 获得NotificationManager的实例 使用notify()方法发布通知。在调用notify()方法 指定通知的ID，(ID用于通知更新) 加载Notification实例 1234int mNotificationId = 001;NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);manager.notify(mNotificationId, notification); 效果如下 android 7.0 / 6.0 /4.0 通过 更新通知 可以创建一个全新的NotificationCompat对象，也可以在原NotificationCompat对象基础上修改，最后只要 .notify 方法中对应同一个 mNotificationId ，系统就会自动更新已有通知，代码不在累赘。 基础部分到此，足矣 正题 实现时间段的显示，肯定会保存系统进入doze 退出doze对应的时间点。再计算出中间经历的时间。 提取系统时间 java.util.Date这里用到了java中的 时间类型 java.util.Datejava.util.Date 是java中常用时间类型，可以被SimpleDateFormat格式化format() 指定输出的时间格式比如我们需要 小时：分：秒SimpleDateFormat scanf = new SimpleDateFormat(&quot;HH:mm:ss&quot;);scanf.format(java.util.Date) 即可。 提前当前系统时间 12java.util.Date time_after = null;time_after = new java.util.Date(System.currentTimeMillis()); 计算时间差理论上是两个时间相减再格式化输出即可，可惜没成，原因还没找到。于是土办法： 调用 .getTime() 方法，将 java.util.Date 转化为毫秒计时(long) 取两者差值 转化为 时间长短 字符串返回， 代码如下123456789101112131415161718192021 size = (time_after.getTime() - time_befor.getTime()); string = scanf.format(time_befor) + "-" + scanf.format(time_after) + "="+ trform(size); String trform(long size) &#123; long day, hour, min, secone; day = size / (1000 * 60 * 60 * 24); //以天数为单位取整 hour = (size / (60 * 60 * 1000) - day * 24); //以小时为单位取整 min = ((size / (60 * 1000)) - day * 24 * 60 - hour * 60); //以分钟为单位取整 secone = (size / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60);if (day != 0) &#123; return day + "d" + hour + "h" + min + "m" + secone + "s"; &#125; else if (hour != 0) &#123; return hour + "h" + min + "m" + secone + "s"; &#125; else if (min != 0) &#123; return min + "m" + secone + "s"; &#125; else &#123; return secone + "s"; &#125; &#125; 通知扩展布局 在如下图片中，可以发现，通知在发出后，只默认显示最近一次的时间记录，其他时间记录可以在此条通知上下滑查看。明显与基础部分不同。 此处应用了 Builder.setStyle() 拓展布局，顾名思义，这是用于拓展通知显示范围 使用扩展布局 使用拓展布局 构建一个 inboxStyle 对象 .addLine方法 添加 String inboxStyle 行 使用 Builder.setStyle( inboxStyle )加载到通知 等待通知发布即可。 简单例程如下 123456//创建 inboxStyle NotificationCompat.InboxStyle inboxStyle = new NotificationCompat.InboxStyle(); //添加 String 行 ，前提是 我已经创建了一个 String inboxStyle.addLine(string); // 在notification 设置 inboxStyle 在一堆 build 里面 .setStyle(inboxStyle) 清除原有内容，发布新的 inboxStyle 只需要 inboxStyle = new NotificationCompat.InboxStyle(); Doze模式改变广播* 对应 ACTION_DEVICE_IDLE_MODE_CHANGED 坑：只能动态注册，静态注册无效，具体代码中powermanger.ACTION_DEVICE_IDLE_MODE_CHANGED 需要实例化 PowerManger ，而 PowerManger 又是与 Activity绑定，所以只有应用保持后台存活时才会进入广播。 例程如下12345678//实例化 PowerManagerPowerManager powermanger = (PowerManager) getApplicationContext().getSystemService(Context.POWER_SERVICE);//动态注册广播intentFilter = new IntentFilter();intentFilter.addAction(powermanger.ACTION_DEVICE_IDLE_MODE_CHANGED);//idlemodechage 是 BroadcastReceiver idlemodechage = new IdleModeChange();registerReceiver(idlemodechage, intentFilter);]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—ContentResolver]]></title>
    <url>%2F2017%2F01%2F19%2FAndroid%E7%AC%94%E8%AE%B0-ContentResolver%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) android6.0运行时权限详解 编程环境 Android Studio 2.2.3 导语 内容提供器是安全的应用间共享数据途径，在正式进入之前需要了解一下 Android 自6.0以来权限的变化 Android 权限详解 资料来源： android6.0运行时权限详解 Develop-API Guides-系统权限 第一行代码(第二版) Android权限介绍 Android 是一个权限分隔的操作系统每个应用系统标识（Linux 用户 ID 和组 ID）不同。系统各部分标识亦不相同。Linux 据此将不同的应用以及应用与系统分隔开来。更详细的安全功能通过“权限”提供，权限 会限制特定进程可以执行的具体操作，并且根据 URI 权限授权临时访问特定的数据段 权限声明最常见的权限声明在 AndroidManifest.xml 文件中一个或多个uses-permission 标记, 例如 声明短信权限 12345&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.android.app.myapp" &gt; &lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt; ... &lt;/manifest&gt; android 6.0 权限机制android 6.0之前 权限及在安装的时候，根据权限声明产生一个权限列表，用户只有在同意之后才能完成app的安装。android 6.0 以后 引入了 运行时权限 功能，应用所需权限不再一次性在安装时申请，而是在运行时需要用到那种权限向用户申请，同时用户也可以随时取消该授权 权限分类 Normal Permissions(普通权限)不涉及用户隐私，不需要用户进行授权的，例如 手机震动、访问网络等 Dangerous Permission(危险权限)涉及到用户隐私的，需要用户进行授权，例如 读取sdcard、访问通讯录等危险权限组如表1 应用运行时申请权限（适用于 Android6.0 及以上版本） 通过一个简单的实例来说明过程实例： 拨打电话 CALLPHONE 权限为例 权限声明1&lt;uses-permission android:name="android.permission.CALL_PHONE"/&gt; 拨打10010 代码如下 构建一个隐式intent 启动拨打电话123Intent intent = new Intent(Intent.ACTION_CALL);intent.setData(Uri.parse("tel:10010"));startActivity(intent); 在主界面上添加一个Button 在其onClick方法中拨打电话，运行程序! 在An’d’roid 6.0 以下版本中 电话都可以正常拨出。Android 6.0 以上版本中 则可能会应用崩溃/无反应，查看logcat的打印日志可以看到 “Permission Denial”权限被禁止的信息，接下来尝试使用 运行时申请权限 检查是否已获得授权int checkSelfPermission(Context context, String permission)方法 Context context contextString permission 权限具体名称打电话对应 Manifest.permission.CALLPHONE 方法返回 PERMISSION_GRANTED / PERMISSION_DENIED 例程12345678if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.CALL_PHONE) !=PackageManager.PERMISSION_GRANTED)&#123; ;&#125;else &#123; ;&#125; 申请权限void ActivityCompat.requestPermissions (Activity activity, String[] permissions, int requestCode)方法 Activity activity Activity实例String[] permissions 请求权限名int requestCode 请求码，大于0即可，对应在onRequestPermissionsResult 回掉方法中的requestCode 例程 12ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.CALL_PHONE&#125;,1 ); 授权后回掉无论用户是否授权都会进入回掉方法，需要重写该方法。void onRequestPermissionsResult (int requestCode, String[] permissions, int[] grantResults)方法 int requestCode 在 requestPermissions 中传入的请求码String[] permissions 请求的权限，不为空int[] grantResults 授权结果 只有 PERMISSION_GRANTED / PERMISSION_DENIED 两个值 例程 123456789101112131415@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; //请求码 1 case 1: //授权结果(int) 的 长度是否大于0 与上 授权结果是否等于 PackageManager.PERMISSION_GRANTED if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //授权通过执行 &#125; else &#123; //授权没有通过 &#125; break; default: &#125;&#125; 当用户拒绝后再次询问 boolean ActivityCompat.shouldShowRequestPermissionRationale(Activity activity, String permission) （真心太长了） Activity activity Activity实例String permission 权限名称应用第一次需要授权时,用户授权，该方法返回false。当用户拒绝授权,下次需要该权限时,该方法会返回true 例程1234567 if (ActivityCompat.shouldShowRequestPermissionRationale(PermissionActivity.this,Manifest.permission.READ_CONTACTS))&#123;//第二次询问用户是否授权&#125;else&#123;//用户依旧拒绝后操作&#125; 例程源码 123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void Button(View view)&#123; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CALL_PHONE&#125;,1 ); &#125;else &#123; call(); &#125; &#125; private void call() &#123; try &#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:10010")); startActivity(intent); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; call(); &#125; else &#123; Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show(); &#125; break; default: &#125; &#125; &#125; 12345&lt;Button android:onClick="Button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" /&gt;]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—数据保存]]></title>
    <url>%2F2017%2F01%2F14%2FAndroid%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) 编程环境 Android Studio 2.2.3 Android 中的主要数据存储 有三种 保存键值集 要保存的相对较小键值集合，使用 SharedPreferences 保存文件使用 Android 文件系统通过 File API 读取和写入文件，适合按开始到结束的顺序不跳过地读取或写入大量数据。 例如，图片文件或通过网络交换的任何内容 在 SQL 数据库中保存数据Android内建的SQLite 数据库存储重复或结构化数据 PS：这里如果没有学过 SQL 数据库使用，推荐LitePal Android开源数据库LitePal ：郭霖(第一行代码作者) 详细介绍在这里（懒人必备）Android开源数据库LitePal 保存键值集 想要保存的相对较小键值集合 调用SharedPreferences 首先：获取SharedPreferences的句柄用户可以创建一个共享参数文件或访问一个已经存在的共享参数文件。具体途径有三条 getSharedPreferences (String name, int mode) 第一个参数：SharedPreferences的名称，第二个：参数指定操作模式 需要创建/读取 多个共享参数文件时使用，每个文件都拥有一个标识符，可以通过这个标识符通过该方法的第一个参数获得共享参数对象。可以通过APP中的任意Context对象调用它。 示例12//指定SharedPreferences名称为data 模式为MODE_PRIVATE：只有当前程序才有权限读取/修改SharedPreferences sharedPref = getSharedPreferences("data", MODE_PRIVATE); getPreferences (int mode) 参数：指定操作模式 只创建 Activity 的一个SharedPreferences。在Activity 中使用。 方法会检索属于该 Activity 的默认共享首选项文件，无需提供名称 示例12//模式：MODE_PRIVATE：只有当前程序才有权限读取/修改SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE); getDefaultSharedPreferences(context) 参数：context 自动以档期应用程序包名作为前缀命名SharedPreferences文件 写入数据到共享参数中 SharedPreferences 调用 edit() 创建一个 SharedPreferences.Editor使用诸如 putInt() 和 putString() 方法写入的键和值最后调用commit() 以保存更改也可调用apply() 保存更改 commit() 与 apply() 相同/区别 相同 都是提交preference修改数据 区别 apply没有返回值 commit返回boolean表明修改是否提交成功 apply是将操作提交到内存，而后异步真正提交到文件 commit是同步的提交到文件 多个commit同时提交，互相等待，效率较低 apply直接覆盖，效率较高 apply没有任何错误提示，只是提交的动作 示例123456//创建 .edit()SharedPreferences.Editor editor = sharedPref.edit();//写入字符串。key-值 TextVieweditor.putString("TextView","hello");//保存更改editor.commit(); 从共享参数中读取数据 获取SharedPreferences的句柄方式同上 调用比如getInt()或getString()方法，然后传入键值，如果键不存在，则会返回一个默认值 示例123456//获取SharedPreferences的句柄SharedPreferences sharedPreferences = getSharedPreferences("data",MODE_PRIVATE);//读取键值对应数据String text = sharedPreferences.getString("TextView","");//打印到log中 验证Log.d("data",text); 保存到文件 Android 设备有两个文件存储区域： 内部存储 和 外部存储Android 设备早期内置的非易失性内存（内部存储），以及移动存储介质 微型 SD 卡等（外部存储）任何Android设备始终有两个存储空间，并且无论外部存储设备是否可移动，API 的行为均一致 Android的文件存储是以java流为基础，并优化了一些操作。java流不属于本文范围。 涉及java流部分参考Android文件IO详解 内部存储保存到内部存储 某一应用对其内部存储 始终具有 进行读写的权限，而无需声明任何权限，在 Android N之前，内部文件可以通过放宽权限让其他应用访问。但是极不推荐以这种方式共享文件 简单实例 123456789101112131415161718192021222324252627public void save(String inputText)&#123; //新建一个FileOutputStream对象(字节流) FileOutputStream out = null; //新建一个BufferedWriter (字符流) BufferedWriter writer = null; try&#123; //out 实例化 out = openFileOutput("data",Context.MODE_PRIVATE); //OutputStreamWrit 字节流转换为字符流 //字符流绑定BufferedWriter(缓冲区) writer = new BufferedWriter(new OutputStreamWriter(out)); //写入到文件 writer.write(inputText); &#125;catch (IOException e )&#123; e.printStackTrace(); &#125; finally &#123; try&#123; //如果写入成功 if (writer != null) &#123; //关闭流 writer.close(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; FileOutputStream： 继承自 OutputStream 用于文件处理的节点流 用于写入原始字节流到文件 FileOutputStream openFileOutput (String name, int mode) 返回FileOutputStream对象 第一个参数是文件名 第二个参数是操作模式，有4种取值 MODEPRIVATE(默认)当同一文件名存在时覆盖原文件 MODEAPPEND 当同名文件存在时，在原文件末尾追加 其余两种均在android4.2及以上版本中废弃 OutputStreamWrit 继承自 Writer 将字节流转换为字符流 BufferedWriter 继承自Writer 绑定字符输出流，提高具体的流对象的效率 .flush()方法 对缓冲区进行刷新，让数据到目的地 .close();方法 关闭缓冲区，即关闭绑定的流 从内部存储读取文件 简单实例 123456789101112131415161718192021222324252627282930313233343536public String load()&#123; //新建FileInputStream对象 FileInputStream in = null; //新建 BufferedReader对象 BufferedReader reader = null; //新建一个StringBuilder 空 content = new StringBuilder(); try&#123; //FileInputStream对象实例化 in = openFileInput("data"); //字节流转换为字符流 //缓冲流绑定字符流 reader = new BufferedReader(new InputStreamReader(in)); //空 String String line = ""; //读取文件内容，并判断是否读取完成 while((line = reader.readLine())!=null)&#123; //读取内容添加到 StringBuilder 对象中 content.append(line); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; if(reader != null)&#123; try&#123; //关闭流 reader.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; //将读取结果 由StringBuilder转换为String 并返回 return content.toString(); &#125; FileInputStream 继承自 InputStream，用于文件处理的节点流 从文件中读取 FileInputStream openFileInput(String filename) 返回FileInputStream对象 参数为 读取的文件名 InputStreamRead 将字节流转换为字符流 BufferedReader 缓冲流 外部存储 占坑]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016总结]]></title>
    <url>%2F2016%2F12%2F31%2F2016%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2016 找到了兴趣-Android开始正式学习。 搭建了自己的blog，虽然周围人没人关注，有一篇日子的阅读量过了1万，还是很惊喜的 嵌入式工作没用找到满意的，只能说等春招 Andoid的实习，这段时间努力提高自己， 放弃了考研 心情走过了类似抑郁的经历，对体制种种各有看法，是对是错，让时间见证 2017 希望有自己的收入，经济相对自由一点 谈一段恋爱，遇到合适的女孩吧 Android的路上，顺利一点吧 不给自己设定限制，走一步再走一步]]></content>
      <categories>
        <category>随</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Studio优化编译速度]]></title>
    <url>%2F2016%2F12%2F25%2FAndroid%20Studio%E4%BC%98%E5%8C%96%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[资料来源如下 http://www.jianshu.com/p/1c878c10a6bb http://www.jianshu.com/p/9b8ef61b7cdb http://www.jianshu.com/p/64d9a52aebbf 编程环境 Android Studio 2.2.3 导语 ssd盘容量不够了，重装系统，随便重新安装了Android Studio 记录一边优化过程 最重要的 有一个良好的梯子+全局翻墙 大部分Android Studio安装的问题,就基本不会出现 开启gradle单独的守护进程 在C:\Users.gradle目录(user目录即当前用户不同电脑一般不同)下新建 gradle.properties文件复制下面的代码 12345org.gradle.daemon=true org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=800m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8org.gradle.parallel=true org.gradle.configureondemand=true 应该是增大了gradle 运行的 java 虚拟机的大小，我的电脑是8g内存，这个配置效果最好 扩大Android Studio 运行内存 找到Android Studio安装目录下的bin文件夹找到studio64.exe.vmoptions和studio.exe.vmoptions文件(64位)studio.exe.vmoptions和studio.exe.vmoptions文件(32位) 分别编辑文件,改动3个地方如下 123-Xms1024m-Xmx2048m-XX:MaxPermSize=800m Android Studio 设置 Command-line Option不填 gradle 离线模式勾选Office Work，我这里测试是速度基本不变，但是网上有人测试是效果相差很多，原因不明，可能是网络一直全局翻墙的关系]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—Broadcast广播]]></title>
    <url>%2F2016%2F12%2F23%2FAndroid%E7%AC%94%E8%AE%B0-Broadcast%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) 编程环境 Android Studio 2.2.3 BroadcastReceiver基础 首先祭出官方文档及中文翻译 https://developer.android.com/reference/android/content/BroadcastReceiver.htmlhttp://www.jianshu.com/p/1b56172b0c77 BroadcastReceiver概述 @别路寻忆Android中的四大组件是 Activity、Service、Broadcast和Content Provider。而Intent是一个对动作和行为的抽象描述，负责组件之间程序之间进行消息传递。那么Broadcast Receiver组件就提供了一种把Intent作为一个消息广播出去，由所有对其感兴趣的程序对其作出反应的机制。 @zuolongsnail专栏 广播接收器是一个专注于接收广播通知信息，并做出对应处理的组件。很多广播是源自于系统代码的──比如，通知时区改变、电池电量低、拍摄了一张照片或者用户改变了语言选项。应用程序也可以进行广播──比如说，通知其它应用程序一些数据下载完成并处于可用状态。 应用程序可以拥有任意数量的广播接收器以对所有它感兴趣的通知信息予以响应。所有的接收器均继承自BroadcastReceiver基类。 广播接收器没有用户界面。然而，它们可以启动一个activity来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。 广播分类 触发广播发生的事件分类有两种 Android系统广播事件 由android设备状态变化而触发的系统广播如： Intent.ACTION_POWER_CONNECTED; //插上外部电源时发出的广播 Intent.ACTION_SCREEN_ON; //屏幕被打开之后的广播 ACTION_TIME_CHANGED//系统时间改变而触发的广播 自定义的广播事件 这个比较好理解了，比如qq当我们再另外一台手机上登陆时，手头的这个手机qq就会自动下线。腾讯的服务器通过后台服务启用了自定义广播来终结正在运行的Activity，详情之后会有例程，不再累赘。 能够被接收的广播类型 普通广播（Normal broadcasts）： （由 Context.sendBroadcast发出）异步发出。所有广播接收器都可以在同一时间接收广播。广播接收者无法接收广播的处理结果或者阻断广播的传递。 有序广播（Ordered broadcasts）： （由 Context.sendOrderedBroadcast发出）每次只发送给一个广播接收器。当每个广播接收器依次执行时，它可以向下一个广播接收器传播结果，或者阻断该广播，使得该广播不能被下一个广播接收器接收到。 通俗解释： 普通广播就相当于小区/村委会的大喇叭，有事发生（触发广播）通知所有的人（广播接收器），全功率的大喊大叫确保所有人（广播接收器）都能听到。而有人（广播接收器）在睡觉被吵醒但是又没办法砸了那个大喇叭，只能继续听着（无法接收广播的处理结果或者阻断广播的传递）。 有序广播 就相当于间谍机关的绝密消息传递。绝密到手（触发广播）间谍秘密汇总给上线A（广播接收器A）。本来 上线（广播接收器A）应该 听取完毕重新整理情向首长B（广播接收器B）报告（向广播接收器B传播 广播接收器A修改的结果）,但是A被收买，将情报隐匿了，没有向首长B汇报（广播接收器A阻断该广播，使得该广播不能被下一个广播接收器B接收到）。（PS结局首长B错误带人炸了村委会，该睡觉的人终于可以安生睡觉了！） 广播事件注册有两种 静态注册，就是在AndroidManifest.xml文件中定义，注册的广播接收器必须要继承BroadcastReceiver. 动态注册，是在程序中使用Context.registerReceiver注册，注册的广播接收器相当于一个匿名类。两种方式都需要IntentFIlter。 例程见下节。 动态注册（在代码中注册） 在代码中通过registerReceiver()注册。app关闭后,该接收器也会随之销毁。 首先定义一个内部子类NetworkChangeReceiver继承自 BroadcastReceiver 12345678class NetworkChangeReceiver extends BroadcastReceiver &#123;@Override//重写onReceive，接收到广播后提示消息 public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "network is available网络已变化", Toast.LENGTH_SHORT).show(); &#125; &#125; 在onCreate()方法中创建IntentFilter实例和NetworkChangeReceiver实例。并在IntentFilter实例中添加网络变化时系统广播对应值。随后传入registerReceiver()中注册。 123456789101112 protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //创建IntentFilter实例 intentFilter = new IntentFilter(); //添加对应系统广播 intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); //添加NetworkChangeReceiver实例 networkChangeReceiver = new NetworkChangeReceiver(); //动态注册 registerReceiver(networkChangeReceiver, intentFilter);&#125; 动态注册的广播接收器最后要取消注册。在onDestroy()方法中调用unregisterReceiver()销毁动态注册的广播接收器。 1234 protected void onDestroy()&#123; super.onDestroy(); unregisterReceiver(networkChangeReceiver);&#125; 最后要在AndroidMainfest.xml中声明查询系统网络状态的权限。 1&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; 运行效果如如所示（模拟器） 静态注册（xml中注册） 直接在Manifest.xml文件中配置广播接收者 例程为了方便同样以android.net.conn.CONNECTIVITY_CHANGE为例，与动态注册相同。不使用内部子类（第一行代码） 新建名称为BootCompleteReceiver的java class 代码如下 123456 public class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent)&#123; Toast.makeText(context, "网络改变", Toast.LENGTH_SHORT).show(); &#125;&#125; 在AndroidManifest.xml文件中注册广播接收器 代码如下 12345&lt;receiver android:name=".BootCompleteReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.net.conn.CONNECTIVITY_CHANGE"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 在AndroidManifest.xml中声明权限 12&lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"&gt;&lt;/uses-permission&gt; 使用内部子类（在Activity中定义） 在这晕圈了一下午，找不出毛病。看书多仔细吧，书上说了不用内部子类。详细资料在这里 http://blog.csdn.net/chdjj/article/details/19496567 清单文件注册广播接收者时，广播接收者的名字格式需要注意因为是内部类，所以需要在内部类所在的类与内部类之间加上$符号(这一点在AndroidStudio中输入时有提示) 内部类在声明时一定要写成静态内部类（class关键字前加上static）。否则会抛出异常（广播发生时，应用停止运行） 在MainActivity中新建子类 123456 public static class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent)&#123; Toast.makeText(context, "Boot complete", Toast.LENGTH_SHORT).show(); &#125;&#125; 在AndroidManifest.xml中注册广播接收器 12345&lt;receiver android:name=".MainActivity$BootCompleteReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.net.conn.CONNECTIVITY_CHANGE"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 在AndroidManifest.xml中声明权限 12&lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"&gt;&lt;/uses-permission&gt; 运行效果同动态注册 使用广播接收器注意事项 在onReceive()方法中不宜添加过多逻辑/耗时操作，广播接收器没有多线程，一旦时间过长，程序就会报错。 广播接收器一般为启动其他组件作用。 发送标准广播 发送标准广播之前，首先要注册一个作为目标的广播接收器。（过程略，只上代码） 新建MyBroadcastReceiver.class 1234567 public class MyBroadcastReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context,"MyBroadcastReceiver",Toast.LENGTH_SHORT).show(); &#125;&#125; 在Xml中注册（静态） 12345&lt;receiver android:name=".MyBroadcastReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.broadcasttest.MyBroad"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; xml中注册一个Button 12345&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="SendBroad" android:text="SendBroad" /&gt; MainActivity中新建 SendBroad()函数 首先构建一个 Intent对象，将自定义的广播值填入。再调用sendBroadcast方法将广播发送出去。 12345 public void SendBroad(View view)&#123; Intent intent = new Intent("com.example.broadcasttest.MyBroad"); sendBroadcast(intent);&#125; 发送的是标准广播。运行效果如下图。 发送有序广播 首先新建一个Broad2 的工程。同样接收Broad发送的广播。 代码如下 1234567 public class AnotherBroadcast extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context," AnotherBroadcast",Toast.LENGTH_SHORT).show(); &#125;&#125; 12345&lt;receiver android:name=".AnotherBroadcast"&gt; &lt;intent-filter android:priority="10"&gt; &lt;action android:name="com.example.broadcasttest.MyBroad"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 测试效果：当摁下发送广播按钮后，弹出两个提示。 修改Broad项目中onClick对应事件。将sendBroadcast(）改为sendOrderedBroadcast();发送有序广播。 12345 public void SendBroad(View view)&#123; Intent intent = new Intent("com.example.broadcasttest.MyBroad"); sendOrderedBroadcast(intent,null);&#125; 效果与发送标准广播相同（还未定义优先级/截断等） 定义优先级，再Broad的AndroidMainfest.xml中修改注册的广播添加android:priority=”100”优先级100 12345&lt;receiver android:name=".MyBroadcastReceiver"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="com.example.broadcasttest.MyBroad"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 在Broad2的AndroidMainfest.xml中添加android:priority=”10”优先级10 12345&lt;receiver android:name=".AnotherBroadcast"&gt; &lt;intent-filter android:priority="10"&gt; &lt;action android:name="com.example.broadcasttest.MyBroad"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 发送广播后MyBroadcastReceiver最先收到广播。 截断广播。有序广播中前一个广播接收器可以截断广播传播。添加 abortBroadcast();即可。 12345678 public class MyBroadcastReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context,"MyBroadcastReceiver",Toast.LENGTH_SHORT).show(); abortBroadcast(); &#125;&#125; 再次点击按钮发送广播，只有MyBroadcastReceiver可以接收到发送的广播。 本地广播 只在app应用内部传递的广播。注册过程类似于动态注册。 定义一个内部类LocalReceiver继承自BroadcastReceiver 123456 public static class LocalReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent)&#123; Toast.makeText(context, "received local broadcast", Toast.LENGTH_SHORT).show(); &#125;&#125; 首先在onCreate()方法中通过localBroadcastManager.getInstan得到一个LocalBroadcastManager的实例，再创建IntentFilter实例和LocalReceiver实例。并在IntentFilter实例中添加广播。随后传入localBroadcastManager.registerReceiver()中注册本地广播。 123456789101112131415161718private IntentFilter intentFilter;private LocalReceiver localReceiver;private LocalBroadcastManager localBroadcastManager;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); localBroadcastManager = localBroadcastManager.getInstance(this); intentFilter = new IntentFilter(); intentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST"); localReceiver = new LocalReceiver(); localBroadcastManager.registerReceiver(localReceiver, intentFilter); &#125; 在Activity的onDestroy()中销毁注册。 12345@Overrideprotected void onDestroy()&#123; super.onDestroy(); localBroadcastManager.unregisterReceiver(localReceiver);&#125; 在Button对应的函数中调用localBroadcastManager.sendBroadcast发送本地广播。 12345 public void SendBroad(View view)&#123; Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST"); localBroadcastManager.sendBroadcast(intent);&#125; 效果基本同上，不加累赘。不过在Broad2中是怎样都搜不到广播了。 本地广播特点 明确广播只在应用内部，传递数据无需担心泄密。 其他程序广播无法发送至程序内部。 本地广播比全局广播更为高效。]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—Fragments]]></title>
    <url>%2F2016%2F12%2F18%2FAndroid%E7%AC%94%E8%AE%B0-Fragments%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) Android官方文档之App Components（Fragments） 编程环境 Android Studio 2.2.3 导语 Fragments的艺术之旅 Fragments简介 Fragment—片段 是Android 在 Android 3.0（API 11 级）中引入了，主要是为了给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持。 可以将多个片段组合在一个 Activity 中来构建多窗格 UI，以及在多个 Activity 中重复使用某个片段。可以将片段视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，可以在 Activity 运行时添加或删除片段（类似于不同 Activity 中重复使用的“子 Activity”） Google官方文档(中文) 创建Fragments fragment创建过程与Activity类似。 创建Fragment，需要继承一个Fragment类，并实现Fragment的生命周期回调方法，如onCreate(), onStart(), onPause(), onStop()等 一般来说，在Fragment中应至少重写以下这些生命周期方法必须重写的时onCreateView()方法. onCreate()：创建Fragment实例时，系统回调的方法。在该方法中，对一些必要的组件进行初始化 onCreateView()：Fragment上绘制UI时，回掉该方法。返回一个View对象，表示Fragment的根视图；若Fragment不需要绑定示图，可以返回null onPause()：当用户离开Fragment时回调。在该方法中，对Fragment的数据信息做持久化的保存工作 创建一个Fragment类 新建first_fragme 继承自Fragment Android Studio中 对应Fragment 包有两个，选择support-v4 _(这个版本可以再Android版本中保持Fragment特性一致) Fragment并非一定要绑定一个布局文件，下面会提到。 1234567public class FirstFragment extends Fragment &#123; @Override public View onCreateView (LayoutInflater inflater, ViewGroup container, Bundle saveInstanceState)&#123; View view = inflater.inflate(R.layout.fragment_firest,container,false); return view; &#125;&#125; 与此对应的fragmentfirest布局文件 LinearLayout加一个Button，背景颜色设置为了靛蓝色。 onCreateView()方法 ViewGroup来自宿主Activity容器布局，Fragment的布局将其作为根视图插入至该视图中。 Bundle用于回传之前占据该位置的Fragment实例所保存的Bundle信息，当该Fragment的新实例处于resume状态时，该参数被回传 inflate() 方法 参数1（int）：需要绑定的Layout的资源ID； 参数2（ViewGroup）：绑定的Layout布局的父视图； 参数3（boolean）：是否需要将参数1的Layout资源依附于，参数2的ViewGroup上，false，表示不依附。（系统已经默认将Layout插入至ViewGroup中，若为true，将添加一层冗余的视图 在XML将fragment添加到activity 在activity_main.xml中添加如下代码。跟添加一个layout没有太大区别。 123456&lt;fragment android:id="@+id/left_fragment" android:name="ljy.com.fragmenttest.fragment_firest" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"/&gt; 至此一个fragment添加完毕。为了对比，再新建一个second_fragment，背景颜色不同，两者同时添加进activity_main中。 一般来说必须为fragment设定唯一的身份标识，以便当宿主Activity为restart状态时可以恢复fragment android:id属性为fragment指定唯一ID android:tag属性为fragment指定唯一字符串标识 未指定，则该fragment的标识为其父容器控件的ID 动态添加碎片 处理片段时，请谨记：Activity 布局必须包含一个可以插入片段的容器 View 添加或移除片段必须使用 FragmentManager 创建 FragmentTransaction， FragmentTransaction将提供添加、移除、替换片段以及执行其他片段事务所需的 API。Activity 内调用 getSupportFragmentManager() 以获取 FragmentManager 12rightfragment right = new rightfragment();FragmentManager fragmentManager = getSupportFragmentManager(); 调用 beginTransaction() 创建一个 FragmentTransaction事务，并调用 add() 添加一个片段，做好更改准备时，调用 commit() 123FragmentTransaction transaction = fragmentManager.beginTransaction();transaction.replace(R.id.right_layout,right);transaction.commit(); 示例： 首先改造一下activitymain.xmlFrameLayout包含一个left_fragment 12345678910111213 &lt;FrameLayout android:id="@+id/right_layout" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"&gt; &lt;fragment android:id="@+id/left_fragment" android:name="com.example.fragment_text.leftfragment" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/FrameLayout&gt; 在MainActivity的onCreate方法中添加fragment 12345678910111213//新建准备替换的Fragment实例rightfragment right = new rightfragment();//新建FragmentManagerFragmentManager fragmentManager = getSupportFragmentManager();// 调用beginTransaction() 创建FragmentTransactionFragmentTransaction transaction = fragmentManager.beginTransaction();//FragmentTransaction内处理添加/替换等。transaction.replace(R.id.right_layout,right);//最后执行commit()方法transaction.commit(); 管理Fragments/执行Fragment事务 Activity中管理Fragment，使用FragmentManager( 1FragmentManager fragmentManager = getFragmentManager(); 可以实现的操作 findFragmentById()方法获取由Activity管辖的绑定了UI的Fragment实例 popBackStack()方法将Fragment从后退栈中弹出 addOnBackStackChangedListener()方法注册监听器，用于监听后退栈的变化 Fragment可实现动态添加、删除、替换 等 操作，每一组向Activity提交的变化称为事务，使用FragmentTransaction这操作事务,调用beginTransaction(）开启一个事务 12FragmentManager fragmentManager = getFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); 可实现对Feagment的操作 add() //添加 remove() //移除 replace() //替换 事务要在Activity中生效，调用commit()方法提交 commit()方法之前，调用addToBackStack()方法，可以将该事物添加到由Activity管辖的Fragment返回栈中。点击Back键即撤销该事物提交的更改 使用FragmentTransaction操作事务时注意 commit()必须在最后调用 一个布局容器中添加多个Fragment，加入的顺序决定了这些Fragment绑定的UI视图在View树中的层级顺序 commit()方法提交后，并不会立即执行事务，UI更新只能在主线程中进行，主线程空闲时，才会执行事务操作Android也提供了 在UI线程中调用executePendingTransactions()方法，使commit()方法调用后立即执行提交的事务（一般用不到） 与 Activity 通信 Fragment 中获取 Activity 实例 getActivity()方法可以获取到 Activity 实例 1MainActivity activity = (MainActivity) getActivity(); 调用Activity中的试图也很简单，使用findViewById()即可，getActivity()方法返回的既是一个Context对象 1View listView = getActivity().findViewById(R.id.list); 在Fragment中使用Context对象，getActivity()方法，只能是在fragment已经依附于Activity后才能调用。当fragment未依附于某个Activity、或fragment已经处于其生命周期的末尾而不再依附于某个Activity时，调用getActivity()方法会直接返回null Activity 中获取 Fragment 实例()FragmentManger提供了findFragmentById()方法 1RightFragment fragment = (RightFragment) getFragmentManager().findFragmentById(R.id.example_fragment); 如果使用的使support-V4包，则 getFragmentManager()改为getSupportFragmentManager()，代码如下： 1RightFragment fragment = (RightFragment)getSupportFragmentManager().findFragmentById(R.id.example_fragment); Fragment与Frangment之间也可以通过宿主Activity，获取到另一个Fragment实例，调用另一个Fragment中的方法 为Activity创建事件回调 占坑， Frangment的生命周期 与Activity极为相似，且 Frangment的生命周期与宿主Activity有很大关联 有3种状态 Resumed继续：宿主Activity处于running，Fragment处于可见状态 Paused暂停：另一个Activity处于前台并获得了焦点，该Fragment的宿主Activity并未被全部遮挡 Stopped停止：Fragment不可见或Fragment已被Activity移除，宿主Activity被回收时，Fragment也将被回收 宿主Activity的影响 重要回调方法 onAttach()：fragment关联Activity时回调 onCreateView()：fragment绑定UI视图(加载布局)时回调 onActivityCreated()：宿主Activity创建完毕 (宿主Activity的onCreate()方法返回) 后调用 onDestroyView()：与fragment绑定的UI视图被移除时回调 onDetach()：fragment不再依附于Activity时回调 Activity 与Fragment在生命周期之间的最显著差异在于它们在其各自返回栈中的存储方式。默认情况下，Activity 停止时会被放入由系统管理的 Activity 返回栈（以便用户通过返回按钮回退到 Activity），Frament仅当您在移除片段的事务执行期间通过调用 addToBackStack() 请求保存实例时，系统才会将Fragment放入由宿主 Activity 管理的返回栈。 一旦Activity处于resume状态时，可以自由地添加或移除fragment，也就是说，只有当Activity的状态为resume时，fragment才能够自由地控制自己的生命周期]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—UI-RecyclerView]]></title>
    <url>%2F2016%2F12%2F16%2FAndroid%E7%AC%94%E8%AE%B0-UI-RecyclerView%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) RecyclerView使用详解—六和敬 RecyclerView使用介绍— Jin Yudong Android RecyclerView 使用完全解析 体验艺术般的控件—鸿洋_ 创建列表与卡片—Android Developer 编程环境 Android Studio 2.2.3 导语 RecyclerView内容较ListView更多，初期只能更新一些基础内容，高级的用法随时更新，长期跟进 简介 RecyclerView是用于取代ListView的组件,第一次出现是在2014年google I/O大会，内置在是Android L及以上版本的SDK中。 对比与ListView，RecyclerView弥补了ListView中的效率问题，同时支持更多的显示效果，代码逻辑更为清晰 基本使用步骤 RecyclerView定义在support库中，使用RecyclerView之前必须在添加依赖 build.gradle中添加 compile &#39;com.android.support:recyclerview-v7:25.1.0&#39; RecyclerView项目结构如下： 要使用RecyclerView，需要指定一个Adapter适配器和一个LayoutManager布局管理器 Adapter适配器：作用与ListView中使用的Adapter相同，都是将数据与对应item的界面进行绑定所不同的是：RecyclerView中适配器必须继承自RecyclerView.Adapter，且 强制使用了ViewHolder LayoutManager布局管理器：每一个item如何进行排列，何时展示和隐藏。重用View时，LayoutManager会向Adapter适配器请求新的数据替换旧的数据，避免了View的冗余和频繁调用findViewById LayoutManager的引入 使得各种布局排列编写，变的格外容易，这也是RecyclerView优于ListView的一个地方 目前RecyclerView 内置3种LayoutManager： LinearLayoutManager 横向/竖向布局 GridLayoutManager 网格布局 StaggeredGridLayoutManager 瀑布流布局 MainActivity中 RecyclerView 设置 创建RecyclerView对象RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycle_view); 设置LayoutManager显示规则 设置适配器recyclerview.setAdapter(adapter); 简单实例由一个简单的实例+详细分析 添加依赖打开app/build.gradle文件，在dependencies闭包下添加依赖库版本与你工程的com.android.support:appcompat-v7:25.1.0版本对应 1compile 'com.android.support:recyclerview-v7:25.1.0' 之后AndroidStudio会开始同步 添加RecyclerView到xml文件,基本与ListView一致，不过RecyclerView并非内置在SDK中，这里需要写出完整的包路径 12345&lt;android.support.v7.widget.RecyclerView android:id="@+id/recycle_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; 要展示的依旧是水果+图片形式，图片资源在第一行代码第二版源码 /chapter3/ListViewTest\app\src\main\res\drawable-hdpi下，同时将Fruit类和fruititem.xml一并复制，这里给出两者源码，不再加分析 Fruit类 1234567891011121314151617public class Fruit &#123;private String name;private int imageId;public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125;public String getName() &#123; return name; &#125;public int getImageId() &#123; return imageId; &#125;&#125; fruititem.xml 123456789101112131415161718&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"android:orientation="horizontal"android:layout_width="match_parent"android:layout_height="match_parent"&gt;&lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="10dp" /&gt;&lt;/LinearLayout&gt; 准备RecyclerView适配器，适配器需要继承自 RecyclerView.Adapter，将泛型指定为 .ViewHolder，(ViewHolder为在适配器的一个内部类)，并重写3个方法 123public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)//创建返回ViewHolder实例public void onBindViewHolder(ViewHolder holder,int pisition)//数据与界面绑定public int getItemCount() // 返回数据的数量 新建 FruitAdapter 继承自 RecyclerView.Adapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 //继承自RecyclerView.Adapter，泛型为 FruitAdapter .ViewHolder public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; //私有Fruit列表 private List&lt;Fruit&gt; mFruitList;//新建内部类ViewHolder继承自RecyclerView.ViewHolde有每个Item的的所有界面元素 static class ViewHolder extends RecyclerView.ViewHolder&#123; ImageView fruitImage; TextView fruitName; //ViewHolder构造函数，传入View，通常为RecyclerView子项的外层布局(本例为fruit_item.xml) public ViewHolder(View view)&#123; super(view); //findViewById获取 Image/Name实例 fruitImage = (ImageView)view.findViewById(R.id.fruit_image); fruitName = (TextView)view.findViewById(R.id.fruit_name); &#125; &#125;//FruitAdapter构造函数，将数据源传入全局变量mFruitList public FruitAdapter(List&lt;Fruit&gt;fruitList)&#123; mFruitList = fruitList; &#125; @Override //创建ViewHolder实例 public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)&#123; //加载布局文件 View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false); //调用ViewHolder构造函数 ViewHolder holder = new ViewHolder(view); //返回ViewHolder实例 return holder; &#125; @Override //对 RecyclerView子项进行赋值，有新的子项进入屏幕显示范围时调用 public void onBindViewHolder(ViewHolder holder,int pisition)&#123; Fruit fruit = mFruitList.get(pisition); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); &#125; @Override //返回 RecyclerView子项数量 public int getItemCount()&#123; return mFruitList.size(); &#125; &#125; MainActivity中使用RecyclerView 创建RecyclerView对象 设置LayoutManager显示规则（默认竖向滚动） 设置适配器 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 public class MainActivity extends AppCompatActivity &#123;//私有列表 private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化Fruits数据 initFruits(); //获取RecyclerView实例 RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycle_view); //创建LinearLayoutManager，并设置入recyclerView LinearLayoutManager layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); //新建适配器，并传入 FruitAdapter adapter = new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); &#125; //初始化Fruits类 private void initFruits() &#123; //循环两遍 怕占不满屏幕 for (int i = 0; i &lt; 2; i++) &#123; Fruit apple = new Fruit("Apple", R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango_pic); fruitList.add(mango); &#125; &#125; &#125; 这样最简单的 RecyclerView 就搭建完了效果如下 代码比ListView稍多，但是逻辑比较清晰。 横向/瀑布流/网格布局 只需要设置相应LayoutManager即可 /手动滑稽 横向 在 LinearLayoutManager 中修改几行代码即可 修改 LinearLayoutManager 代码，添加一行，搞定！ 1layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); 当然需要简单修改一下item的布局文件，LinearLayout改为垂直排列，宽度固定100dp，图片/文字居中效果如下 瀑布流 这需要 StaggeredGridLayoutManager 布局管理器，可以 竖向/横向 滚动 代码如下12//瀑布流布局，3行，竖向StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL); 调整布局文件，效果如下 网格 这需要 GridLayoutManager 布局管理器 代码如下 12//网格布局，两行GridLayoutManager layoutManager = new GridLayoutManager(this,3); 调整布局文件后，效果如下 注册点击事件 RecyclerView 中并没有提供注册监听器的方法，需要子项View自行注册 部分代码如下1234567891011121314151617181920212223242526272829303132333435 static class ViewHolder extends RecyclerView.ViewHolder &#123; View fruitView; ImageView fruitImage; TextView fruitName; public ViewHolder(View view) &#123; super(view); fruitView = view; fruitImage = (ImageView) view.findViewById(R.id.fruit_image); fruitName = (TextView) view.findViewById(R.id.fruit_name); &#125;&#125; @Overridepublic ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); final ViewHolder holder = new ViewHolder(view); holder.fruitView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), "you clicked view " + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); holder.fruitImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), "you clicked image " + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); return holder;&#125;]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记-UI-ListView]]></title>
    <url>%2F2016%2F12%2F13%2FAndroid%E7%AC%94%E8%AE%B0-UI-ListView%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) ListView Android ListView工作原理完全解析，带你从源码的角度彻底理解 ListView是所有原生控件中使用频率最高和最复杂的，涉及知识点也较多，专门抽出一篇来记录，涉及一些过程分析，希望自己能写完 ListView的简单使用 先来看一下一个简单的实例代码如下 在activity_main.xml中添加_ListView 12345&lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt;&lt;/ListView&gt; 修改MainActivity的代码 123456789101112131415161718 //要显示的数组，屏幕长了点，为了显示滑动效果多增加了几项。 private String[] data = &#123;"apple","banana","orange","watermelon","pear","grape","pineapple","strawberry","cherry","mango","A","B","C","D","E","F"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar);//为适配器绑定数据 ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this,android.R.layout.simple_list_item_single_choice,data);//得到ListView对象的引用ListView listView = (ListView) findViewById(R.id.list_view);//适配器内容传递listView.setAdapter(adapter); &#125;); &#125; 效果如图 步骤其实比较简单 准备要显示的数据 ——String[] data数组 构建适配器 ——ArrayAdapter adapter 将适配器添加到ListView ——listView.setAdapter(adapter); 详解 ListView首先是用来展现大量数据的，数据源的来源可以是网络下载，程序内置、数据库提取等，本例中则是简单的定义了一个String类型 data数组。数据源的类型/种类繁多，使得ListView无法直接适配数据源，直接适配数据源将导致代码的臃肿和效率的低下。ListView与数据源之间需要一个过度 适配器：Adapter，Adapter在ListView和数据源之间起到了一个桥梁的作用。正是Adapter的使用ListView的使用变得要比其它控件复杂得多。 Adapter适配器 Adapter适配器在ListView和数据源之间起到了一个桥梁的作用Adapter的接口都是统一的，因此ListView不用担心任何适配方面的问题。 Adapter又是一个接口(interface)，它可以去实现各种各样的子类，每个子类都能通过自己的逻辑来去完成特定的功能，以及与特定数据源的适配操作，比如说ArrayAdapter可以用于数组和List类型的数据源适配，SimpleCursorAdapter可以用于游标类型的数据源适配 这样就解决了数据源适配的难题，并且还拥有相当不错的扩展性 简易的示图(来自 郭霖的博客) 常用Adapter ArrayAdapter——用来绑定一个数组，支持泛型操作 SimpleAdapter——用来绑定在xml中定义的控件对应的数据 SimpleCursorAdapter——用来绑定游标得到的数据 BaseAdapter——通用的基础适配器 实例中使用的是ArrayAdapter，ArrayAdapter具有多个构造函数重载，这里使用的是字符串类型， ArrayAdapter的构造函数 当前上下文 ListView子项的id，本例中使用的是android.R.layout.simple_list_item 这是Android内置的一个布局文件 需要适配的数据之后适配器就构建完成，最后传递进LIstView中即可 自定义适配器 从第一行代码第二版的源码LiseViewTest目录下拷贝drawblehdpi 到你的工程下 新建Fruit类 123456789101112131415161718public class Fruit &#123; private String name; private int imageId; //构造函数 水果名称/水果对应图片资源ID public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125; 在layout目录下新建fruititem.xml 123456789101112131415161718&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="10dp" /&gt;&lt;/LinearLayout&gt; 一个ImageView和TextView ，水平居中显示 自定义适配器继承自ArrayAdapter 泛型指定为fruit类 12345678910111213141516171819202122 //继承自ArrayAdapter public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId;//构造函数 /上下文 ListView子项布局id 数据 public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @Override //当前子元素的的位置， public View getView(int position, View convertView, ViewGroup parent)&#123; Fruit fruit = getItem(position); // 获取当前项的Fruit实例 View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false); ImageView fruitImage = (ImageView)view.findViewById(R.id.fruit_image); TextView fruitName = (TextView)view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125; &#125; getView()方法接受的三个参数，第一个参数position代表当前子元素的的位置，我们可以通过具体的位置来获取与其相关的数据。第二个参数convertView LayoutInflater.inflate()方法来去加载布局。接收3个参数，第三个参数为false表示只在父布局声明的layout属性有效，但不会为这个view添加父布局，最后设定为接下来会对这个view进行一些属性和值的设定，最后将view返回。 修改MainActivity的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; //新建Fruit类的数组 private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);// 初始化水果数据 initFruits(); //设置FruitAdapter适配器 FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); //得到ListView的引用 ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; // 初始化水果数据 private void initFruits() &#123; //填充两遍，占满屏幕 for (int i = 0; i &lt; 2; i++) &#123; Fruit apple = new Fruit("Apple", R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango_pic); fruitList.add(mango); &#125; &#125;&#125; 只需要修改fruititem.xml，即可定制界面 提升ListView的效率convertView参数 针对 Fruit fruit = getItem(position); // 获取当前项的Fruit实例每次滑动ListView时，getView()方法都会将布局都会重新加载一边 convertView参数：将之前加载完成的布局进行缓存。 借助convertView参数，在每次加载View之前查询convertView是否为空，为空则重新加载，不为空则从convertView中取 代码部分如下 12345678View view;Fruit fruit = getItem(position); // 获取当前项的Fruit实例 if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false); &#125;else &#123; view = convertView; &#125; ListView不会再重复加载布局了 ViewHolder ViewHolder不是Android的开发API，而是一种设计方法 针对ImageView fruitImage = (ImageView)view.findViewById(R.id.fruit_image); TextView fruitName = (TextView)view.findViewById(R.id.fruit_name);每次布局实例化后，findViewById都会重新执行获取控件实例 新增内部类 ViewHolder，利用Tag附加到对应View中，即每次加载布局时，对应的 获取控件实例的操作也一并执行，并储存在View中。这样 获取控件实例的操作直接缓存在View中，不会再重复执行 代码如下 12345678910111213141516171819202122232425262728 @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); // 获取当前项的Fruit实例 View view; ViewHolder viewHolder; if (convertView == null) &#123; //加载布局 view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById (R.id.fruit_image); viewHolder.fruitName = (TextView) view.findViewById (R.id.fruit_name); view.setTag(viewHolder); // 将ViewHolder存储在View中 &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); // 重新获取ViewHolder &#125; viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; &#125;//ViewHolder 内部类 class ViewHolder &#123; ImageView fruitImage; TextView fruitName; &#125; ListView中的点击事件 比较简单,再MainActivty的onCreate方法中添加 代码如下 123456listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show(); setOnItemClickListener为ListView注册了一个监听器，点击发生时回掉 onItemClick()方法，该方法通过position参数判断具体子项。该处是执行Toast]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—UI(一)]]></title>
    <url>%2F2016%2F12%2F09%2FAndroid%E7%AC%94%E8%AE%B0-UI(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) 常用控件TextView TextView 显示文本信息 12345678&lt;TextView android:id=&quot;@+id/text_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:textSize=&quot;24sp&quot; android:textColor=&quot;#00ff00&quot; android:text=&quot;This is TextView&quot; /&gt; 效果如下 常用属性详解 android:id 指定当前控件唯一标识符 android:layout_width android:layout_height指定控件的宽度和高度，取值有 match_parent 匹配父布局 wrap_content自适应内容 fill_parent与match_parent 相同 android:gravity 文字对齐方式，可取值 top bottom left right center 可以使用 | 同时使用多个属性 android:text 文本内容 android:textSize android:textColor 文本的大小/颜色 Button Button 按钮 代码 123456&lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button" android:textAllCaps="false"/&gt; 效果如下 常用属性 android:textAllCaps 系统自动转换文本为大写 true/false 按钮响应(3种) 匿名类注册监听器 代码如下12345678//新建Button对象 //强制类型转换Button button = (Button)findViewById(R.id.button);button.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v)&#123; //添加逻辑 &#125;&#125;); 接口方式实现 代码123456789101112131415161718192021222324 //继承接口 public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //注册监听器 Button button = (Button)findViewById(R.id.button); button.setOnClickListener(this); &#125; @Override //根据button id处理不同逻辑 public void onClick(View view)&#123; switch (view.getId())&#123; case R.id.button: //处理逻辑 break; default: break; &#125; &#125;&#125; android:onClick 匹配在xml中指定android:onClick 指定的方法名称匹配，签名必须完全相同方法要求： 是公共方法 public 具有空返回值 void 以 View 作为唯一参数（这将是之前点击的 View） 代码如下 1android:onClick="Button_onClick" 123public void Button_onClick(View view)&#123; //处理逻辑&#125; EditText EditText 代码如下 123456&lt;EditText android:id="@+id/edit_text" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="输入文字" android:maxLines="2"/&gt; 效果 常用属性 android:hint 指定一些提示性文字，再用户未输入时提示。 android:maxLines 输入内容最大占用行数 提取输入文本 通过findViewById找到EditText 实例，在处理逻辑中调用EditText.getText方法得到输入内容，再由toString转换为字符串。 代码如下12345678910//新建EditTExt对象private EditText editText;//绑定EditText实例editText = (EditText)findViewById(R.id.edit_text);//提取文本String inputText = editText.getText().toString();//Toast显示Toast.makeText(MainActivity.this,inputText,Toast.LENGTH_SHORT).show(); ImageView 将图片放入drawable-xhdpi文件夹 ImageView 代码 12345&lt;ImageView android:id="@+id/image_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/img_1"/&gt; 效果如下 常用属性 android:src 引用资源位置 更改ImageView图片 调用 imageView.setImageResource()方法 代码如下12345private ImageView imageView;imageView = (ImageView)findViewById(R.id.image_view);imageView.setImageResource(R.drawable.img_2); ProgressBar ProgressBar 代码如下 123456&lt;ProgressBar android:id="@+id/progress_bar" android:layout_width="match_parent" android:layout_height="wrap_content" style="?android:attr/progressBarStyleHorizontal" android:max="100"/&gt; 常用属性 android：visibility 是否可见 取值 visible invisible gone style=”?android:attr/progressBarStyleHorizontal”android:max=”100”设定显示方式为横向进度条，进度条最大值100 进度条有关设置 显示/隐藏进度条progressBar.setVisibility()方法 12345678910private ProgressBar progressBar;progressBar = (ProgressBar)findViewById(R.id.progress_bar);//设置ProgressBarif(progressBar.getVisibility() == View.GONE)&#123; progressBar.setVisibility(View.VISIBLE);&#125; else &#123; progressBar.setVisibility(View.GONE);&#125; 设置进度条进度 123int progress = progressBar.getProgress();progress +=10;progressBar.setProgress(progress); AlertDialog AlertDialog 代码如下 123456789101112131415161718AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);dialog.setTitle("This is Dialog");dialog.setMessage("something important");dialog.setCancelable(false);//setPositiveButton设定OK点击事件dialog.setPositiveButton("OK",new DialogInterface.OnClickListener()&#123;@Override public void onClick(DialogInterface dialog,int which)&#123; &#125;&#125;);//setNegativeButton设定Canncel点击事件dialog.setNegativeButton("Canncel",new DialogInterface.OnClickListener()&#123;@Override public void onClick(DialogInterface dialog,int which)&#123; &#125;&#125;);//显示 AlertDialogdialog.show(); ProgressDialog ProgressDialog与AlertDialog类似，但是会额外显示一个进度条 代码如下 12345678910//新建ProgressDialog对象ProgressDialog progressDialog = new ProgressDialog(MainActivity.this);//设置标题progressDialog.setTitle("This is ProgressDialog");//设置内容progressDialog.setMessage("Loading...");//是否可以返回键取消progressDialog.setCancelable(false);//显示progressDialog.show(); 效果如图 PS：progressDialog.setCancelable();属性设置为false时表示ProgressDialog无法通过Back键取消。只能通过progressDialog.dismiss()方法取消 四种基本布局LinearLayout 线性布局 线性方向上依次排列 基础效果如下1234567891011121314151617181920212223242526&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="ljy.com.uilayouttest.MainActivity"&gt; &lt;Button android:id="@+id/button_1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button_1"/&gt; &lt;Button android:id="@+id/button_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button_2"/&gt; &lt;Button android:id="@+id/button_3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button_3"/&gt;&lt;/LinearLayout&gt; 基础属性 android：orientation LinearLayout 的排列方向，取值有两种 horizontal横向和vertical竖向，不指定 android：orientation时，默认 horizontal android:layoutgravity 指定控件在布局中的对齐方式。该属性与 LinearLayout 的排列方向有很大关系。 android:layoutweight 允许使用比例方式指定控件大小,计算控件大小时，系统非将所有控件的android:layoutweight 值相加，当作基底，计算指定的大小比例 EditText和Button常见用法 12345678910111213 &lt;EditText android:id="@+id/button_1" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="Button_1"/&gt;&lt;Button android:id="@+id/button_2" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:text="Button_2"/&gt; 指定android:layoutwidth 为0dp，android:layoutweight=”1”均为1 平分大小 另一种用法 123456789101112 &lt;EditText android:id="@+id/button_1" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="Button_1"/&gt;&lt;Button android:id="@+id/button_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button_2"/&gt; 将Button的android:layout_width设定为wrap_content，EditText 的android:layoutweight=”1”，EditText会占满整个屏幕剩余部分，在适配屏幕时较常用 RelativeLayout相对布局 属性较多，以代码形式说明相对父布局位置 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="ljy.com.uilayouttest.MainActivity"&gt; &lt;Button android:id="@+id/button_1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentLeft="true" android:layout_alignParentTop="true" android:text="Button 1"/&gt; &lt;Button android:id="@+id/button_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentRight="true" android:layout_alignParentTop="true" android:text="Button 2"/&gt; &lt;Button android:id="@+id/button_3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="Button 3"/&gt; &lt;Button android:id="@+id/button_4" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:layout_alignParentLeft="true" android:text="Button 4"/&gt; &lt;Button android:id="@+id/button_5" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:layout_alignParentRight="true" android:text="Button 5"/&gt;&lt;/RelativeLayout&gt; android:layout_alignParentLeft=”true”android:layout_alignParentTop=”true”android:layout_centerInParent=”true”android:layout_alignParentBottom=”true”android:layoutalignParentRight=”true” 简而言之这些属性指定了控件相对父布局的位置 相对控件位置 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="ljy.com.uilayouttest.MainActivity"&gt; &lt;Button android:id="@+id/button_3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="Button 3"/&gt; &lt;Button android:id="@+id/button_1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_above="@id/button_3" android:layout_toLeftOf="@id/button_3" android:text="Button 1"/&gt; &lt;Button android:id="@+id/button_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_above="@id/button_3" android:layout_toRightOf="@id/button_3" android:text="Button 2"/&gt; &lt;Button android:id="@+id/button_4" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@id/button_3" android:layout_toLeftOf="@id/button_3" android:text="Button 4"/&gt; &lt;Button android:id="@+id/button_5" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@id/button_3" android:layout_toRightOf="@id/button_3" android:text="Button 5"/&gt;&lt;/RelativeLayout&gt; 说明 android:layout_above 可以指定一个控件位于指定控件的上方，需要指定ID引用 android:layout_below 指定一个控件位于指定控件的下方，id引用 android:layout_toLeftOf 指定一个控件位于指定控件的左侧，id引用 android:layout_toRightOf 指定一个控件位于指定控件的右侧，id引用。 NOTE：当控件去引用另一个控件的ID时，引用控件一定要在前本例中是id/button3在最前面 FrameLayout帧布局 所有控件默认左上角 代码如下两个控件重合 1234567891011121314&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TextView"/&gt; &lt;ImageView android:id="@+id/image_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher"/&gt;&lt;/FrameLayout&gt; android:layoutgravity 同样可以应用于FrameLayout中，指定对齐方式 PercentFrameLayout百分比布局 PercentFrameLayout并非内置于系统SDK中，使用前要在build.gradle中添加百分比布局的依赖。 修改app/build.gradle文件，在dependencies闭包中增加依赖。 12345678910dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.0.1' //下面一行为增加内容，要与上面的版本号保持一致 compile 'com.android.support:percent:25.0.1' testCompile 'junit:junit:4.12'&#125; 修改完成后，as会开始同步，同步完成即可。 PercentFrameLayout继承了FrameLayout的特性，所有控件默认左上角，需要通过android:layoutgravity 来调整位置 源码如下 12345678910111213141516171819202122232425262728293031323334# PercentFrameLayout 并非系统内置SDK，需要声明完整包路径&lt;android.support.percent.PercentFrameLayout# 随后定义app的命名空间 xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button1" android:text="Button1" android:layout_gravity="left|top" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt; &lt;Button android:id="@+id/button2" android:text="Button2" android:layout_gravity="right|top" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt; &lt;Button android:id="@+id/button3" android:text="Button3" android:layout_gravity="left|bottom" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt; &lt;Button android:id="@+id/button4" android:text="Button4" android:layout_gravity="right|bottom" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt;&lt;/android.support.percent.PercentFrameLayout&gt; 效果如图 与之类似的还有 PercentRelativeLayout，用法不加累赘 自定义控件引入布局 新建title.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/title_bg"&gt; &lt;Button android:id="@+id/title_back" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="5dp" android:background="@drawable/back_bg" android:text="Back" android:textColor="#fff" /&gt; &lt;TextView android:id="@+id/title_text" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_weight="1" android:gravity="center" android:text="Title Text" android:textColor="#fff" android:textSize="24sp" /&gt; &lt;Button android:id="@+id/title_edit" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="5dp" android:background="@drawable/edit_bg" android:text="Edit" android:textColor="#fff" /&gt;&lt;/LinearLayout&gt; 在activitymain.xml 中使用title.xml &lt;include layout=&quot;@layout/title&quot;/&gt; 隐藏系统自带标题栏,在mainActivity的onCreat中添加如下代码。 123 ActionBar actionBar = getSupportActionBar();if (actionBar != null) actionBar.hide(); 效果如下 自定义控件 创建TitleLayout继承自LinearLayout ，代码如下123456789public class TitleLayout extends LinearLayout &#123;//构造函数 public TitleLayout(Context context, AttributeSet attributeSet)&#123; super(context,attributeSet); //调用LayoutInflater.from方法构建LayoutInflater对象， //再调用inflate加载布局文件 LayoutInflater.from(context).inflate(R.layout.title,this); &#125;&#125; 再activitymain.xml 中 添加自定义控件,添加自定义控件时要指明控件的完整类名 123&lt;ljy.com.uicustomviews.TitleLayout android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; 效果与引入布局文件相同 注册按钮点击事件 在TitleLayout的构造函数添加按钮注册点击事件1234567891011121314151617Button titleBack = (Button)findViewById(R.id.title_back);Button titleEdit = (Button)findViewById(R.id.title_edit);titleBack.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //模拟返回键 ((Activity)getContext()).finish(); &#125; &#125;); titleEdit.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //Toast通知 Toast.makeText(getContext(),"clik",Toast.LENGTH_SHORT).show(); &#125; &#125;);]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—Activity]]></title>
    <url>%2F2016%2F12%2F07%2FAndroid%E7%AC%94%E8%AE%B0-Activity%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) Activity基础Activity定义 Activity 是Android四大组件之一，用户可与其提供的屏幕进行交互，以执行操作。 每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口可以充满屏幕，也可浮动。应用通常由多个彼此联系的 Activity 组成。应用中的某个 Activity 为“主”Activity，即首次启动应用时的Activity。 创建Activity 新建FirstAtivity继承自AppCompatActivity 12345public class FirstActivity extends AppCompatActivity&#123;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);&#125; &#125; 创建加载布局 切换到first-layout 1234567891011 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button_1" android:text="button_1" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 在FirestActivity中加载layout 在onCreate中加入 1setContentView(R.layout.first_layout); 在AndroidMainfest文件中注册。 12345678&lt;activity android:name=".FirstActivity" android:label="This is FirstActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 在模拟器中启动apk 使用Toast Toast google官方说明 推送一个短小信息推送给用户 如图（摘自android developer） 使用方法 1Toast.makeText(context, text, duration).show(); 举例 12Toast.makeText(FirstActivity.this, "you clicked button 1", Toast.LENGTH_SHORT).show();/* activity.this 消息内容 显示时间设置 */ 使用Menu 创建菜单 在res下新疆menu文件夹，右击menu文件夹—new—Menu resource file，创建main的菜单文件。 main.xml中添加如下代码 123456789 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@+id/add_item" android:title="Add"/&gt; &lt;item android:id="@+id/remove_item" android:title="Remove"/&gt;&lt;/menu&gt; 这里创建了两个菜单项 Add和Remove 在FirestActivity中重写 onCreateOptionsMenu()方法（快捷键 Ctrl+O） 12345 @Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return true;&#125; getMenuInflater()可以得到MenuInflater对象，再调用.inflate就可以创建菜单。.inflat接受俩个参数，一是资源文件名，二是菜单项添加至那个对象中。onCreateOptionsMenu方法中返回true表示创建菜单并显示。 效果如下。 创建菜单点击响应事件 重写onOptionsItemSelected方法 12345678910111213@Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(this, "Add", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, "Remove", Toast.LENGTH_SHORT).show(); break; default: &#125; return true; &#125; 通过item.getItemId()判断点击选项，弹出不同的Toast 向一个activity 并传递字符串 构建一个Intent Intent intent = new Intent(this, DisplayMessageActivity.class); 构造方法有两个参数： Context 是第一个参数，这里使用了this是因为Activity是Context的子类。 Class 类是系统将要分发的APP组件，在这里，这个Activity将会被启动。 12345678910111213public void sendMessage(View view) &#123; // 创建一个新的intent对象，绑定DisplayMessageActivity Intent intent = new Intent(this, DisplayMessageActivity.class); //创建一个editText对象，绑定xml中editText EditText editText = (EditText) findViewById(R.id.edit_message); //获取editText中输入文字，转成字符串 String message = editText.getText().toString(); //一个Intent对象可以携带被称为extras的键值对。 // putExtra()方法将键放在第一个参数中，将值放在第二个参数中。 intent.putExtra(EXTRA_MESSAGE, message); //启动intent对应Activity startActivity(intent); &#125; 1234567891011121314151617181920protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_display_message); //创建本地intent Intent intent = getIntent(); //取出String类型数据，如果是Int类型就是getIntExtra，Boolean类型就是getBooleanExtra String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE); //显示String //创建新的TextView TextView textView = new TextView(this); //设置文本大小 textView.setTextSize(40); //设置显示内容 textView.setText(message); //绑定xml ViewGroup layout = (ViewGroup) findViewById(R.id.activity_display_message); //ViewGroup中添加TextView layout.addView(textView);&#125; 返回数据给上一个Activity 构建Intent使用startActivityForResult()方法传入请求码，启动下一个Activity在下一个Activity中构建Intent，intent.putExtra存入键值-key，调用setResult()方法，传入finish()结束掉Activity重写第一个Activity中的onActivityResult()方法，调用.getStringExtra取出key对应键值。 startActivityForResult(Intent, int Bundle) Intent与单纯启动Activity的Intent相同，第二个是请求码，下一级 回调提供相同的请求码，以便您应用可以正确识别结果。 12Intent intent = new Intent(FirestActivity.this,ScendActivity.class);startActivityForResult(intent,1); setResult()方法，第一个参数向上级方法处理结果，一般使用RESULT_OK或RESULT_CANCELED，第二个参数 对应Intent 1234567//新建显示IntentIntent intent = new Intent();//存入key-键值intent.putExtra("data_return","Hello Firest");setResult(RESULT_OK,intent);//结束Activityfinish(); onActivityResult()三个参数.第一个startActivityForResult() 传递的请求代码。第二个 Activity 指定的结果代码。成功是 RESULT_OK；失败，则是 RESULT_CANCELED。第三个是传送结果数据的 Intent。 12345678910111213 @Overrideprotected void onActivityResult(int requestCode,int resultCode,Intent data)&#123; //选择不同请求码对应处理逻辑 switch(requestCode)&#123; case 1: //处理结果时候ok if(resultCode == RESULT_OK)&#123; //取出数据 String returnedData = data.getStringExtra("data_return"); Log.d("FirstActivity", returnedData); &#125; &#125;&#125; Activity生命周期 Activity 3种状态 Resumed/继续Activity 处于前台，且用户可以与其交互 Paused/暂停 Activity 被在前台中处于另一个 Activity—部分阻挡。 暂停的 Activity 不会接收用户输入并且无法执行任何代码。 Stopped/停止Activity完全隐藏，对用户完全不可见.当停止时，activity的所有状态信息比如成员变量都会被保留，但是不能再执行任何代码 启动一个Activity onCreate方法 主Activity： 用户点击app图标，启动主Activity 在AndroidManifest.xml中声明1234&lt;intent-filter&gt;&lt;action android:name="android.intent.action.MAIN" /&gt;&lt;category android:name="android.intent.category.LAUNCHER" /&gt;&lt;/intent-filter&gt; 通过调用onCreate方法创建一个Activity实例，onCreate方法在Activity的整个生命周期中只执行一次。 之后系统会很快的调用onStart和onResume方法，Activity进入Resumed/继续模式。直到被其他activity覆盖/屏幕关闭。销毁Activity onDestory方法大多数的APP不需要实现这个方法，因为本地类引用会随着Activity一起总结，不过Activity的清理工作应该放在onPause下或者onStop。 Note:在所有的情况下系统调用onDestory方法之后已经调用过onPause方法与onStop方法，不过有一个例外情况：你在onCreate方法中调用了finish方法。在一些例子中，当你的Activity临时决定要启动另一个Activity，你可能要在onCreate方法内调用finish方法来销毁这个Activity，在这种情况下，系统会立即调用onDestory方法，而不会调用其它任何生命周期方法。 暂停Activity onPause()方法 Activity被其他Activity覆盖/失去用户焦点，系统调用onPause()方法，Activity 进入暂停状态。 note：android7.0及以上版本加入了多窗口模式，当Activity失去用户焦点时，可能处于多窗口模式。 onPause() 常用回调： 检查 Activity 是否可见。不可见则停止可能消耗 CPU 的操作 提交未保存的更改，仅保存用户离开时希望永久性保存此类更改（比如电子邮件草稿）。 释放系统资源，GPS/Camer等 示例 (释放Camer) 123456789public void onPause() &#123;super.onPause(); // Always call the superclass method first// Release the Camera because we don't need it when paused// and other activities might need to use it.if (mCamera != null) &#123; mCamera.release(); mCamera = null;&#125; 注意事项： 在onPause()一般不执行永久性存储用户更改，不执行 CPU 密集型工作，这些工作一般放在onStop() 。 继续 Activity onResume() 方法 暂停状态回到继续状态，Activity第一次启动时也会调用这个方法。 onResume() 以初始化在 onPause() 期间释放的组件。 示例(重新获取Camera)1234567public void onResume() &#123; super.onResume(); // Always call the superclass method first // Get the Camera instance as the activity achieves full user focus if (mCamera == null) &#123; initializeCamera(); // Local method to handle camera init &#125; 停止 Activity note：大多数相对简单的 Activity 而言，系统在 Activity 停止时会将Activity 实例保留在系统内存中，无需实现 onStop() 和 onRestart() 或甚至onStart() 方法。可能只需使用 onPause() 暂停正在进行的操作，并从系统资源断开连接。 onStop() 方法 场景： 用户在最近应用切换到另一个应用 应用中执行开始新 Activity 的操作 Activity使用时，接打电话 调用时，Activity不再可见，释放几乎所有用户不使用时不需要的资源。如果系统内存紧张，则可能销毁内存中的Acitivity实例。 onStop() 方法调用后，Activity不再可见，极端情况下，系统可能会仅终止应用进程，而不调用 onDestroy() ，因此需要使用 onStop() 释放几乎所有用户不使用时不需要的资源。 尽管 onPause() 方法在 onStop()之前调用，在onStop() 执行更大、占用更多 CPU 的关闭操作，比如向数据库写入信息 示例（草稿笔记内容保存在永久存储）12345678910111213141516 protected void onStop() &#123; super.onStop(); // Always call the superclass method first // Save the note's current draft, because the activity is stopping // and we want to be sure the current note progress isn't lost. ContentValues values = new ContentValues(); values.put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText()); values.put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle()); getContentResolver().update( mUri, // The URI for the note to update. values, // The map of column names and new values to apply to them. null, // No SELECT criteria are used. null // No WHERE columns are used. );&#125; 启动/重启 Activity onStart() 方法 Activity 停止转换为继续状态时，系统回调onRestart() 方法+ onStart() 方法.onStop() 方法清理了所有 Activity 的资源，重启 Activity 需要重新实例化它们。同时 Activity 初次创建时重新实例化它们。 出于此，经常使用 onStart() 方法作为 onStop() 方法的对应 示例1234567891011121314151617181920212223 @Overrideprotected void onStart() &#123; super.onStart(); // Always call the superclass method first // The activity is either being restarted or started for the first time // so this is where we should make sure that GPS is enabled LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE); boolean gpsEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER); if (!gpsEnabled) &#123; // Create a dialog here that requests the user to enable GPS, and use an intent // with the android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS action // to take the user to the Settings screen to enable GPS when they click "OK" &#125;&#125;@Overrideprotected void onRestart() &#123; super.onRestart(); // Always call the superclass method first // Activity being restarted from stopped state&#125; 保存 Activity 状态 onSaveInstanceState()方法 默认情况下，Activity 实例被销毁时系统会使用 Bundle 实例状态保存 Activity 布局中有关每个 View 对象的信息。在Activity 重建时，布局状态便自动恢复先前的状态。 默认实现保存有关 Activity 视图层次的状态信息，例如 EditText 小部件中的文本或ListView 的滚动位置 要恢复的更多信息，需要重写 onSaveInstanceState()方法，将键值对添加至 Bundle 对象 note:旋转屏幕时，Activity 将被销毁并重新创建。原因：方向更改时可能需要时加载备用资源（比如布局） 示例12345678910111213static final String STATE_SCORE = "playerScore";static final String STATE_LEVEL = "playerLevel";...@Overridepublic void onSaveInstanceState(Bundle savedInstanceState) &#123; // Save the user's current game state savedInstanceState.putInt(STATE_SCORE, mCurrentScore); savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel); // Always call the superclass so it can save the view hierarchy state super.onSaveInstanceState(savedInstanceState); &#125; 恢复 Activity onCreate() 和 onRestoreInstanceState() 回调方法均接收包含实例状态信息的相同 Bundle onCreate() 方法 调用onCreate() 方法需要区分是创建 Activity 的新实例还是恢复先前的实例，判断 Bundle 是否为 null 示例 1234567891011121314@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Always call the superclass first // Check whether we're recreating a previously destroyed instance if (savedInstanceState != null) &#123; // Restore value of members from saved state mCurrentScore = savedInstanceState.getInt(STATE_SCORE); mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL); &#125; else &#123; // Probably initialize members with default values for a new instance &#125; ...&#125; onRestoreInstanceState()方法 只需要恢复的已保存的状态 示例12345678 public void onRestoreInstanceState(Bundle savedInstanceState) &#123; // Always call the superclass so it can restore the view hierarchy super.onRestoreInstanceState(savedInstanceState); // Restore state members from saved instance mCurrentScore = savedInstanceState.getInt(STATE_SCORE); mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);&#125; 重启Activity其他选择 官方说明 重启应用并恢复大量数据不仅成本高昂，而且会留下糟糕的使用体验，有两个其他选择在配置变更期间保留对象 Activity 因配置变更而重启，则可通过保留 Fragment 来减轻重新初始化 Activity 的负担 当 Android 系统因配置变更而关闭 Activity 时，不会销毁已标记为要保留的 Activity 的片段。 您可以将此类片段添加到 Activity 以保留有状态的对象。 Activity最佳实践知晓当前运行的活动 自定义BaseActivity继承自AppCompatActivity重写onCreate方法，打印当前运行的Activity名app类所有Activity改为继承BaseActivity 代码如下 1234567public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //打印当前类名 Log.d("BaseActivity", getClass().getSimpleName())； &#125; 效果如下 随时退出程序 新建ActivityCollector类作为活动管理器，添加/删除Activity登记,在BaseActivity中添加对应代码。 代码如下 1234567891011121314151617181920 public class ActivityCollector &#123;//新建Activity的列表对象 public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;();//添加Activity进入列表 public static void addActivity(Activity activity) &#123; activities.add(activity); &#125;//在列表中移除Activity public static void removeActivity(Activity activity) &#123; activities.remove(activity); &#125;//for循环列表 结束所有Activity public static void finishAll() &#123; for (Activity activity : activities) &#123; if (!activity.isFinishing()) &#123; activity.finish(); &#125; &#125; &#125; &#125; BaseActivity在onCreate()方法中添加 12//Activity管理器中添加新的活动ActivityCollector.addActivity(this); 重写onDestroy()方法 123456@Overrideprotected void onDestroy()&#123; super.onDestroy(); //Activity管理器中移除活动 ActivityCollector.removeActivity(this);&#125; 在任何地方调用finishAll()方法即可。 启动活动的最近写法 启动下一个Activity并传递数据模块化 在SecondActivity内增加actionStart()方法 12345678910 //调用的Activity，数据1，数据2 public static void actionStart(Context context, String data1, String data2)&#123; //新建Intent，绑定SecondActivity Intent intent = new Intent(context,ScendActivity.class); //存入data1，data2 intent.putExtra("param1",data1); intent.putExtra("param2",data2); //启动Activity context.startActivity(intent);&#125; 启动SecondActivity方式ScendActivity.actionStart(FirestActivity.this,&quot;data1&quot;,&quot;data2&quot;);]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初入树莓派2---初始化+远程桌面]]></title>
    <url>%2F2016%2F11%2F27%2F%E5%88%9D%E5%85%A5%E6%A0%91%E8%8E%93%E6%B4%BE2----%E5%B8%B8%E8%A7%84%E5%88%9D%E5%A7%8B%E5%8C%96%2B%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[初始化启用树莓派root用户 不做物联网终端时启用root用户比较方便 SSH连接树莓派 在命令行下执行 启用root用户 1sudo passwd root 执行后输入两遍你要设定的root密码 在输入1sudo passwd –unlock root root用户解锁完成 执行完毕后依旧无法登陆 执行 1sudo nano /etc/ssh/sshd_config 找到PermitRootLogin without-password 改为PermitRootLogin yes Ctrl + X 、 Y 、 回车 保存 sudo reboot 更换国内镜像地址 &gt; http://blog.lxx1.com/2040 由于众所周知的原因，树莓派链接官方更新源实在太过缓慢，国内有一批不错的镜像地址，可以解决系统/软件更新问题。 收集的树莓派镜像一般使用比较频繁的有下面几个1.阿里云 首推镜像地址，移动/联通/电信网络都有不错的访问速度。2.大连东软信息学院 北方用户比较友好3.中国科学技术大学 教育网有加成，非教育网就慢多了 这里选择 阿里云的镜像 更新 sources.list 执行 1sudo nano /etc/apt/sources.list 删除官方内容或者用#注释掉，添加以下内容 12deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contribdeb-src http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib 删除raspi.list备用更新源(可选) 通常更新sources.list后依旧缓慢，大多是raspi.list的锅 rm /etc/apt/sources.list.d/raspi.list 设置中文字体 系统中缺少中文字库 首先更新字库和输入法 执行 12sudo apt-get install ttf-wqy-zenheisudo apt-get install scim-pinyin 接下来 都点 y 执行 1sudo raspi-config 选择change_locale 空格键在前面打勾或去掉勾（星号=勾） Tab选择OK 去掉en_GB.UTF-8 UTF-8勾选：”en_US.UTF-8 UTF-8”、”zh_CN.UTF-8 UTF-8”、”zh_CN.GBK GBK” OK，下一屏幕, 默认语言选zh_CN.UTF-8 远程桌面 终端执行 1apt-get install xrdp windows端 CMD 执行 mstsc 输入树莓派ip地址 用户名 密码]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub-Pages更新导致Next主题-博客主页空白，解决方案]]></title>
    <url>%2F2016%2F11%2F08%2FGitHub-Pages%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4Next%E4%B8%BB%E9%A2%98-%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A1%B5%E7%A9%BA%E7%99%BD%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[倒腾了俩小时，以为梯子坏了，结果。。。GitHub-Pages更新了！！！ 原因 GitHub-Pages更新， 过滤掉了 source/vendors 目录的访问。 issues入口 解决1更新主题 作者更新了到最新的master分支，解决了这个问题， So： 1git pull https://github.com/iissnan/hexo-theme-next themes/next 解决2更新本地设置（Next最新版） 将 source/vendors 目录修改成 source/lib （或者其他的名称，只是 lib 我测试了可以使用）；同时，修改下主题配置文件_config.yml， 将 _internal: vendors 改成你所修改的名字，例如 _internal: lib。 解决3更新本地设置（Next5.0及以下版本） 将 source/vendors 目录修改成 source/lib （或者其他的名称，只是 lib 我测试了可以使用）；同时，修改下主题配置文件_config.yml， vendors: vendors 改成你所修改的名字，例如 _internal: lib。]]></content>
      <categories>
        <category>点滴</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自建DNS服务器(dnsmasq)，对抗DNS污染]]></title>
    <url>%2F2016%2F10%2F09%2F%E8%87%AA%E5%BB%BADNS%E8%A7%A3%E5%86%B3%E8%BF%90%E8%90%A5%E5%95%86DNS%E6%B1%A1%E6%9F%93%2F</url>
    <content type="text"><![CDATA[背景 学校网络出口劫持严重，上淘宝加返利———-等等等等等等 一直更新hosts不方便，要上google，全平台不好弄 项目组需要 目的 搭建一个可访问个人公网DNS服务器 提高DNS加载速度 规避运营商的DNS劫持 不影响学校内网访问 简单的能上google 准备 一台有公网IP的vps，开放了53端口（端口扫描显示开放了53端口） 装的是linux系统（以 CentOS 6.4 为例） WinSCP（或其他文件管理） putty.exe（或者其他SSH登陆工具） 没了。。。。 DNSmasq原理和说明 DNSmasq是一个小巧且方便地用于配置DNS和DHCP的工具，适用于小型网络。作为域名解析服务器(DNS)，dnsmasq可以通过缓存 DNS 请求来提高对访问过的网址的连接速度。 通过设置DNSmasq的上游DNS地址为无污染DNS来解决运营商的DNS污染。 DNSmasq可以对单独的网址设置DNS服务器。对于学校内网地址设置为学校教育网的DNS解析。对于类似于youtube这种由于DNS污染没法访问的地址，可以先收集无污染的DNS地址，然后交与无污染DNS解析得到正确地址。 DNSmasq再对网址提交上游DNS解析前，可以先通过本地hosts匹配。设置合适hosts可以实现科学上网。 开始！ 步骤安装dnsmasq 1yum install dnsmasq -y 配置Dnsmasq Dnsmasq的配置文件是 /etc/dnsmasq.conf .通过WinSCP加载修改。 dnsmasq.conf设置项说明 此次使用的配置如下 1234567891011 #指定给dnsmasq使用的hosts addn-hosts=/etc/dnsmasq.host #不使用/etc/resolv.conf(VPS默认DNS)来进行上游dns服务器解析需要配置的比较少直接写在dnsmasq.conf文件里了 no-resolv #上游DNS地址这里为腾讯DNS和中科大DNSserver=119.29.29.29server=202.141.162.123server=/google.com/202.141.162.123 #这一行是针对学校内网访问，学校内地址使用学校内网DNS。具体地区调整。server=/.edu.cn/202.141.162.123 上游DNS推荐 这里需要在VPS上测试各个DNS后决定。 常用靠谱DNS 阿里DNS 223.5.5.5 223.6.6.6 114DNS 114.114.114.114 腾讯DNS 119.29.29.29 V2EX DNS 199.91.73.222 178.79.131.110（访问苹果商店有buff加速） 无污染DNS 目前比较稳定的只有中科大DNS和一些自建的小型DNS。小型DNS通过反带来访问google等，会带来一些隐私和安全风险，还是推荐自建DNS/hosts访问。 中科大DNS 202.38.93.153 （教育网） 202.141.176.93 （中国移动） 202.141.162.123 （中国电信） 其他DNS请自行GOOGLE 千万注意！！！ 配置文件中有listen-address配置，网络大多数教程中有listen-address=127.0.0.1这是指Dnsmasq只服务于本机的DNS请求。如果需要搭建公网DNS服务，这个绝对不能有！！ 创建/修改/etc/dnsmasq.host文件 一些常用去广告hosts/科学上网hosts的内容， 具体不多说hosts科学上网是一天比一天死的快。没有找到靠谱的地址推荐。自行搜索把！ 重启Dnsmasq服务 1sudo service dnsmasq restart 测试53端口 1netstat -tunlp|grep 53 如果正常应该如下 123[root@VM_27_70_centos ~]# netstat -tunlp|grep 53tcp 0 0 0.0.0.0:53 0.0.0.0:* LIST EN 4226/dnsmasqudp 0 0 0.0.0.0:53 0.0.0.0:* 4226/dnsmasq 修改本地DNS地址 这个不多说了，不会的自行google了。。 结束语创建完了，本地DNS快多了，访问淘宝再也没有了牛皮癣。 参考文献 http://blog.antior.cn/posts/2015_29.htmlhttp://www.jianshu.com/p/71ccc79aaa9ehttp://www.linuxdown.net/install/soft/2016/0520/5566.htmlhttp://blog.cnwyhx.com/centos-linux-dnsmasq-install-dns/]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android]]></title>
    <url>%2F2016%2F07%2F17%2FAndroid%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Andorid笔记系列1234567891011121314151617181920更新2016.07.20 第一行代码Activity创建部分完成2016.07.21 完成添加了button和menu部分，对应P39页2016.07.22 完成了P55页之前的activity部分。对于activity（二）2016.08.10 基本搞定，UI除ListView以外的部分。4种布局比较熟悉，不再折腾。2016.08.11 开始ListView部分2016.08.14 停更半月2016.09.02 恢复更新2016.09.03 Broadcast部分开坑。2016.09.07 ListView部分除BaseAdapter外完成。BaseAdapter内容，什么时候理解深一点再补上。2016.09.13 完成了Broadcast对应部分2016.10.03 重新按照google的文档查漏补缺.2016.10.03 更名Android笔记，重新开始更新。2016.12.05 第二行代码开始！2016.12.07 重新整理Android系列笔记，从0整合2016.12.08 Activity部分整合完成2016.12.13 UI部分基础完成，LIstView部分完成2016.12.16 RecycleView部分，基础完成，有待进一步填坑 2016.12.22 Fragment完成，有一个占坑2016.12.23 Broadcast完成]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机课程设计总结]]></title>
    <url>%2F2016%2F07%2F09%2F%E5%8D%95%E7%89%87%E6%9C%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[累死人的单片机课程设计终于结束了，忙了两天多。就是个数码管+ADC。看看自己两年多前写的程序。。这感觉。用了一天多重构。。。。之前写程序的那个乱啊。。。重新整理下，自己的库函数。记录于此。 1602库函数1602.h1234567891011121314151617181920212223242526272829303132333435363738/*模 块 名： LCD1602 *//*创 建 人：zyy 日期：2014-11-04 *//*修 改 者：js 日期：2016-07-08 *//*版 本2.1 *//*使用方法：首先调用LCD初始化函数void LcdInit()； 输入一个double类型数据调用void LcdDisplay(double temp); 显示在第二行；如需修改第一行数据可在LcdDisplay函数中修改 *//* BUG : 第二行double数据显示最后一位后，会跟随一位乱码 */#include &lt;stc12c5a60s2.h&gt; #include &lt;intrins.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define uint unsigned int#define uchar unsigned charsbit lcdrs = P1^7;sbit lcden = P2^4;sbit rw = P1^6;#define lcd_data_port P0void sdelay(uint s); //通用延迟函数void write_com(uchar com); //并口写数据void write_data(uchar date); //并口写数据void LcdInit(); //1602初始化void LcdDisplay(double temp,uint t); //显示函数 1602.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//1602.cinclude &lt;1602.h&gt;/*模 块 名： LCD1602 *//*创 建 人：zyy 日期：2014-11-04 *//*修 改 者：js 日期：2016-07-08 *//*版 本2.1 *//**********************************************/void sdelay(uint s) //通用延迟函数&#123; uint x,y; for(x=s;x&gt;0;x--) for(y=250;y&gt;0;y--);&#125;/**********************************************/void write_com(uchar com) //并口写数据&#123; lcdrs=0; lcden=0; lcd_data_port=com; sdelay(1); lcden=1; sdelay(1); lcden=0;&#125;void write_data(uchar date) //并口写数据&#123; lcdrs=1; lcden=0; lcd_data_port=date; sdelay(1); lcden=1; sdelay(1); lcden=0;&#125;/*********************************************************************** 函 数 名: LcdInit* 功能描述: LCD初始化* 函数说明: 初始化数据：0x38 0x0c 0x06 0x01* 调用函数: sdelay（），write_com（）， write_data（）* 输 入: 无* 返 回: 无* 设 计 者：zyy 日期：2014-12-23* 版 本： 1.0***********************************************************************/void LcdInit() //1602初始化&#123; lcden=0; rw=0; write_com(0x38); write_com(0x0c); write_com(0x06); write_com(0x01);&#125;/*********************************************************************** 函 数 名: LcdDisplay* 功能描述: LCD显示* 函数说明: double类型数据转化为字符串，在lcd第二行显示。* 调用函数: sprintf(),write_com(),sdelay()* 全局变量: 无* 输 入: 一个double类型变量值* 返 回: 无* 设 计 者：zyy 日期：2014-12-23* 修 改 者：js 日期：2016-07-08* 版 本： 2.0***********************************************************************/void LcdDisplay(double temp,uint t) //显示函数&#123;static uchar table0[]=&#123;"pm "&#125;; //1602默认第一行static uchar table1[]=&#123;"00.0 "&#125;;uchar num=0;sprintf(table1,"%f",(double)temp);sprintf(table1+8,"%2d",(uint)t); write_com(0x80); for(num=0;num&lt;15;num++) //第一行刷新 &#123; write_data(table0[num]); sdelay(5); &#125; write_com(0x80+0x40); for(num=0;num&lt;16;num++) //第二行显示 &#123;write_data(table1[num]); //0.0195 sdelay(5); &#125;&#125; 数码管 对应电路图如下shu.h12345678910111213141516171819202122232425262728293031323334353637/*模 块 名： 数码管 *//*创 建 人：zy 日期：2014-07-01 *//*版 本1.2 *//*使用方法：调用 Shu_Display(double js)函数，输入一个double类型数据， 固定显示格式为小数点前4位及小数点后两位。 *//*BUG：显示小数点后第二位时，有时会与输入值小1.原因疑似与fmod()函数有关 */#include &lt;stc12c5a60s2.h&gt; #include &lt;intrins.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define uint unsigned int#define uchar unsigned char //端口定义#define io_dm P0 //定义LED显示的段码数据脚sbit io_shu = P2^3; //数码管开关低电平有效sbit io_A = P2^0; //3-8译码器输入sbit io_B = P2^1;sbit io_C = P2^2;sbit io_DP = P0^7; //dp点定义extern uchar du_num[15];void delay_1ms(uchar x); //1ms延迟函数void wei(uchar i); //位选输出函数void Shu_Display(double js);//数码管显示函数 shu.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;shu.h&gt; /*模 块 名： 数码管 *//*创 建 人：zy 日期：2014-07-01 *//*版 本1.2 *///显示数字uchar du_num[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71&#125;;// 0 1 2 3 4 5 6 7 8 9 a b c d e f void delay_1ms(uchar x)//1ms延迟函数&#123; uchar j; while(x--)&#123; for(j=0;j&lt;125;j++) &#123;;&#125; &#125; &#125;void wei(uchar i) //位选信号输入&#123; //i=i+1; switch (i) &#123; case 0:&#123;io_A=0;io_B=0;io_C=0;&#125; break; case 1:&#123;io_A=1;io_B=0;io_C=0;&#125; break; case 2:&#123;io_A=0;io_B=2;io_C=0;&#125; break; case 3:&#123;io_A=1;io_B=1;io_C=0;&#125; break; case 4:&#123;io_A=0;io_B=0;io_C=1;&#125; break; case 5:&#123;io_A=1;io_B=0;io_C=1;&#125; break; case 6:&#123;io_A=0;io_B=1;io_C=1;&#125; break; default: ; break; &#125;&#125; /*********************************************************************** 函 数 名: Shu_Display() * 功能描述: 将数字显示到数码管上，显示格式4+2* 函数说明: 段选位选，动态刷新数码管* 调用函数: delay_1ms fmod()* 全局变量: 无* 输 入: 1个double类型数据* 返 回: 无* 设 计 者：zy 日期：2014-07-01 * 修 改 者：zy 日期：2016-07-08* 版 本： 1.2***********************************************************************/void Shu_Display(double js)&#123;uchar i; //循环变量 static uchar suff[6]; //数据处理暂存数组 static uint cuff[4]; //提取各位有关 static double n=1,y; //与小数截取有关 static uint count; //暂存 y=fmod(js,n); //分离js小数部分 存在y中 count=js; //强制类型转换，取js整数部分 suff[0] = count/1000; //取千位 cuff[0] = count%1000; suff[1] = cuff[0]/100; //取百位 cuff[1] = cuff[0]%100; suff[2] = cuff[1]/10; //取十位 suff[3] = cuff[1]%10; //取个位 count = y*1000; //小数部分。扩大1000倍提取。 cuff[2] = count%1000; suff[4] = cuff[2]/100; //小数点后一位 cuff[3] = cuff[2]%100; suff[5] = cuff[3]/10; //小数点后2位 io_shu=0; //打开3-8译码器 for(i=0;i&lt;6;i++) &#123; wei(i); //位选 io_dm=du_num[suff[i]];//段选 if(i==3) io_DP=1; delay_1ms(1); //延迟 &#125; &#125;]]></content>
      <categories>
        <category>电子类</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网教程（二）——VPS优化加速]]></title>
    <url>%2F2016%2F06%2F27%2FVPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%972%2F</url>
    <content type="text"><![CDATA[12345678910更新2016.06.26 与SSR有关部分基本完成。2016.06.28 TCP优化部分完成2016.06.29 gfw.press、FinalSpeed和锐速部分基本完成。2016.12.11 重新整理相关内容，增加SSR混淆2016.12.15 增加TCP-BBR2017.01.11 整理相关内容，增加锐速配置优化 2017.03.28 更新一部分配置内容，删除无效内容2017.04.02 因91yun被爆隐私问题，删除其对应内容2017.07.03 更新大量锐速/bbr内容，移除GFW.Press和其他内容 TCP优化（非BBR适用）使用建议 建议科学上网服务器都进行一遍TCP优化 与其他加速手段兼容 使用 BBR 加速可以略过此部分(已包含) 具体步骤 适用场景：高延迟搞丢包线路 增加TCP连接数量 1nano /etc/security/limits.conf 添加两行： 12* soft nofile 51200* hard nofile 51200 保存(Ctrl + X —— y ——回车) 设置ulimit： 1ulimit -n 51200 修改内核参数适合的还是hybla（高延迟高丢包率环境）首先看一下VPS现有算法： 1sysctl net.ipv4.tcp_available_congestion_control 没有hybla时，加载hybla算法. 1/sbin/modprobe tcp_hybla 开始修改 1nano /etc/sysctl.conf 复制代码： 1234567891011121314151617181920212223#TCP配置优化(不然你自己根本不知道你在干什么)fs.file-max = 51200#提高整个系统的文件限制net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.core.netdev_max_backlog = 250000net.core.somaxconn = 4096net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_fastopen = 3net.ipv4.tcp_mem = 25600 51200 102400net.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = hybla#END OF LINE 保存(Ctrl + X —— y ——回车) 应用 1sysctl -p 重启SSR 1/etc/init.d/shadowsocks restart 锐速 介绍锐速（ServerSpeeder）加速软件是一种基于ZETATCP加速引擎的软件，只需单边部署就可以起到 显著加速效果的 TCP 加速技术。 使用建议(7.03) 除非对隐私要求特别高，加速手段首先参数锐速 与 BBR 目前不兼容，二者取其一可满足大部分需要加速场景 默认参数即可满足大部分场景，除非很慢，否则不推荐更改配置文件 锐速目前已经基本停止运营，而且母公司LotServer面向企业用户还在运营 以下提供的破解版安装方式，收集自网络。仅供个人实验使用，请支持正版。 锐速安装 安装包来自 @Vicer 感谢原作者！ 锐速一键安装包 参考 https://github.com/0oVicero0/serverSpeeser_Install 安装 1wget --no-check-certificate -qO /tmp/appex.sh "https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh" &amp;&amp; bash /tmp/appex.sh 'install' 中间提示全部输入 y 即可，等待安装完成 卸载 1wget --no-check-certificate -qO /tmp/appex.sh "https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh" &amp;&amp; bash /tmp/appex.sh 'uninstall' 常用命令 启动命令 /appex/bin/lotServer.sh start 状态查询 /appex/bin/lotServer.sh status 停止加速 /appex/bin/lotServer.sh stop 更新许可 /appex/bin/serverSpeeder.sh renewLic 重新启动 /appex/bin/serverSpeeder.sh restart (7.03)锐速配置文件优化 详细配置文档 https://github.com/0oVicero0/serverSpeeder_Install/blob/master/lotServer.pdf 配置文件在/serverspeeder/etc/config 首先确保下面3个参数开启 123rsc="1"advinacc="1"maxmode="1" rsc=”1″ #RSC 网卡驱动模式advinacc=”1″ #流量方向加速maxmode=”1″ #最大传输模式 DO vps还要开启gso 下面是一些个人测试对加速有效果的选项，请结合网络环境自行测试 杂项 initialCwndWan=“64″初始 TCP 发送窗口能够发送的数据包的数量，该值设置的高会获得更好的加速效果，但是可能会造成网络的拥塞。使用值在60以下有效果 l2wQLimit=”1024 4096″从 LAN 到 WAN 加速引擎在缓冲池充满和空闲时分别能够缓存的数据包队列的长度的上限，该值设置的高会获得更好的加速效果，但是会消耗更多的内存。w2lQLimit=”1024 4096″从 WAN 到 LAN 加速引擎在缓冲池充满和空闲时分别能够缓存的数据包队列的长度的上限，该值设置的高会获得更好的加速效果，但是会消耗更多的内存。 halfCwndMinSRtt=”500″halfCwndLossRateShift=”3″以上两个值用于判断网络拥塞，分别为延时和丢包率，丢包率默认值为 3，即1/2^3，当拥塞产生时，退出第三代 Learning-based TCP 算法，采用类似传统 TCP 的算法。此处对于高丢包的线路来说，直接设置为1，即丢包百分之50以上时，才退出Learning-based TCP 算法(这会导致高丢包线路上增加流量消耗) 修改完成后，重启锐速 1/serverspeeder/bin/serverSpeeder.sh restart FinalSpeed 介绍FinalSpeed是高速双边加速软件,可加速所有基于tcp协议的网络服务,在高丢包和高延迟环境下,仍可达到90%的物理带宽利用率,即使高峰时段也能轻松跑满带宽。可以与锐速共存。 使用建议(7.03) FinalSpeed现在已停止更新,建议作为备选加速手段 OVZ虚拟化的vps上只可用udp模式，udp在国内被封杀较严重，导致链接中断等。 安装方法 FinalSpeed现在已停止更新，官方移除了安装方法，以下安装方式来自github备份。 安装命令: 1234rm -f install_fs.shwget https://github.com/dupontjoy/customization/raw/master/Rules/Shadowsocks/Finalspeed/install_fs.shchmod +x install_fs.sh./install_fs.sh 2&gt;&amp;1 | tee install.log 一键安装完成后，vps会自动安装java环境。 卸载： 1sh /fs/stop.sh ; rm -rf /fs 设置开机启动： 12chmod +x /etc/rc.localvi /etc/rc.local 然后加入 1sh /fs/start.sh 每天晚上1点自动重启： 12crontab -e0 1 * * * sh /fs/restart.sh FinalSpeed windows客户端官方最新版本为1.2 更新日志上表明cpu占用降低30%，但是稳定性较差，时常挂掉。推荐FinalSpeed1.12测试版 个人常用版本，很稳定。 这一部分请参考一下网站。 https://blog.kuoruan.com/82.html 常用命令 启动： 1sh /fs/start.sh 停止： 1sh /fs/stop.sh 重新启动： 1sh /fs/restart.sh 运行日志： 1tail -f /fs/server.log Kcptun 小内存VPS可用(64M内存服务器稳定运行)，OVZ架构可用， Go 语言编写 使用建议(7.03) 首次使用，建议作为备选加速手段 不当配置将带来大量流量消耗 安装 Kcptun 基于 KCP 协议的 UDP 隧道，它可以将 TCP 流转换为 KCP+UDP 流。而 KCP 是一个快速可靠协议，能以比 TCP 浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。 Kcptun 服务端安装繁琐，目前没有改为Kcptun加速的需求，收集网络一部分Kcptun搭建教程供参考。 小内存福音，Kcptun Shadowsocks加速方案 https://blog.kuoruan.com/102.html Kcptun 服务端一键安装脚本,喜闻乐见的多用户支持 https://blog.kuoruan.com/110.html SSR混淆参数 作者Jessica Lynn转载自 https://plus.google.com/113582246973758055268/posts/H51ZpzwUFDK?iem=4&amp;gpawv=1&amp;hl=zh-Hans-TW 一些混淆参数（域名） 国内： sz.btfs.mail.ftn.qq.com btrace.video.qq.com ossweb-img.qq.com 1234-wyfqdku4kcgcabalp6rdudo7–1042249034.cmos.greencompute.org aecpm.alicdn.com aldh5.tmall.com at.alicdn.com atanx.alicdn.com g.alicdn.com gtms03.alicdn.com gw.alicdn.com img.alicdn.com 国外： az813057.vo.msecnd.net az817829.vo.msecnd.net azureedge.net media.gettyimages.com origin.cdn77.com TCP-BBR(7.03) BBR (Bottleneck Bandwidth and RTT)是由google工程师编写的新的 TCP 拥塞控制算法，目的是要尽量跑满带宽, 并且尽量不要有排队的情况, 加速效果不比锐速差 使用建议(7.03) 开源，高效，强烈推荐首选！ 同一线路，BBR与锐速可分别试用取舍，一般满足需求！ 修改版 BBR 更为高效 不会造成流量大量浪费 安装 开源地址 测试环境 Debian 7 x64 Vultr 启用TCP-BBR涉及VPS更换内核，所以如果步骤错误，或者VPS不兼容最新的内核，会导致无法开机等错误， 锐速不支持，更换后的 &gt;4.9 内核 安装原版BBR 脚本来自秋水逸冰 系统支持：CentOS 6+，Debian 7+，Ubuntu 12+ 虚拟技术：OpenVZ 以外的，比如 KVM、Xen、VMware 等 内存要求：≥128M 连接SSH，输入下面命令，更新内核 123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启 重连SSH 验证 内核版本 1uname -r 最新内核版本大于4.9即可，最新4.12(7.03) 修改sysctl.conf 1nano /etc/sysctl.conf 复制代码： 1234567891011121314151617181920212223#TCP配置优化(不然你自己根本不知道你在干什么)fs.file-max = 51200#提高整个系统的文件限制net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.core.netdev_max_backlog = 250000net.core.somaxconn = 4096net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_fastopen = 3net.ipv4.tcp_mem = 25600 51200 102400net.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = bbr#END OF LINE 保存(Ctrl + X —— y ——回车) 应用 1sysctl -p 重启SSR 1/etc/init.d/shadowsocks restart 修改版BBR 相对原版更为暴力，加速效果更好 提供 Vicer版 和 魔改版 两个试用后加速效果还不错的版本。 我的测试来看 魔改版 的最高速度高于 Vicer版 ，但 YOUTUBE 来看 Vicer版 高于 魔改版 注意：修改版BBR的一键脚本，支持系统较少，安装前需要确认自己的系统支持，如不在支持列表，自行Google即可，有大量第三方脚本。 支持系统： Debian 8 / Ubuntu16 + /Debian 7(需要手动安装gcc4.9) Debian 7手动安装gcc4.9(以root用户登陆，否则 命令前添加sudo) 修改系统更新源 1nano /etc/apt/sources.list 添加如下两个更新源 12deb http://ftp.cn.debian.org/debian/ jessie main non-free contribdeb http://ftp.uk.debian.org/debian/ jessie main non-free contrib 保存(Ctrl + X —— y ——回车) 执行更新apt-get update 检查可安装 gcc 版本列表apt-cache search gcc输出有gcc4.9 字样即可，数量无所谓 1234567891011121314151617181920libx32gcc-4.8-dev - GCC support library (x32 development files) cpp-4.9 - GNU C preprocessor gcc-4.9 - GNU C compiler gcc-4.9-base - GCC, the GNU Compiler Collection (base package) gcc-4.9-locales - GCC, the GNU compiler collection (native language support files) gcc-4.9-multilib - GNU C compiler (multilib files) gcc-4.9-plugin-dev - Files for GNU GCC plugin development. gcc-4.9-source - Source of the GNU Compiler Collection gccgo-4.9 - GNU Go compiler gccgo-4.9-multilib - GNU Go compiler (multilib files) gcj-4.9 - GCJ byte code and native compiler for Java(TM) gcj-4.9-jdk - GCJ and Classpath development tools for Java(TM) gcj-4.9-jre-lib - Java runtime library for use with gcj (jar files) gdc-4.9 - GNU D compiler (version 2), based on the GCC backend gfortran-4.9 - GNU Fortran compiler gfortran-4.9-multilib - GNU Fortran compiler (multilib files) gobjc++-4.9 - GNU Objective-C++ compiler gobjc++-4.9-multilib - GNU Objective-C++ compiler (multilib files) gobjc-4.9 - GNU Objective-C compiler gobjc-4.9-multilib - GNU Objective-C compiler (multilib files) 命令apt-get install g++-4.9 安装g++-4.9 Vicer版BBR 脚本来自Debian/Ubuntu TCP BBR 改进版/增强版 一键安装 1wget --no-check-certificate -qO &apos;BBR_POWERED.sh&apos; &apos;https://moeclub.org/attachment/LinuxShell/BBR_POWERED.sh&apos; &amp;&amp; chmod a+x BBR_POWERED.sh &amp;&amp; bash BBR_POWERED.sh 遇到 Error! Header not be matched by Linux Kernel. 参看Debian/Ubuntu 开启 TCP BBR 拥塞算法,依照 作者开启bbr 的脚本执行一遍即可。 遇到Error! Install gcc-4.9. debian 7 重新安装一遍 gcc-4.9 ，其他系统 执行 apt-get update 安装完成后 执行lsmod |grep &#39;bbr_powered&#39; 结果不为空,则加载模块成功 重启SSR /etc/init.d/shadowsocks restart 魔改版BBR 一键脚本 1wget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/YankeeBBR/master/bbr.sh &amp;&amp; bash bbr.sh install 之后选择重启系统，重连SSH 输入命令 bash bbr.sh start 即可完成安装 验证 sysctl net.ipv4.tcp_available_congestion_control 返回命令有 tsunami 即可。 重启SSR /etc/init.d/shadowsocks restart 结束]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网教程（一）——VPS上搭建SSR]]></title>
    <url>%2F2016%2F06%2F26%2FVPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[不再更新任何科学上网内容,各位后会无期! SSR原作者已于2017年7月清空Github仓库. GFW在进化,人却百年未有变,各位后会无期! SSR已不推荐使用 被识别? 未知 什么混淆安全? 未知 换什么? 未知 GFW接下来是什么? 未知 12345678910111213141516171819更新2016.06.26 与SSR有关部分基本完成。2016.09.29 更新SSR部分内容2016.10.09 更新SSR内容，更新Android端接入。2016.11.09 更新SSR混淆相关内容，更新SSR-Android，更新部分介绍。2016.11.20 整合一部分VPS优化内容2016.12.11 删减调整一部分内容2016.12.15 替换锐速优化为 BBR，整合TCP优化2016.12.26 更换TCP BBR 脚本，脚本来自@秋水逸冰 版本，测试通过2017.01.11 同步更新一部分SSR内容2017.02.17 同步更新，调整删减内容，降低上手难度，增加VPS测速相关内容2017.03.28 调整一部分内容，更新Vps推荐2017.04.08 新增 VPS 安全加固2017.05.24 同步更新内容，更换协议，增加新内容。2017.06.28 删减过时内容，同步更新2017.07.03 更新BBR内容，VPS测速2017.07.12 更换过时截图，修正错误。2017.07.28 更换失效链接，可能是最后一次更新了2017.10.18 更新vps内容,缩减无效信息. 安装脚本说明：遇到失效等，请留言或邮件我！ 脚本来源 @秋水逸冰ShadowsocksR一键安装脚本 隐私/后门：(这个结论仅对本文使用脚本负责)文章中所使用的脚本，除默认用户名/密码外，没有任何夹带私货。脚本亦开源，不放心可以下载后自行审计！ https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh SSR 服务器端更新：使用此一键脚本安装的，不能使用其他命令更新，只能通过 备份配置文件，卸载再重新安装！也都不是事，备份一下配置文件，重新安装，覆盖配置文件，重启即可。 基本从0开始的教程，当作自己的备份了。 吐槽作为一个伪程序员，每次最苦恼的就是Android SDK的更新，当初安装Android Studio时候就因为防火墙折腾了整整2周，简直就是把自学Android的那点耐心都磨没了。各种的搜索文档，离了google效率下降70%！科学上网简直成了程序员的必备生存技能了。 谁比较需要单独购买VPS科学上网？ 只是翻墙简单浏览网页，就不必要再单独花费人民币了，蓝灯、和各个网站的免费ss账户，是你的主菜。 偶尔看看视频、不想画太多精力在寻找免费资源上。可以直接购买现成的ss/vpn账户，在G+相应的社区可以找到很多比较靠谱的提供商。 常年泡视频网站又受不了国内视频网站乱七八糟、24h使用google服务、对稳定性和流量有一定要求、愿意使用一点时间来折腾VPS。比较适合单独购买VPS来科学上网。VPS选择如下会提及。 搜索文档，更新软件源、折腾个人网站又不想备案的、折腾开源的 这部分大神谁会来看这个啊，早自己分分钟写个轮子了 VPS选择选择VPS看那几点 一定要根据自己的具体使用场景和网络环境来选择VPS服务。 选择VPS的一般要注意的几点 自己的具体网络环境 简单来说，一般联通的国际出口稳定性大于电信、移动的国际出口看心情有的地区甩电信联通几条街，坏的时候根本没速度。电信网路比较特殊，国际出口充足，但是限速到不能忍，不挤的时候嗖嗖的，高峰期渣到爆炸.移动出口不错,但墙中墙.. 其他二级宽带商忽略不计 VPS地点。 日本VPS电信网络访问要绕道美国绕道ping一般在200到300了，（9.29）联通直连日本，ping在100！联通目前也分地区有限速。(2.17)联通因为16年年底海底光缆故障损失了30％的国际出口，导致新年到现在出口路由并不稳定，联通-日本ntt延迟有时200有时100.（6.28）目前读者反映ntt比较稳定。已放弃亚洲地区vps(10.18),不稳定相比其他地区. 美国的VPS联通/电信访问延迟基本相当。一般选择靠近美国西海岸节点旧金山、洛杉矶、纽约等地点。电信限速很厉害，所以一般电信网需要开混淆配合FinaSppeed等加速。可以选择便宜cn2线路vps,会好很多. 新加坡节点，在靠近南方地区，可以ping在100以内稳定！youtube 4k不卡。但在偏北一些地区ping不稳定 香港VPS，这个比较特殊，香港的VPS ping值可以低到20几，但是香港本身的国际出口就小，VPS价格也偏高，另外香港毕竟也在政府的直接管辖内，隐私方面风险比其他地区节点要大一些。建议土豪级别的游戏玩家使用。 VPS虚拟化架构 (具体解释请自行google，只说明对科学上网的影响) OpenVZ（简称OVZ） 便宜！但是没法进行修改内核、加锐速之类的优化操作。访问速度基本取决于你的本地网络环境优化的可能性。（不是没有可以加速的手段，就是在基本相同情况下，不如其他架构的vps可以榨干VPS的传输性能）。加速手段：Finaspeed（已停止更新） 和net-speeder。 Xen性能较好，实际用的不多，不做更多评论 Hyper-VH完美支持Windows系统，Hyper-V同样可以超售内存和硬盘，如果服务商超卖较多可能会有性能问题，Linux操作系统性能较低。 KVM全功能虚拟化架构，可上传ISO手动安装系统。KVM VPS相对其它架构的VPS较为自由。虚拟化性能比Xen略低。可以使用TCP优化和锐速，价格比一半OVZ的要高一些。（本教程以KVM为例。。速度需求大的最好使用KVM） VPS提供商 这个就比较多了，尽量选择购买人较多的，而且一般支持支付宝的服务商被国人玩半残居多（比如搬瓦工。。超售严重），所以购买不支持支付宝的vps提供商 (相对) 要靠谱一点。注册paypal国际版（注：是国际版paypal 不是国内的贝宝！）一般的vps提供商都支持paypal付款。与使用信用卡相比，具体的优惠政策不同. 支持支付宝/微信的服务商良莠不齐，第一次购买需要注意退款政策，虚拟化架构等，最好按月支付。现在使用的是洛杉矶的KVM机器，配合BBR基本3网通吃，除个别时段非常稳定。电信推荐洛杉矶C3机房,虽然为半程cn2,但足够便宜稳定. 推荐几个 VPS 的评测网站，相对更新很快。 http://www.laozuo.org/myvpshttps://doub.io/https://www.91yun.org/ VPS测速 决定科学上网质量的主要是由vps回城的线路决定. 常用VPS提供商测速地址 vultr http://www.vultrvps.com/test-server 搬瓦工 http://www.64mb.biz/tips/4ip.html 其他待更新，其实只要搜索 测速地址+vps提供商名称就好 以vultr东京节点为例 有的vps提供商只提供测速网址，而测速大多以ip地址为主，ping命令可以获取 测速网址 对应的ip地址 最简单的命令 PING (延迟测试) win+r组合键打开运行栏 输入cmd，回车 如图 输入 ping 你需要测试的ip地址 这里是 1ping hnd-jp-ping.vultr.com 应答如下 这里可以看到具体的测速ip地址为 108.61.201.151 选中 Ctrl + C复制下来 延迟141 左右，还在接受范围内。丢包大致作为参考即可，只有4个包发送，不足以作为结果注意这里的延迟只是ping检测的结果，可以作为实际访问延迟的参考值，而不是绝对准确！ 测速相关网站 查询ip地址归属地不要使用 百度搜索查询ip地址 那些数据国内尚可，vps一般对应国外网站，百度等则错误不少，推荐：ipip.net https://www.ipip.net/ip.html 全国ping检测有时ss属于合租服务器，可能在不同省份，需要评估ip到不同省份的延迟，这个时候就需要 全国范围内的ping检测首推：站长之家ping检测 http://ping.chinaz.com/ 路由追踪 Best Trace Best Trace是由 IPIP.NET 开发的路由追踪检测工具官方地址下载 路由追踪 即 检测数据 从你的本地宽带开始 到 vps 的整个过程中走的路径，例如 北京联通 到 vultr东京 从北京直接连到日本，而 河南电信到 vultr东京 则是先到美国，再去日本。 上图说话(图片来自91yun) 这款软件几乎没有上手难度 具体介绍如下 http://www.laozuo.org/8277.html 丢包率 WinMTR 具体介绍如下，91yun介绍很详细，并附带下载地址，此处就不多言了 https://www.91yun.org/zh/archives/1120 VPS自身测试（7.03） vps网络测试 https://teddysun.com/444.html vps性能测试 https://teddysun.com/245.html vps部署 我选择的是Vultr VPS。2.5刀/月，500G流量 怎么折腾都够了。 本节内容转载/删节/修正自 https://mpc2008cn.github.io/2015/10/22/vps/就是从这开始折腾的，有删减和修改。 Vultr 通过下面链接注册，你可以免费获得 10美元同时 也能帮助我获得一些奖励，谢谢！ Vultr地址 服务器选择 选择东京或者美国西海岸的服务器,速度相对比较快 操作系统 推荐选择Debian 7 x64此版本搭建SSR/锐速/bbr基本没有遇到故障其他版本也可，请自行选择 选择硬件 一个月可以免费用$5的配置,科学上网就够了，建站等需求需要更大的。 创建vps 等待完成。 VPS测试(可忽略，但是推荐进行) 你可以使用上面提到的 VPS测试软件，来查看 自己的vps到本地的 路由追踪 时候与 官方测试地址 相同，丢包率/延迟如何等 现在几乎所有的vps运营商 都有大量的国人涌入，有一点概率你开到的IP 是被 长城防火墙 阻断过，被废弃的ip。在正式搭建 科学上网 服务之前，请确保自己 VPS 的可访问性 配置securecrt(不必在意ip地址) 下载securecrt 复制服务器的IP地址,初始用户名,初始密码 securecrt连接vps 解压下载的secure crt,双击\SecureCRT_EN\SecureCRT\中的SecureCRT.exe 输入IP地址,用户名,点击connect 弹出框点击Accept&amp;Save 输入密码,勾选save password,OK 出现如图所示,标签变绿就说明连接成功啦. 部署ShadowSocksR 为什么选择SSR而不是原版的SS主要原因如下 可以直接启用chacha20加密，在移动设备上比较好使 TFO(TCP Fast Open)直接自带，减少握手次数。 二次混淆和抗重放等附加功能 shadowsocksR的相关争论在以下网址中，至于用户而言，现在ssr开源，一定的网络环境下比原版的ss稳定就够了。 一些争议如下 https://www.librehat.com/about-shadowsocks-r-and-the-security-of-shadowsocks/ SSR有关网址 (2.17)在2016.12月之前很长一段时间SSR只在 ZeroNet 中更新，17年以后到现在恢复在github上更新！望周知！**SSR已删除库，但还可以安装** ShadowsocksR github主页 https://github.com/breakwa11/shadowsocks-rss ShadowsocksR C#(windows版)下载地址 https://github.com/shadowsocksr/shadowsocksr-csharp/releases shadowsocksr-android版下载地址 https://github.com/shadowsocksr/shadowsocksr-android/releases 用到的一键安装脚本@秋水逸冰(感谢！) https://shadowsocks.be/9.html ZeroNet(目前更新状态未知) SSR-ZeroNet http://127.0.0.1:43110/shadowsocksr.bit（10.9）不安装ZeroNet，直接访问地址https://bit.no.com:43110/shadowsocksr.bit/ ZeroNet简介和接入 http://www.williamlong.info/archives/4574.html 安装SSR 复制以下代码到登陆成功的securecrt 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 如图，回车。 输入设定初始密码，也可以直接回车。 输入初始端口，也直接回车 嗯，回车 等待一段时间的滚屏，最后会提示——成功 shadowsocks.json配置文件 shadowsocks.json文件中定义SSR的访问端口，加密方式等，我们使用 WinSCP软件进行编辑修改(更为友好)，直接使用 securecrt 等工具 使用 vim 命令修改也可，此文中暂不涉及 WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。同时支持 SCP 协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件. 下载WinSCP绿色中文版。 解压缩打开winscp，保持默认配置不变，输入VPS的ip地址、用户名、密码。点击登陆。 默认在/root文件夹下，要进入/etc文件夹下找到shadowsocks.json 编辑shadowsocks.json文件 下面是一个 shadowsocks.json的注释模板直接复制粘贴 无注释版本 覆盖原始文件即可，或者在原文件上修改（建议先看一下注释，了解一下shadowsocks.json的大致内容） 参考资料网址shadowsocks.json文件各项配置说明 https://github.com/breakwa11/shadowsocks-rss/wiki/Server-Setup 混淆插件说明 https://github.com/breakwa11/shadowsocks-rss/wiki/obfs 注释 12345678910111213141516171819202122232425262728&#123; "server":"0.0.0.0", "server_ipv6":"::", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; #纯 SS 不带混淆 端口25 密码为123456. "25":"123456", #端口443，密码123456 ，protocol选择auth_chain_a。obfs选择tls1.2_ticket_auth，具体插件的介绍如下参考资料中 "443":&#123;"protocol":"auth_chain_a", "password":"123456", "obfs":"tls1.2_ticket_auth", "obfs_param":""&#125;, #注意无论怎么变化，最后一个端口设置，不带逗号！ "3389":&#123;"protocol":"auth_aes128_md5", "password":"123456", "obfs":"tls1.2_ticket_auth", "obfs_param":""&#125;#此处没有逗号！ &#125;, "timeout":400, #默认全局的加密方式，即上边各个端口的默认加密方式。一般为aes-256-cfb， 此处，选择为chacha20，移动设备性能较好。 "method":"chacha20", #protocol.协议定义插件的默认值，origin即使用原版SS协议，不混淆。即上面端口配置中，你没有设置 protocol 和 obfs 情况下，使用的默认值。 "protocol": "origin", "protocol_param": "", #protocol.协议定义插件的默认值，plain即使用原协议，不混淆。 "obfs": "plain", "obfs_param": "", "redirect": "", "dns_ipv6": true, #TCP FAST OPEN ，打开 "fast_open": true, "workers": 1&#125; 无注释版本，直接复制粘贴覆盖原始文件，或者在原文件上修改 12345678910111213141516171819202122&#123; "server":"0.0.0.0", "server_ipv6":"::", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "25":"123456", "443":&#123;"protocol":"auth_chain_a", "password":"123456", "obfs":"tls1.2_ticket_auth", "obfs_param":""&#125;, "3389":&#123;"protocol":"auth_aes128_md5", "password":"123456", "obfs":"tls1.2_ticket_auth", "obfs_param":""&#125; &#125;, "timeout":400, "method":"chacha20", "protocol": "origin", "protocol_param": "", "obfs": "plain", "obfs_param": "", "redirect": "", "dns_ipv6": true, "fast_open": true, "workers": 1&#125; 重启SSR 配置完成后，重启SSR,以root账户登陆securecrt，复制以下代码，重启ssr。 1/etc/init.d/shadowsocks restart 会提示shadowsocksr重启成功。（如图） 更新SSR vps端，需要先令存 shadowsocks.json文件。再执行卸载 1./shadowsocksR.sh uninstall 之后重新执行安装脚本即可 混淆选择(新手可略过)混淆插件简介 ShadowsocksR目前支持的混淆插件（此类型的插件用于定义加密后的通信协议）： plain ,http_simple ,http_post,random_head ,tls1.2_ticketauth 协议定义插件(用于定义加密前的协议): origin, auth_sha1, auth_sha1_v2, auth_sha1_v4, auth_aes128_md5/auth_aes128_sha1 auth_aes128_md5/auth_aes128_sha1 支持 单端口多用户，即一个端口 可以配置 几个不同的密码，稍后更新。 ShadowsocksR 协议插件文档 混淆插件选择(5.24) 通用 推荐auth_chain_a+tls1.2_ticket_auth这种组合目前混淆效果最好，有利于个人VPS的长时间使用。 （5.24）auth_chain_a可不使用用加密，即加密方式None（SSR作者语），但是吧，性能差不多的情况下，加个密没毛病。 auth_aes128_md5或auth_aes128_sha1+随意，即使使用rc4加密亦可（SSR作者语） 玩游戏，或对延迟有要求，不要使用tls1.2_ticket_auth 网络封锁/监控环境下 例如学校教育网/公司内网/广电宽带等等，封杀了BT/禁止访问网盘等等等等。 使用http_simple、http_post或tls1.2_ticket_auth 混淆访问的目标网址。再配合443/80端口通常可以解决问题。 Android (5.24)最好使用auth_chain_a。 如果之前使用的是auth_aes128_md5，推荐以auth_chain_a替换 手机运算能力较差的推荐使用auth_sha1_v4替换auth_aes128_md5 单端口多用户 适用场景:多人合租,减少vps开放端口. https://breakwa11.blogspot.ru/2017/01/shadowsocksr-mu.html?m=1 官方 ShadowsocksR单端口多用户配置方法 伪装正常网站(推荐) 适用场景最大程度减少GFW主动扫描,被发现的可能性. (伪装网站后,无法使用单端口多用户) https://doub.io/ss-jc48/ 逗比根据地的介绍，很详细，搭配最新的auth_chain_a 混淆，很好用。 http网站对应混淆选择http 或 post https 网站选择tls1.2 域名申请，免费！ https://my.freenom.com/clientarea.php DNS解析(目前国内网站 域名 CDN DNS解析 均需备案实名,故放弃) https://www.cloudflare.com/ VPS优化 详情在科学上网教程（二）——VPS优化加速 这里只提及 原版BBR BBR目前有很多修改版本，效果很好，BBR属于内核级别，不推荐新手 安装修改版BBR，内核挂掉，新手一般很难处理。 修改版BBR 详情见科学上网教程（二）——VPS优化加速 TCP优化 增加TCP连接数量 1nano /etc/security/limits.conf 添加两行： 12* soft nofile 51200* hard nofile 51200 保存(Ctrl + X —— y ——回车) 设置ulimit： 1ulimit -n 51200 TCP-BBR(推荐) 脚本来自于@秋水逸冰 敬告： 锐速不支持，更换后的 4.9及以后 内核 加速效果与具体网络状态有关 不推荐新手直接安装修改版BBR，挂掉后很难恢复。 BBR (Bottleneck Bandwidth and RTT)是由google工程师编写的新的 TCP 拥塞控制算法，目的是要尽量跑满带宽, 并且尽量不要有排队的情况, 加速效果不比锐速差，完全开源，对隐匿性要求高而无法使用锐速的人士，也可以放心使用开源地址 启用TCP-BBR涉及VPS更换内核，所以如果步骤错误，或者VPS不兼容最新的内核，会导致无法开机等错误 目前在 Vultr / DO 上测试通过。其他主机提供商，请自行测试 连接SSH，运行下面的命令 123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 提示需要重启 VPS，输入 y 并回车后重启，重连SSH 脚本会自动更新匹配的4.xx版本内核(6.28 目前是4.11），并启用TCP BBR 验证 输入 1uname -r 有4.9.0 以上就 表示 更新成功 输入 1lsmod | grep bbr 返回值有 tcpbbr 即bbr已启动。 添加一些优化内容修改sysctl.conf 1nano /etc/sysctl.conf 复制代码： 1234567891011121314151617181920212223#TCP配置优化(不然你自己根本不知道你在干什么)fs.file-max = 51200#提高整个系统的文件限制net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.core.netdev_max_backlog = 250000net.core.somaxconn = 4096net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_fastopen = 3net.ipv4.tcp_mem = 25600 51200 102400net.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = bbr#END OF LINE 保存(Ctrl + X —— y ——回车) 应用 1sysctl -p 重启SSR 1/etc/init.d/shadowsocks restart VPS安全加固( 安全性是重中之重！) 必须进行的步骤，安全性是重中之重！详情在科学上网教程（三）——VPS安全加固 shadowsocksR 客户端配置shadowsocksR C# windows版本 (6.28)最新的4.6.0客户端(注意MD5校验) 支持hosts文件实验性质，稳定后加入 shadowsocksR C# windows版本 来源于github备份。 解压ShadowsocksR-win-4.6.1.7z（以具体客户端版本为准），打开。 对应上文中SSR服务端配置输入对应端口配置，ip地址，密码等。 25端口（单SS） 443端口 3389端口 右键shadowsocks快捷图标,选择启用系统代理现在应该可以访问 谷歌了:) 使用Chrome+SwitchyOmega 推荐！！ Chrome下插件SwitchyOmega可以根据要访问的网址判断是否需要经过代理，做到智能的科学上网。并且现在这个插件的配置可以云同步，再也不用本地保存了！具体教程如下SwitchyOmega使用ss代理 http://www.ihacksoft.com/chrome-switchyomega.html 配合gfwlist https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList SSR-Android SSR-Android SSR-Android端(注意MD5校验) https://github.com/Jasper-1024/shadowsocksr-android-1/releases (12.11) ssr-android更新到3.2.7.14.版，增加auth_aes128_md5和auth_aes128_sha1,推荐更新！ (1.11)ssr-android更新到3.3.3.1推荐更新！ (2.17)ssr-android更新到3.3.4.5 推荐更新! (6.28)SSR-android更新3.4.0.5 android端使用 可以直接输入SSR配置，较为繁琐 在SSR C#版本，中输入完毕，保存。直接扫描二维码即可！二维码必须在光标移到 SSR链接 处才会出现 结束]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开端，起始。]]></title>
    <url>%2F2016%2F06%2F21%2F%E5%BC%80%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[总算是博客搭建完了，依附在github上，自己的域名什么的先不买了。 评论系统、RSS、留言、统计、访问量 基本有个独立博客的样子了。之前一直以为独立博客要花很长时间才可以完成，其实也就那些东西，真正厉害的是造轮子的人。 马上大四了，反而找到了自己的兴趣，不知道是高兴还是悲伤，做了三年的单片机最后发现最喜欢的是软件，造化弄人吧。 开始更新自己的经历和心情，基本不用担心审查和备案，反正服务器又不在国内。只能说走一步再走一步了用好剩下的时间。前路和期许很难，但是就这么熬着，总有意外的一天。]]></content>
      <categories>
        <category>随</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初入树莓派1安装系统+进入SSH]]></title>
    <url>%2F2016%2F06%2F21%2F%E5%88%9D%E5%85%A5%E6%A0%91%E8%8E%93%E6%B4%BE1----%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F%2B%E8%BF%9B%E5%85%A5SSH%2F</url>
    <content type="text"><![CDATA[为了更好的从事程序员事业、填坑linux、为学弟打下第一手资料、留下linux培训教材…… 实际就是为了搭个路由器，玩玩 入了树莓派3b +电源+外壳+sd卡—300大洋——–肉疼 树莓派系统安装 树莓派3b的耗电量还是挺大的 推荐买个2.5A的电源 系统选择 树莓派支持 数十款操作系统，一般新手推荐的是raspbian Raspbian是为树莓派设计，基于Debian的操作系统，不隶属于树莓派基金会[1]，但被列为官方支持的操作系统， Raspbian镜像地址(最好在FQ下，否则会很慢的。你要用IDM当我没说) Raspbian有两个版本，简单区别如下 RASPBIAN JESSIE WITH PIXEL带有完整的桌面体验，安装包1.4G左右 RASPBIAN JESSIE LITE没有X-server 套件，没有 Qt 和 GTK+ 的函式库。等于去掉了桌面。安装包400Mb上下。 所要用到的工具是： 1.多功能读卡器一个 2.TF卡一张（4G以上） 烧写器官方推荐是win32diskimager但是文件路径不支持中文。 个人推荐 USB Image Tool故障率最低的是1.7版本。 插上读卡器，烧写系统开始！ 烧写系统 打开USB Image Tool注意左上角是Device Mode，不是Volume Mode！ 选择下载后解压的img文件 写入等待进度条完成即可。 错误原因 USB Image Tool 在win7以上系统中必须要以管理员权限运行 USB Image Tool运行需要.net环境 直接使用系统默认加载的即可。 烧写完成后接入电源 进入SSH管理（没有显示设备时） 第一次进入系统时直接利用网线接入路由器，将电脑接入同一个wifi下。在路由器管理界面查找树莓派对应得IP地址。也可以扫描一下局域网设备中开启22端口的设备. 使用SSH管理工具，这里以putty为例。打开软件，填入树莓派ip地址。 打开软件，填入树莓派ip地址。默认登陆界面 默认用户名pi 密码raspberry。 登陆成功！ 参考 http://blog.csdn.net/longerzone/article/details/36034619]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F06%2F18%2Fhellowworld%2F</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>随</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Linux</tag>
        <tag>VPS</tag>
        <tag>python</tag>
        <tag>单片机</tag>
        <tag>开源</tag>
      </tags>
  </entry>
</search>
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux内核C语言中的面向对象]]></title>
    <url>%2F2017%2F07%2F11%2FLinux%E5%86%85%E6%A0%B8C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[转载自”Blog of UnicornX” (http://unicornx.github.io/) 面向对象的思想在c语言中的应用，第一次看到才知道c语言还能这么用。。。 封装 封装的定义是在程序上隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。 最早C++里面的封装是从C中的头文件规则衍生出来的。其关键在于对于一个公共数据操作方法的归类。如果一个公共变量，被很多个C 函数修改，如下图：]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—乐联网上传数据 TCP长连接总结]]></title>
    <url>%2F2017%2F06%2F11%2FAndroid%E7%AC%94%E8%AE%B0-%E4%B9%90%E8%81%94%E7%BD%91%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%20TCP%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[资料来源如下 乐联网 编程环境 Android Studio 2.2.3 导语 毕设中的乐联网部分,记录以供复习 开源在github上 https://github.com/Jasper-1024/HbuLeWei 最终效果 使用okhttp上传数据。 Tcp长连接实现方向控制 以代码为主 相关教程 okhttp入门 http://blog.csdn.net/biezhihua/article/details/50603624 乐联网 https://www.lewei50.com/dev/doc/176https://www.lewei50.com/dev/doc/155 Tcp长连接 http://ls15114843569.blog.51cto.com/11015399/1767195 简易上传 http://ls15114843569.blog.51cto.com/11015399/1767195 上传数据 API介绍 https://www.lewei50.com/dev/apiinfo/3 API测试 https://www.lewei50.com/dev/apitest/3 地址：http://www.lewei50.com/api/v1/gateway/updatesensors/你的网关号 POST方式 需要配置header头 Userkey 数据发送/返回方式JSON 12345678910[ &#123; "Name":"T1", "Value":"1" &#125;, &#123; "Name":"01H1", "Value":"96.2" &#125;] 返回格式 1234&#123; "Successful": true, "Message": null&#125; okhttp POST 传感器数据 这里使用了一个静态内部类。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 //返回数据处理 public okhttp3.Callback callback = new okhttp3.Callback() &#123; @Override public void onResponse(Call call, Response response) throws IOException &#123; //返回服务器内容 String responsedata = response.body().string(); LogUtil.d("okHttp", responsedata); &#125; @Override public void onFailure(Call call, IOException e) &#123; //异常处理 LogUtil.d("okHttp", "POST错误"); &#125; &#125;;//内部类 public static class Http &#123; public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");//POST数据，指定接收回掉 public static void postData(String sensor_name, String sensor_data, okhttp3.Callback callback) &#123; OkHttpClient client = new OkHttpClient(); final String value = "[" + " &#123;" + " \"Name\":\"" + sensor_name + "\"," + " \"Value\":\"" + sensor_data + "\"" + " &#125;" + "]"; RequestBody requestBody = new RequestBody() &#123; @Override public MediaType contentType() &#123; return MEDIA_TYPE_MARKDOWN; &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; sink.write(value.getBytes()); &#125; &#125;; Request request = new Request.Builder() .url("http://www.lewei50.com/api/V1/gateway/UpdateSensors/01") .header("userkey", "你的userkey") .post(requestBody) .build(); client.newCall(request).enqueue(callback); &#125; &#125; 实际使用 放在一个后台服务内，调用相当简单1Http.postData("PM2.5", "你的数据转为String", callback); Tcp长连接，远程控制 首先参考乐联网反向控制教程，新建一个控制器，这里以开关为例。 原理是与服务器保持一个TCP长连接，不到40s刷新一次，以此保持通道，与被控制段通信，发送控制信息。 Tcp长连接参考了@墨迹流韶的Android基于Tcp协议的Socket长链接封装 地址 tcp.lewei50.com端口号 9960心跳包间隔 1min以内 发送/接收数据格式 Json本地发送数据格式 123456789&#123; "method": "update", "gatewayNo": "你的网关号", "userkey": "你的userkey"&#125;&amp;^! 服务器发送控制命令格式，数据处理时需要去掉字符串最后的&amp;^! 12345678910111213141516&#123;"method":"send","gatewayNo":"01","userkey":"6d16ddb3c58c4e448a7e15e7acxxxxxx","f":" updateSensor","p1":"D1","p2":"1"&#125;&amp;^! 本地响应控制命令后返回数据格式 12345678910111213141516171819&#123;"method":"response","result":&#123; "successful":true, "message":"ok!", "data":[&#123; "id":"D1", "value":"1" &#125;, &#125;&amp;^! TCP连接类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class TcpSocketHelper &#123; private String mTag = "TcpSocketHelper"; private Socket socket; private boolean _connect; private ReceiveThread mReceiveThread; private boolean receiveStop; private Date lastKeepAliveOkTime; private OnRecivedListener mRecivedListener; //地址 private String mIpAddr = "http://tcp.lewei50.com"; //端口 private int mPort = 9960; /** * 开启链接socket * @param ipAddr * @param port */ public void startConnect(String ipAddr, int port)&#123; LogUtil.d(mTag, "准备链接..."); this.mIpAddr = ipAddr; this.mPort = port; InetAddress serverAddr; try &#123; socket = new Socket(ipAddr, port); LogUtil.d(mTag, "准备链接..."); _connect = true; mReceiveThread = new ReceiveThread(); receiveStop = false; mReceiveThread.start(); LogUtil.d(mTag, "链接成功..."); &#125; catch (Exception e) &#123; LogUtil.d(mTag, "链接出错..." + e.getMessage()); e.printStackTrace(); &#125; &#125; /** * 关闭链接 */ public void closeConnect()&#123; if (socket != null)&#123; try &#123; socket.close(); socket = null; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 保持心跳 */ public void KeepAlive() &#123; // 判断socket是否已断开,断开就重连 if (lastKeepAliveOkTime != null) &#123; LogUtil.d(mTag, "上次心跳成功时间:"+ DateFormat.format("yyyy-MM-dd HH:mm:ss", lastKeepAliveOkTime)); Date now = Calendar.getInstance().getTime(); long between = (now.getTime() - lastKeepAliveOkTime.getTime());// 得到两者的毫秒数 if (between &gt; 60 * 1000) &#123; LogUtil.d(mTag, "心跳异常超过40,重新连接:"); lastKeepAliveOkTime = null; socket = null; &#125; &#125; else &#123; lastKeepAliveOkTime = Calendar.getInstance().getTime(); &#125; if (!checkIsAlive()) &#123; LogUtil.d(mTag, "链接已断开,重新连接."); startConnect(mIpAddr, mPort); &#125; &#125; /** * 此方法是检测是否连接 * @return */ public boolean checkIsAlive() &#123; if (socket == null||!socket.isConnected()) return false; return true; &#125; /** * 发送数据的方法 * @param msg */ public void sendmessage(String msg) &#123; boolean isAlive = checkIsAlive(); if (!isAlive) return; LogUtil.d(mTag, "准备发送消息:" + msg); try &#123; if (socket != null &amp;&amp; socket.isConnected()) &#123; if (!socket.isOutputShutdown()) &#123; //2.得到socket读写流 OutputStream os=socket.getOutputStream(); //true:是否自动flush PrintWriter outStream=new PrintWriter(os, true); outStream.print(msg); outStream.flush(); &#125; &#125; LogUtil.d(mTag, "发送成功!"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 设置接收数据监听器 * @param mRecivedListener */ public void setmRecivedListener(OnRecivedListener mRecivedListener) &#123; this.mRecivedListener = mRecivedListener; &#125; /** * 数据接收线程 */ class ReceiveThread extends Thread&#123; @Override public void run() &#123; while (true) &#123; try &#123; sleep(2000); // 判断 Socket 是否处于连接状态 if (socket != null &amp;&amp; socket.isConnected()) &#123; // 客户端接收服务器端的响应，读取服务器端向客户端的输入流 InputStream isRead = socket.getInputStream(); // 缓冲区 byte[] buffer = new byte[isRead.available()]; // 读取缓冲区 isRead.read(buffer); // 转换为字符串 String responseInfo = new String(buffer); // 日志中输出 if(responseInfo != null&amp;&amp;!responseInfo.equals(""))&#123; LogUtil.d("TcpManager", "返回："+responseInfo); mRecivedListener.onRecived(responseInfo); &#125; lastKeepAliveOkTime = Calendar.getInstance().getTime(); KeepAlive(); continue; &#125; else &#123; if (socket != null) LogUtil.d(mTag, "链接状态:" + socket.isConnected()); &#125; &#125; catch (Exception e) &#123; LogUtil.d(mTag, "监听出错:" + e.toString()); e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 使用,包装在一个后台service中，在service中实现TcpSocketHelper的onRecived方法 1234567891011 //tcp返回信息 @Override public void onRecived(String data) &#123; LogUtil.d(&quot;okHttpService&quot;, data); //处理服务器发回的数据 &#125;TcpSocketHelper tcpSocketHelper = new TcpSocketHelper();tcpSocketHelper.startConnect(&quot;tcp.lewei50.com&quot;, 9960);//设置监听tcpSocketHelper.setmRecivedListener(this); 发送心跳包12345678String value = " &#123;" + " \"method\":\"update\"," + " \"gatewayNo\":\"01\"," + " \"userkey\":\"你的userkey\"" + " &#125;&amp;^!"; //发送数据 tcpSocketHelper.sendmessage(value); 处理数据 在service的onRecived中 本地处理完毕后，向服务器返回被控制器状态 123String value5 = "&#123;\"method\":\"response\",\"result\":&#123;\"successful\":true,\"message\":\"ok!\",\"data\":[&#123;\"id\":\"D1\",\"value \":\"1\"&#125;]&#125;&#125;&amp;^! "; tcpSocketHelper.sendmessage(value6);]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
        <tag>毕设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记-自用MVP框架]]></title>
    <url>%2F2017%2F05%2F08%2FAndroid%E7%AC%94%E8%AE%B0-%E8%87%AA%E7%94%A8MVP%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[资料来源如下 网络 编程环境 Android Studio 2.2.3 导语 转眼刚用上手的MVP又不符合需求了，还是总结一下，继续MVVM吧。 起 主要内容是转载，搭建小工程应该足够了。Android mvp 架构的自述如何更高效的使用MVP以及官方MVP架构解析 框架开源在GitHub 地址点我直达 好，我们开始吧！ MVC MVP MVVM 省略200行，详情看Android App的设计架构：MVC,MVP,MVVM与架构经验谈 再累赘属于掉书袋了，作者写的是很用心，恩，MVVM也有。 框架详解 整个框架截图 整体层次比较明确了，BaseClass 里存放基类，Model层存放数据存储有关类、Presenter层存放逻辑代码、View层存放Activity、frament等。 这个框架是由MVP在Android中应用存在的问题而搭建的，基类中代码也由此而来。 问题 presenter一直持有Activity对象导致的内存泄漏问题 使用mvp的时候，presenter会持有view，如果presenter有后台异步的长时间的动作，比如网络请求，这时如果返回退出了Activity，后台异步的动作不会立即停止，这里就会有内存泄漏的隐患。 需要一个销毁view的方法，这里是在基类中完成的。 presenter绑定和解绑繁琐 一般一个presenter对应一个Activity，一般应用内存在多个Actiivity，绑定与解绑相当繁琐。 统一在 Basepresenter 与 BaseActivity中进行，同时解决内存泄漏问题，还有其他常用内容一并添加。 presenter 与 Model 的通信问题。 presenter已经与View层 强耦合了，框架中需要解耦presenter 与 Model ，使用异步通信。Handle等都太复杂了。。。 开始没有什么好的解决办法，直到遇到了EventBus，当然EventBus也不是万能解决方案，跨进程，还是要另辟蹊径，不过EventBus足够自己写着完了。还有Rxjava，恩，还在玩着，没搞太懂。 代码 BasePresenter123456789101112 public abstract class BasePresenter&lt;Viewinterface&gt; &#123; //传入泛型 public Viewinterface mView; //绑定 public void attach(Viewinterface mView) &#123; this.mView = mView; &#125; //解绑，防止view为空是内存泄漏 public void dettach() &#123; mView = null; &#125;&#125; BaseActivity1234567891011121314151617181920212223242526272829303132 public abstract class BaseActivity &lt;Viewinterface,mPresenter extends BasePresenter&lt;Viewinterface&gt;&gt;extends AppCompatActivity &#123; //获取Presenter对象 public mPresenter mpresenter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //Presenter实例化 mpresenter = initPresenter(); //打印当前activity LogUtil.d("Activity", getClass().getSimpleName()+"onCreate"); &#125; @Override protected void onResume() &#123; //重新刷新时重新绑定view mpresenter.attach((Viewinterface) this); super.onResume(); LogUtil.d("Activity", getClass().getSimpleName()+"onResume"); &#125; @Override protected void onDestroy() &#123; //解绑presenter持有的view mpresenter.dettach(); super.onDestroy(); LogUtil.d("Activity", getClass().getSimpleName()+"onDestroy"); &#125; public abstract mPresenter initPresenter();&#125; Presenter12 public interface Presenter &#123;&#125; mPresenter12345678 public class mPresenter extends BasePresenter&lt;Viewif&gt; implements Presenter &#123; private Model mModel; public mPresenter(Viewif view) &#123; this.attach(view); this.mModel = new mModel(); &#125;&#125; BaseView 123 public interface BaseView&lt;T&gt; &#123;&#125; Viewif 123 public interface Viewif extends BaseView &#123;&#125; MainActivity12345678910111213141516 public class MainActivity extends BaseActivity&lt;Viewif, mPresenter&gt; implements Viewif&#123; Presenter presenter; //Presenter初始化 public mPresenter initPresenter() &#123; return new mPresenter(this); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; //presenter初始化 presenter = mpresenter; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; LogUtil123456789101112131415161718192021222324252627282930313233343536373839 public class LogUtil &#123; public static final int VERBOSE = 1;//啰嗦，等级最低的 public static final int DEBUG = 2;//调试 public static final int INFO = 3;//信息 public static final int WARN = 4;//警告 public static final int ERROR = 5;//错误 public static final int NOTHING = 6;//什么也不打印出来 public static final int level = VERBOSE;//LEVEL:标准 public static void v(String tag, String msg) &#123; if (level &lt;= VERBOSE) &#123;//如果大于或者等于定义的标准就打印出来 Log.v(tag, msg); &#125; &#125; public static void d(String tag, String msg) &#123; if (level &lt;= DEBUG) &#123; Log.d(tag, msg); &#125; &#125; public static void i(String tag, String msg) &#123; if (level &lt;= INFO) &#123; Log.i(tag, msg); &#125; &#125; public static void w(String tag, String msg) &#123; if (level &lt;= WARN) &#123; Log.w(tag, msg); &#125; &#125; public static void e(String tag, String msg) &#123; if (level &lt;= ERROR) &#123; Log.e(tag, msg); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—蓝牙串口(BlueTooth+EventBus)]]></title>
    <url>%2F2017%2F04%2F17%2FAndroid%E7%AC%94%E8%AE%B0-%E8%93%9D%E7%89%99%E4%B8%B2%E5%8F%A3%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88BlueTooth%2BEventBus%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) 编程环境 Android Studio 2.2.3 导语 毕设中的蓝牙部分,记录以供复习 概述最终效果 Android应用 与 Hc-05 蓝牙模块连接,单片机与 Android 端 可以通过串口正常收发数据. 预留足够灵活的接口, Android 应用中可以在任意位置获取到蓝牙数据 Activity切换时,蓝牙连接不断开. 用到的开源库/知识点资料 简介/来源 蓝牙:Android API 指南 https://developer.android.com/guide/topics/connectivity/bluetooth.html EventBus:EventBus-GitHub 是一个Android端优化的publish/subscribe消息总线,用来替代 Intent 、 Handler 、 Broadcast 等在 Actvity 、 Fragment 、 Service 等组件之间传递信息 . EventBus 可以传递一个完整的对象,简单高效, 注意 EventBus 只能在多线程之间传递消息,无法在不同进程之间传递消息 ,EventBus 3.0 以后进一步简化了传递方式,真的是很值得学习的一个开源库! 参考资料如下: EventBus 3.0初探: 入门使用及其使用 完全解析 EventBus3(3.0.0)源码解析 基础部分 蓝牙 与 EventBus 基础部分 BlueTooth 备注 : 这里使用的是 传统蓝牙 即 蓝牙4.0以前版本, 而不是 蓝牙4.0 ( ble低功耗蓝牙)及以后版本 Android 对 Bluetooth 做了很好的封装,我们可以比较轻松的在 Android Bluetooth API 上进行开发. Android中所有蓝牙API均来自 android.bluetooth 包 BlueTooth基础 BluetoothAdapter 本地蓝牙适配器BluetoothAdapter 是所有蓝牙交互的入口点, 在初始化蓝牙及蓝牙配对阶段使用1.发现其他蓝牙设备2.查询绑定（配对）设备的列表3.使用已知的 MAC 地址实例化 BluetoothDevice4.创建 BluetoothServerSocket 侦听来自其他设备的通信。 BluetoothDevice 远程蓝牙设备含有该设备的信息，例如设备的名称、地址、类和绑定状态等。 BluetoothSocket 蓝牙套接字接口（与 TCP Socket 相似）与 BluetoothDevice 配合建立远程连接,允许应用通过 InputStream 和 OutputStream 与其他蓝牙设备交换数据. 初始化蓝牙 声明蓝牙权限Android 应用使用蓝牙前都需要声明蓝牙权限一般只需要 BLUETOOTH 权限即可,但是考虑到之后有更多的需求,需要更改系统蓝牙设置,由此需要 BLUETOOTHADMIN 权限也一起声明 12345&lt;manifest ... &gt;&lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;...&lt;/manifest&gt; 蓝牙设备可用性 获取 BluetoothAdapter获取 BluetoothAdapter，需要静态 getDefaultAdapter() 方法。getDefaultAdapter() 会返回一个表示设备自身的蓝牙适配器的 BluetoothAdapter 设备不支持蓝牙 则返回 null 1234BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();if (mBluetoothAdapter == null) &#123; // 蓝牙不可用操作&#125; 开启蓝牙BluetoothAdapter 的 .isEnabled() 可以判断系统蓝牙是否开启.没有开启时 startActivityForResult() 发送包含 ACTION_REQUEST_ENABLE 的 Intent 请求系统开启蓝牙,并在 onActivityResult() 返回的数据中 RESULT_CANCELED 表示开启失败 RESULT_OK 表示开启成功,这里我们只检测开启失败情况,并提示用户 1234567891011121314if (!mBluetoothAdapter.isEnabled()) &#123; Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);&#125; protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == REQUEST_ENABLE_BT &amp;&amp; resultCode == RESULT_CANCELED) &#123; Toast.makeText(MyApplication.getContext(),R.string.Bluetooth_openfail, Toast.LENGTH_SHORT).show(); &#125; BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); if (mBluetoothAdapter == null) &#123; //设备不支持蓝牙时处理 &#125; &#125; 查询已配对的设备调用 getBondedDevices(),返回已配对设备的一组 BluetoothDevice.之后使用for循环遍历 123456789Set&lt;BluetoothDevice&gt; pairedDevices = mBluetoothAdapter.getBondedDevices();if (pairedDevices.size() &gt; 0) &#123; //重新加载bluetoothDeviceList bluetoothDeviceList.clear(); //BluetoothDevice列表循环 for (BluetoothDevice device : pairedDevices) &#123; bluetoothDeviceList.add(device); &#125; &#125; 扫描设备查找设备是非常耗费系统资源的事项，需要安排在子线程中执行，这里没有用到，由需要请参考Google官方蓝牙教程 连接设备蓝牙分主从机，链接为服务器/客户端。这里使用的是连接为客户端。 首先获取远程设备的 BluetoothDevice 对象，即在选择设备阶段的BluetoothDevice 调用 createRfcommSocketToServiceRecord(UUID) 获取 BluetoothSocket，UUID通用唯一识别码 在蓝牙中具体是什么没有很好的解释。这里的值取的是&quot;00001101-0000-1000-8000-00805F9B34FB&quot; 调用 connect() 发起连接,阻塞调用，需要在子线程中执行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//蓝牙连接子线程private class ConnectThread extends Thread &#123; private final BluetoothSocket mmSocket; //解析函数 ConnectThread(BluetoothDevice bluetoothDevice) &#123; // 使用一个中间变量 tmp // mmSocket 类型是 final BluetoothSocket tmp = null; // 获取 BluetoothSocket try &#123; // MY_UUID is the app's UUID string, also used by the server code tmp = bluetoothDevice.createRfcommSocketToServiceRecord(UUID.fromString(MyApplication.MY_UUID)); &#125; catch (IOException ignored) &#123; &#125; //赋值给 mmSocket mmSocket = tmp; &#125; public void run() &#123; // 关闭蓝牙扫描 MyApplication.getBluetoothAdapter().cancelDiscovery(); try &#123; // 通过 socket 连接到设备. connect() 会一直执行直到成功连接或者抛出异常 mmSocket.connect(); &#125; catch (IOException connectException) &#123; //无法连接到蓝牙,关闭连接并退出 try &#123; mmSocket.close(); &#125; //没有正常关闭 catch (IOException ignored) &#123; &#125; return; &#125; // Do work to manage the connection (in a separate thread) mConnectedThread = new ConnectedThread(mmSocket); mConnectedThread.start(); &#125; /** * 关闭蓝牙连接 */ void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException ignored) &#123; &#125; &#125;&#125; 管理连接获取BluetoothSocket获取 InputStream 和 OutputStream， getInputStream() 和 getOutputStream() 来处理数据传输。read(byte[]) 和 write(byte[]) 读取数据并写入到流式传输。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private class ConnectedThread extends Thread &#123; //BluetoothSocket private final BluetoothSocket mmSocket; //输入流 private final InputStream mmInStream; //输出流 private final OutputStream mmOutStream; ConnectedThread(BluetoothSocket socket) &#123; //传入BluetoothSocket，实例化mmSocket mmSocket = socket; //输入/输出流 中间变量 InputStream tmpIn = null; OutputStream tmpOut = null; // 输入输出流实例化 try &#123; tmpIn = socket.getInputStream(); tmpOut = socket.getOutputStream(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; mmInStream = tmpIn; mmOutStream = tmpOut; &#125; public void run() &#123; byte[] buffer = new byte[1024]; int bytes; // 连接成功时 while (true) &#123; try &#123; // 在InputStream读数据 bytes = mmInStream.read(); //发送数据 Events.bluetooth_Recycle bluetooth_recycle = new Events.bluetooth_Recycle(); bluetooth_recycle.s = bytes; bluetooth_recycle.bytes = String.valueOf((char) bytes); EventBus.getDefault().post(bluetooth_recycle); &#125; catch (IOException e) &#123; break; &#125; &#125; &#125; //写方法 void write(byte[] bytes) &#123; try &#123; mmOutStream.write(bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //关闭流连接 void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; EventBus 直接放链接了 http://www.jianshu.com/p/a040955194fchttp://www.jianshu.com/p/acfe78296bb5http://www.ff50.net/view/40565212977623506063.html 正文 蓝牙连接子线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 private class ConnectThread extends Thread &#123; private final BluetoothSocket mmSocket; //解析函数 ConnectThread(BluetoothDevice bluetoothDevice) &#123; // 使用一个中间变量 tmp // mmSocket 类型是 final BluetoothSocket tmp = null; // 获取 BluetoothSocket try &#123; // MY_UUID is the app's UUID string, also used by the server code tmp = bluetoothDevice.createRfcommSocketToServiceRecord(UUID.fromString(MyApplication.MY_UUID)); &#125; catch (IOException ignored) &#123; &#125; //赋值给 mmSocket mmSocket = tmp; &#125; public void run() &#123; // 关闭蓝牙扫描 MyApplication.getBluetoothAdapter().cancelDiscovery(); try &#123; // 通过 socket 连接到设备. connect() 会一直执行直到成功连接或者抛出异常 mmSocket.connect(); &#125; catch (IOException connectException) &#123; //无法连接到蓝牙,关闭连接并退出 try &#123; mmSocket.close(); &#125; //没有正常关闭 catch (IOException ignored) &#123; &#125; return; &#125; // Do work to manage the connection (in a separate thread) mConnectedThread = new ConnectedThread(mmSocket); mConnectedThread.start(); &#125; /** * 关闭蓝牙连接 */ void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException ignored) &#123; &#125; &#125;&#125; 管理连接子线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 //管理连接子线程private class ConnectedThread extends Thread &#123; //BluetoothSocket private final BluetoothSocket mmSocket; //输入流 private final InputStream mmInStream; //输出流 private final OutputStream mmOutStream; ConnectedThread(BluetoothSocket socket) &#123; //传入BluetoothSocket，实例化mmSocket mmSocket = socket; //输入/输出流 中间变量 InputStream tmpIn = null; OutputStream tmpOut = null; // 输入输出流实例化 try &#123; tmpIn = socket.getInputStream(); tmpOut = socket.getOutputStream(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; mmInStream = tmpIn; mmOutStream = tmpOut; &#125; public void run() &#123; byte[] buffer = new byte[1024]; int bytes; // 连接成功时 while (true) &#123; try &#123; // 在InputStream读数据 bytes = mmInStream.read(); //发送数据 Events.bluetooth_Recycle bluetooth_recycle = new Events.bluetooth_Recycle(); bluetooth_recycle.s = bytes; bluetooth_recycle.bytes = String.valueOf((char) bytes); EventBus.getDefault().post(bluetooth_recycle); &#125; catch (IOException e) &#123; break; &#125; &#125; &#125; //写方法 void write(byte[] bytes) &#123; try &#123; mmOutStream.write(bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //关闭流连接 void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException e) &#123; &#125; &#125;&#125; 连接蓝牙123456789//连接线程private ConnectThread mConnectThread;//管理连接进程private ConnectedThread mConnectedThread;//创建连接子线程mConnectThread = new ConnectThread(bluetoothDevice);//启动连接子线程mConnectThread.start(); 向蓝牙写入数据1234567 //发送数据String, 主线程 优先级4 非粘性事件@Subscribe(threadMode = ThreadMode.MAIN, priority = 4, sticky = false)public void onEvent(Events.bluetooth_Send bluetoothSend) &#123; String bytes = bluetoothSend.bytes; mConnectedThread.write(bytes.getBytes()); LogUtil.d(Tag, "onEvent:Send" + bluetoothSend.bytes);&#125; 接收数据处理123456 //数据转换 后台进程 优先级3 非粘性事件@Subscribe(threadMode = ThreadMode.BACKGROUND, priority = 3, sticky = false)public void onEvent(Events.bluetooth_Transformers bluetoothTransformers) &#123; int bytes = bluetoothTransformers.bytes; //处理数据&#125;]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
        <tag>毕设</tag>
        <tag>BlueTooth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网教程（三）——VPS安全加固]]></title>
    <url>%2F2017%2F04%2F08%2FVPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B3%2F</url>
    <content type="text"><![CDATA[12更新2017.04.08 VPS日常一些安全措施 导语科学上网教程系列，很久没有更新新内容了。更新常用安全措施，至少保证，不会被轻易的当作肉鸡。都是一些常用的安全措施。 系统环境：CentOS SSH 有两种方案 彻底关闭SSH登陆，改为密钥登陆，安全性最高，但配置较为复杂 修改SSH登陆端口，同时开放默认端口，将爆破 ssh 密码的 IP 封停密钥登陆 主要步骤在这里,有时间再更新 https://ttt.tt/104/ 修改端口 命令 如下，以下是将 SSH 端口改为 999 端口 1sed -i &apos;s/#Port 22/Port 999/g&apos; /etc/ssh/sshd_config 安装 fail2ban 封掉 暴力破解ip fail2ban fail2ban 是 Linux 上的一个著名的入侵保护的开源框架，它会监控多个系统的日志文件，并根据检测到的任何可疑的行为自动触发不同的防御动作。将尝试爆破 ssh 密码的 IP 封停，默认10分钟。 详细配置安装方法在如下网址，这里使用默认配置即可。 https://linux.cn/article-5067-1.html 安装 fail2banCentOS 需要提前 设置 EPEL 仓库 以 root 用户登陆，非 root 用户需要 命令前 增加 sudo 安装命令 1234//CentOSyum install fail2ban//Debian / ubuntuapt-get install fail2ban 其他命令 重启 1service fail2ban restart 验证状态 1fail2ban-client ping 返回 1Server replied: pong 设置开机自启动 1234// CentOS/RHEL 6chkconfig fail2ban on// CentOS/RHEL 7systemctl enable fail2ban 禁用Linux多余端口 关闭多余端口是永远正确的选择！只留下常用端口 和 SSR端口 配置 iptables 警告 iptables 配置不是一般的复杂，谨慎操作 清空默认规则 1iptables -F 允许22端口，给暴力破解留点空间 //doge 12iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT 允许53端口 udp ，一般用做DNS服务器，如果你不需要则忽略此条 12iptables -A OUTPUT -p udp --dport 53 -j ACCEPTiptables -A INPUT -p udp --sport 53 -j ACCEPT 允许本机访问本机 12iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPTiptables -A OUTPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT 允许真正 SSH 端口 12iptables -A INPUT -p tcp -s 0/0 --dport 999 -j ACCEPTiptables -A OUTPUT -p tcp --sport 99 -m state --state ESTABLISHED -j ACCEPT 允许 80 443 端口，http 和 https 1234iptables -A INPUT -p tcp -s 0/0 --dport 80 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPTiptables -A INPUT -p tcp -s 0/0 --dport 443 -j ACCEPTiptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT 允许 SSR端口 以888 xxx 为例 你有几个端口，就添加几个 12345iptables -A INPUT -p tcp -s 0/0 --dport 888 -j ACCEPTiptables -A OUTPUT -p tcp --sport 888 -m state --state ESTABLISHED -j ACCEPTiptables -A INPUT -p tcp -s 0/0 --dport xxx -j ACCEPTiptables -A OUTPUT -p tcp --sport xxx -m state --state ESTABLISHED -j ACCEPT 保存配置 1iptables-save &gt; /etc/sysconfig/iptables 重载 iptables 1iptables -L 安装 CSF 防火墙 命令1234567rm -fv csf.tgzwget http://download.configserver.com/csf.tgztar -xzf csf.tgzcd csfsh install.sh//使用下边的命令来验证csf正确安装并已经运行perl /usr/local/csf/bin/csftest.pl]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—仿绿色守护嗜睡模式通知]]></title>
    <url>%2F2017%2F03%2F07%2FAndroid%E7%AC%94%E8%AE%B0%E2%80%94%E4%BB%BF%E7%BB%BF%E8%89%B2%E5%AE%88%E6%8A%A4%E5%97%9C%E7%9D%A1%E6%A8%A1%E5%BC%8F%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) Android Training Notifying the User Android API 通知 【Android】状态栏通知Notification、NotificationManager详解 编程环境 Android Studio 2.2.3 导语 OneTapDoze遇到的第一个难题，顺带记录Android 通知相关内容 最终效果 绿色守护进入doze模式后，会在通知栏创建一个计时通知 如下图 退出doze模式后，会指示进入doze和退出doze的时间段。 我们要仿照的样式就是这样，进入退出doze，对应创建通知的代码都在doze模式改变的Broadcast中。 基础部分创建通知 行文前：Android每次版本几乎都会有通知API的改动，不同版本之间通知兼容性很是问题，为此我们使用support_v7 库中的NotificationCompat.Builder代替Notification.Builder二者使用方式相同 涉及到的两个类 NotificationManager Notification (support库中对应NotificationCompat) NotificationManager 状态栏通知的管理类，负责发通知、清除通知等 NotificationManager 是一个系统Service，必须通过 getSystemService()方法来获取 Notification 具体的状态栏通知对象，可以设置icon、文字、提示声音、振动等参数 一个Builder对象至少包含三个方面 一个小图标，通过setSmallIcon()方法设置。 通知标题，通过setContentTitle()方法设置。 详细文本，通过setContentText()方法设置。 简单示例 创建通知构建器 代码 123456Notification notification = new NotificationCompat.Builder(this) .setContentTitle("这是通知标题") .setContentText("这是通知内容") //这里使用的是应用图标，一般没人这么干，就是为了方便 .setSmallIcon(R.mipmap.ic_launcher) .build(); 发布通知 获得NotificationManager的实例 使用notify()方法发布通知。在调用notify()方法 指定通知的ID，(ID用于通知更新) 加载Notification实例 1234int mNotificationId = 001;NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);manager.notify(mNotificationId, notification); 效果如下 android 7.0 / 6.0 /4.0 通过 更新通知 可以创建一个全新的NotificationCompat对象，也可以在原NotificationCompat对象基础上修改，最后只要 .notify 方法中对应同一个 mNotificationId ，系统就会自动更新已有通知，代码不在累赘。 基础部分到此，足矣 正题 实现时间段的显示，肯定会保存系统进入doze 退出doze对应的时间点。再计算出中间经历的时间。 提取系统时间 java.util.Date这里用到了java中的 时间类型 java.util.Datejava.util.Date 是java中常用时间类型，可以被SimpleDateFormat格式化format() 指定输出的时间格式比如我们需要 小时：分：秒SimpleDateFormat scanf = new SimpleDateFormat(&quot;HH:mm:ss&quot;);scanf.format(java.util.Date) 即可。 提前当前系统时间 12java.util.Date time_after = null;time_after = new java.util.Date(System.currentTimeMillis()); 计算时间差理论上是两个时间相减再格式化输出即可，可惜没成，原因还没找到。于是土办法： 调用 .getTime() 方法，将 java.util.Date 转化为毫秒计时(long) 取两者差值 转化为 时间长短 字符串返回， 代码如下123456789101112131415161718192021 size = (time_after.getTime() - time_befor.getTime()); string = scanf.format(time_befor) + "-" + scanf.format(time_after) + "="+ trform(size); String trform(long size) &#123; long day, hour, min, secone; day = size / (1000 * 60 * 60 * 24); //以天数为单位取整 hour = (size / (60 * 60 * 1000) - day * 24); //以小时为单位取整 min = ((size / (60 * 1000)) - day * 24 * 60 - hour * 60); //以分钟为单位取整 secone = (size / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60);if (day != 0) &#123; return day + "d" + hour + "h" + min + "m" + secone + "s"; &#125; else if (hour != 0) &#123; return hour + "h" + min + "m" + secone + "s"; &#125; else if (min != 0) &#123; return min + "m" + secone + "s"; &#125; else &#123; return secone + "s"; &#125; &#125; 通知扩展布局 在如下图片中，可以发现，通知在发出后，只默认显示最近一次的时间记录，其他时间记录可以在此条通知上下滑查看。明显与基础部分不同。 此处应用了 Builder.setStyle() 拓展布局，顾名思义，这是用于拓展通知显示范围 使用扩展布局 使用拓展布局 构建一个 inboxStyle 对象 .addLine方法 添加 String inboxStyle 行 使用 Builder.setStyle( inboxStyle )加载到通知 等待通知发布即可。 简单例程如下 123456//创建 inboxStyle NotificationCompat.InboxStyle inboxStyle = new NotificationCompat.InboxStyle(); //添加 String 行 ，前提是 我已经创建了一个 String inboxStyle.addLine(string); // 在notification 设置 inboxStyle 在一堆 build 里面 .setStyle(inboxStyle) 清除原有内容，发布新的 inboxStyle 只需要 inboxStyle = new NotificationCompat.InboxStyle(); Doze模式改变广播* 对应 ACTION_DEVICE_IDLE_MODE_CHANGED 坑：只能动态注册，静态注册无效，具体代码中powermanger.ACTION_DEVICE_IDLE_MODE_CHANGED 需要实例化 PowerManger ，而 PowerManger 又是与 Activity绑定，所以只有应用保持后台存活时才会进入广播。 例程如下12345678//实例化 PowerManagerPowerManager powermanger = (PowerManager) getApplicationContext().getSystemService(Context.POWER_SERVICE);//动态注册广播intentFilter = new IntentFilter();intentFilter.addAction(powermanger.ACTION_DEVICE_IDLE_MODE_CHANGED);//idlemodechage 是 BroadcastReceiver idlemodechage = new IdleModeChange();registerReceiver(idlemodechage, intentFilter);]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—ContentResolver]]></title>
    <url>%2F2017%2F01%2F19%2FAndroid%E7%AC%94%E8%AE%B0-ContentResolver%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) android6.0运行时权限详解 编程环境 Android Studio 2.2.3 导语 内容提供器是安全的应用间共享数据途径，在正式进入之前需要了解一下 Android 自6.0以来权限的变化 Android 权限详解 资料来源： android6.0运行时权限详解 Develop-API Guides-系统权限 第一行代码(第二版) Android权限介绍 Android 是一个权限分隔的操作系统每个应用系统标识（Linux 用户 ID 和组 ID）不同。系统各部分标识亦不相同。Linux 据此将不同的应用以及应用与系统分隔开来。更详细的安全功能通过“权限”提供，权限 会限制特定进程可以执行的具体操作，并且根据 URI 权限授权临时访问特定的数据段 权限声明最常见的权限声明在 AndroidManifest.xml 文件中一个或多个uses-permission 标记, 例如 声明短信权限 12345&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.android.app.myapp" &gt; &lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt; ... &lt;/manifest&gt; android 6.0 权限机制android 6.0之前 权限及在安装的时候，根据权限声明产生一个权限列表，用户只有在同意之后才能完成app的安装。android 6.0 以后 引入了 运行时权限 功能，应用所需权限不再一次性在安装时申请，而是在运行时需要用到那种权限向用户申请，同时用户也可以随时取消该授权 权限分类 Normal Permissions(普通权限)不涉及用户隐私，不需要用户进行授权的，例如 手机震动、访问网络等 Dangerous Permission(危险权限)涉及到用户隐私的，需要用户进行授权，例如 读取sdcard、访问通讯录等危险权限组如表1 应用运行时申请权限（适用于 Android6.0 及以上版本） 通过一个简单的实例来说明过程实例： 拨打电话 CALLPHONE 权限为例 权限声明1&lt;uses-permission android:name="android.permission.CALL_PHONE"/&gt; 拨打10010 代码如下 构建一个隐式intent 启动拨打电话123Intent intent = new Intent(Intent.ACTION_CALL);intent.setData(Uri.parse("tel:10010"));startActivity(intent); 在主界面上添加一个Button 在其onClick方法中拨打电话，运行程序! 在An’d’roid 6.0 以下版本中 电话都可以正常拨出。Android 6.0 以上版本中 则可能会应用崩溃/无反应，查看logcat的打印日志可以看到 “Permission Denial”权限被禁止的信息，接下来尝试使用 运行时申请权限 检查是否已获得授权int checkSelfPermission(Context context, String permission)方法 Context context contextString permission 权限具体名称打电话对应 Manifest.permission.CALLPHONE 方法返回 PERMISSION_GRANTED / PERMISSION_DENIED 例程12345678if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.CALL_PHONE) !=PackageManager.PERMISSION_GRANTED)&#123; ;&#125;else &#123; ;&#125; 申请权限void ActivityCompat.requestPermissions (Activity activity, String[] permissions, int requestCode)方法 Activity activity Activity实例String[] permissions 请求权限名int requestCode 请求码，大于0即可，对应在onRequestPermissionsResult 回掉方法中的requestCode 例程 12ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.CALL_PHONE&#125;,1 ); 授权后回掉无论用户是否授权都会进入回掉方法，需要重写该方法。void onRequestPermissionsResult (int requestCode, String[] permissions, int[] grantResults)方法 int requestCode 在 requestPermissions 中传入的请求码String[] permissions 请求的权限，不为空int[] grantResults 授权结果 只有 PERMISSION_GRANTED / PERMISSION_DENIED 两个值 例程 123456789101112131415@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; //请求码 1 case 1: //授权结果(int) 的 长度是否大于0 与上 授权结果是否等于 PackageManager.PERMISSION_GRANTED if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //授权通过执行 &#125; else &#123; //授权没有通过 &#125; break; default: &#125;&#125; 当用户拒绝后再次询问 boolean ActivityCompat.shouldShowRequestPermissionRationale(Activity activity, String permission) （真心太长了） Activity activity Activity实例String permission 权限名称应用第一次需要授权时,用户授权，该方法返回false。当用户拒绝授权,下次需要该权限时,该方法会返回true 例程1234567 if (ActivityCompat.shouldShowRequestPermissionRationale(PermissionActivity.this,Manifest.permission.READ_CONTACTS))&#123;//第二次询问用户是否授权&#125;else&#123;//用户依旧拒绝后操作&#125; 例程源码 123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void Button(View view)&#123; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CALL_PHONE&#125;,1 ); &#125;else &#123; call(); &#125; &#125; private void call() &#123; try &#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:10010")); startActivity(intent); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; call(); &#125; else &#123; Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show(); &#125; break; default: &#125; &#125; &#125; 12345&lt;Button android:onClick="Button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" /&gt;]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—数据保存]]></title>
    <url>%2F2017%2F01%2F14%2FAndroid%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) 编程环境 Android Studio 2.2.3 Android 中的主要数据存储 有三种 保存键值集 要保存的相对较小键值集合，使用 SharedPreferences 保存文件使用 Android 文件系统通过 File API 读取和写入文件，适合按开始到结束的顺序不跳过地读取或写入大量数据。 例如，图片文件或通过网络交换的任何内容 在 SQL 数据库中保存数据Android内建的SQLite 数据库存储重复或结构化数据 PS：这里如果没有学过 SQL 数据库使用，推荐LitePal Android开源数据库LitePal ：郭霖(第一行代码作者) 详细介绍在这里（懒人必备）Android开源数据库LitePal 保存键值集 想要保存的相对较小键值集合 调用SharedPreferences 首先：获取SharedPreferences的句柄用户可以创建一个共享参数文件或访问一个已经存在的共享参数文件。具体途径有三条 getSharedPreferences (String name, int mode) 第一个参数：SharedPreferences的名称，第二个：参数指定操作模式 需要创建/读取 多个共享参数文件时使用，每个文件都拥有一个标识符，可以通过这个标识符通过该方法的第一个参数获得共享参数对象。可以通过APP中的任意Context对象调用它。 示例12//指定SharedPreferences名称为data 模式为MODE_PRIVATE：只有当前程序才有权限读取/修改SharedPreferences sharedPref = getSharedPreferences("data", MODE_PRIVATE); getPreferences (int mode) 参数：指定操作模式 只创建 Activity 的一个SharedPreferences。在Activity 中使用。 方法会检索属于该 Activity 的默认共享首选项文件，无需提供名称 示例12//模式：MODE_PRIVATE：只有当前程序才有权限读取/修改SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE); getDefaultSharedPreferences(context) 参数：context 自动以档期应用程序包名作为前缀命名SharedPreferences文件 写入数据到共享参数中 SharedPreferences 调用 edit() 创建一个 SharedPreferences.Editor使用诸如 putInt() 和 putString() 方法写入的键和值最后调用commit() 以保存更改也可调用apply() 保存更改 commit() 与 apply() 相同/区别 相同 都是提交preference修改数据 区别 apply没有返回值 commit返回boolean表明修改是否提交成功 apply是将操作提交到内存，而后异步真正提交到文件 commit是同步的提交到文件 多个commit同时提交，互相等待，效率较低 apply直接覆盖，效率较高 apply没有任何错误提示，只是提交的动作 示例123456//创建 .edit()SharedPreferences.Editor editor = sharedPref.edit();//写入字符串。key-值 TextVieweditor.putString("TextView","hello");//保存更改editor.commit(); 从共享参数中读取数据 获取SharedPreferences的句柄方式同上 调用比如getInt()或getString()方法，然后传入键值，如果键不存在，则会返回一个默认值 示例123456//获取SharedPreferences的句柄SharedPreferences sharedPreferences = getSharedPreferences("data",MODE_PRIVATE);//读取键值对应数据String text = sharedPreferences.getString("TextView","");//打印到log中 验证Log.d("data",text); 保存到文件 Android 设备有两个文件存储区域： 内部存储 和 外部存储Android 设备早期内置的非易失性内存（内部存储），以及移动存储介质 微型 SD 卡等（外部存储）任何Android设备始终有两个存储空间，并且无论外部存储设备是否可移动，API 的行为均一致 Android的文件存储是以java流为基础，并优化了一些操作。java流不属于本文范围。 涉及java流部分参考Android文件IO详解 内部存储保存到内部存储 某一应用对其内部存储 始终具有 进行读写的权限，而无需声明任何权限，在 Android N之前，内部文件可以通过放宽权限让其他应用访问。但是极不推荐以这种方式共享文件 简单实例 123456789101112131415161718192021222324252627public void save(String inputText)&#123; //新建一个FileOutputStream对象(字节流) FileOutputStream out = null; //新建一个BufferedWriter (字符流) BufferedWriter writer = null; try&#123; //out 实例化 out = openFileOutput("data",Context.MODE_PRIVATE); //OutputStreamWrit 字节流转换为字符流 //字符流绑定BufferedWriter(缓冲区) writer = new BufferedWriter(new OutputStreamWriter(out)); //写入到文件 writer.write(inputText); &#125;catch (IOException e )&#123; e.printStackTrace(); &#125; finally &#123; try&#123; //如果写入成功 if (writer != null) &#123; //关闭流 writer.close(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; FileOutputStream： 继承自 OutputStream 用于文件处理的节点流 用于写入原始字节流到文件 FileOutputStream openFileOutput (String name, int mode) 返回FileOutputStream对象 第一个参数是文件名 第二个参数是操作模式，有4种取值 MODEPRIVATE(默认)当同一文件名存在时覆盖原文件 MODEAPPEND 当同名文件存在时，在原文件末尾追加 其余两种均在android4.2及以上版本中废弃 OutputStreamWrit 继承自 Writer 将字节流转换为字符流 BufferedWriter 继承自Writer 绑定字符输出流，提高具体的流对象的效率 .flush()方法 对缓冲区进行刷新，让数据到目的地 .close();方法 关闭缓冲区，即关闭绑定的流 从内部存储读取文件 简单实例 123456789101112131415161718192021222324252627282930313233343536public String load()&#123; //新建FileInputStream对象 FileInputStream in = null; //新建 BufferedReader对象 BufferedReader reader = null; //新建一个StringBuilder 空 content = new StringBuilder(); try&#123; //FileInputStream对象实例化 in = openFileInput("data"); //字节流转换为字符流 //缓冲流绑定字符流 reader = new BufferedReader(new InputStreamReader(in)); //空 String String line = ""; //读取文件内容，并判断是否读取完成 while((line = reader.readLine())!=null)&#123; //读取内容添加到 StringBuilder 对象中 content.append(line); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; if(reader != null)&#123; try&#123; //关闭流 reader.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; //将读取结果 由StringBuilder转换为String 并返回 return content.toString(); &#125; FileInputStream 继承自 InputStream，用于文件处理的节点流 从文件中读取 FileInputStream openFileInput(String filename) 返回FileInputStream对象 参数为 读取的文件名 InputStreamRead 将字节流转换为字符流 BufferedReader 缓冲流 外部存储 占坑]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016总结]]></title>
    <url>%2F2016%2F12%2F31%2F2016%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2016 找到了兴趣-Android开始正式学习。 搭建了自己的blog，虽然周围人没人关注，有一篇日子的阅读量过了1万，还是很惊喜的 嵌入式工作没用找到满意的，只能说等春招 Andoid的实习，这段时间努力提高自己， 放弃了考研 心情走过了类似抑郁的经历，对体制种种各有看法，是对是错，让时间见证 2017 希望有自己的收入，经济相对自由一点 谈一段恋爱，遇到合适的女孩吧 Android的路上，顺利一点吧 不给自己设定限制，走一步再走一步]]></content>
      <categories>
        <category>随</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Studio优化编译速度]]></title>
    <url>%2F2016%2F12%2F25%2FAndroid%20Studio%E4%BC%98%E5%8C%96%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[资料来源如下 http://www.jianshu.com/p/1c878c10a6bb http://www.jianshu.com/p/9b8ef61b7cdb http://www.jianshu.com/p/64d9a52aebbf 编程环境 Android Studio 2.2.3 导语 ssd盘容量不够了，重装系统，随便重新安装了Android Studio 记录一边优化过程 最重要的 有一个良好的梯子+全局翻墙 大部分Android Studio安装的问题,就基本不会出现 开启gradle单独的守护进程 在C:\Users.gradle目录(user目录即当前用户不同电脑一般不同)下新建 gradle.properties文件复制下面的代码 12345org.gradle.daemon=true org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=800m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8org.gradle.parallel=true org.gradle.configureondemand=true 应该是增大了gradle 运行的 java 虚拟机的大小，我的电脑是8g内存，这个配置效果最好 扩大Android Studio 运行内存 找到Android Studio安装目录下的bin文件夹找到studio64.exe.vmoptions和studio.exe.vmoptions文件(64位)studio.exe.vmoptions和studio.exe.vmoptions文件(32位) 分别编辑文件,改动3个地方如下 123-Xms1024m-Xmx2048m-XX:MaxPermSize=800m Android Studio 设置 Command-line Option不填 gradle 离线模式勾选Office Work，我这里测试是速度基本不变，但是网上有人测试是效果相差很多，原因不明，可能是网络一直全局翻墙的关系]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—Broadcast广播]]></title>
    <url>%2F2016%2F12%2F23%2FAndroid%E7%AC%94%E8%AE%B0-Broadcast%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) 编程环境 Android Studio 2.2.3 BroadcastReceiver基础 首先祭出官方文档及中文翻译 https://developer.android.com/reference/android/content/BroadcastReceiver.htmlhttp://www.jianshu.com/p/1b56172b0c77 BroadcastReceiver概述 @别路寻忆Android中的四大组件是 Activity、Service、Broadcast和Content Provider。而Intent是一个对动作和行为的抽象描述，负责组件之间程序之间进行消息传递。那么Broadcast Receiver组件就提供了一种把Intent作为一个消息广播出去，由所有对其感兴趣的程序对其作出反应的机制。 @zuolongsnail专栏 广播接收器是一个专注于接收广播通知信息，并做出对应处理的组件。很多广播是源自于系统代码的──比如，通知时区改变、电池电量低、拍摄了一张照片或者用户改变了语言选项。应用程序也可以进行广播──比如说，通知其它应用程序一些数据下载完成并处于可用状态。 应用程序可以拥有任意数量的广播接收器以对所有它感兴趣的通知信息予以响应。所有的接收器均继承自BroadcastReceiver基类。 广播接收器没有用户界面。然而，它们可以启动一个activity来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。 广播分类 触发广播发生的事件分类有两种 Android系统广播事件 由android设备状态变化而触发的系统广播如： Intent.ACTION_POWER_CONNECTED; //插上外部电源时发出的广播 Intent.ACTION_SCREEN_ON; //屏幕被打开之后的广播 ACTION_TIME_CHANGED//系统时间改变而触发的广播 自定义的广播事件 这个比较好理解了，比如qq当我们再另外一台手机上登陆时，手头的这个手机qq就会自动下线。腾讯的服务器通过后台服务启用了自定义广播来终结正在运行的Activity，详情之后会有例程，不再累赘。 能够被接收的广播类型 普通广播（Normal broadcasts）： （由 Context.sendBroadcast发出）异步发出。所有广播接收器都可以在同一时间接收广播。广播接收者无法接收广播的处理结果或者阻断广播的传递。 有序广播（Ordered broadcasts）： （由 Context.sendOrderedBroadcast发出）每次只发送给一个广播接收器。当每个广播接收器依次执行时，它可以向下一个广播接收器传播结果，或者阻断该广播，使得该广播不能被下一个广播接收器接收到。 通俗解释： 普通广播就相当于小区/村委会的大喇叭，有事发生（触发广播）通知所有的人（广播接收器），全功率的大喊大叫确保所有人（广播接收器）都能听到。而有人（广播接收器）在睡觉被吵醒但是又没办法砸了那个大喇叭，只能继续听着（无法接收广播的处理结果或者阻断广播的传递）。 有序广播 就相当于间谍机关的绝密消息传递。绝密到手（触发广播）间谍秘密汇总给上线A（广播接收器A）。本来 上线（广播接收器A）应该 听取完毕重新整理情向首长B（广播接收器B）报告（向广播接收器B传播 广播接收器A修改的结果）,但是A被收买，将情报隐匿了，没有向首长B汇报（广播接收器A阻断该广播，使得该广播不能被下一个广播接收器B接收到）。（PS结局首长B错误带人炸了村委会，该睡觉的人终于可以安生睡觉了！） 广播事件注册有两种 静态注册，就是在AndroidManifest.xml文件中定义，注册的广播接收器必须要继承BroadcastReceiver. 动态注册，是在程序中使用Context.registerReceiver注册，注册的广播接收器相当于一个匿名类。两种方式都需要IntentFIlter。 例程见下节。 动态注册（在代码中注册） 在代码中通过registerReceiver()注册。app关闭后,该接收器也会随之销毁。 首先定义一个内部子类NetworkChangeReceiver继承自 BroadcastReceiver 12345678class NetworkChangeReceiver extends BroadcastReceiver &#123;@Override//重写onReceive，接收到广播后提示消息 public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "network is available网络已变化", Toast.LENGTH_SHORT).show(); &#125; &#125; 在onCreate()方法中创建IntentFilter实例和NetworkChangeReceiver实例。并在IntentFilter实例中添加网络变化时系统广播对应值。随后传入registerReceiver()中注册。 123456789101112 protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //创建IntentFilter实例 intentFilter = new IntentFilter(); //添加对应系统广播 intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); //添加NetworkChangeReceiver实例 networkChangeReceiver = new NetworkChangeReceiver(); //动态注册 registerReceiver(networkChangeReceiver, intentFilter);&#125; 动态注册的广播接收器最后要取消注册。在onDestroy()方法中调用unregisterReceiver()销毁动态注册的广播接收器。 1234 protected void onDestroy()&#123; super.onDestroy(); unregisterReceiver(networkChangeReceiver);&#125; 最后要在AndroidMainfest.xml中声明查询系统网络状态的权限。 1&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; 运行效果如如所示（模拟器） 静态注册（xml中注册） 直接在Manifest.xml文件中配置广播接收者 例程为了方便同样以android.net.conn.CONNECTIVITY_CHANGE为例，与动态注册相同。不使用内部子类（第一行代码） 新建名称为BootCompleteReceiver的java class 代码如下 123456 public class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent)&#123; Toast.makeText(context, "网络改变", Toast.LENGTH_SHORT).show(); &#125;&#125; 在AndroidManifest.xml文件中注册广播接收器 代码如下 12345&lt;receiver android:name=".BootCompleteReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.net.conn.CONNECTIVITY_CHANGE"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 在AndroidManifest.xml中声明权限 12&lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"&gt;&lt;/uses-permission&gt; 使用内部子类（在Activity中定义） 在这晕圈了一下午，找不出毛病。看书多仔细吧，书上说了不用内部子类。详细资料在这里 http://blog.csdn.net/chdjj/article/details/19496567 清单文件注册广播接收者时，广播接收者的名字格式需要注意因为是内部类，所以需要在内部类所在的类与内部类之间加上$符号(这一点在AndroidStudio中输入时有提示) 内部类在声明时一定要写成静态内部类（class关键字前加上static）。否则会抛出异常（广播发生时，应用停止运行） 在MainActivity中新建子类 123456 public static class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent)&#123; Toast.makeText(context, "Boot complete", Toast.LENGTH_SHORT).show(); &#125;&#125; 在AndroidManifest.xml中注册广播接收器 12345&lt;receiver android:name=".MainActivity$BootCompleteReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.net.conn.CONNECTIVITY_CHANGE"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 在AndroidManifest.xml中声明权限 12&lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"&gt;&lt;/uses-permission&gt; 运行效果同动态注册 使用广播接收器注意事项 在onReceive()方法中不宜添加过多逻辑/耗时操作，广播接收器没有多线程，一旦时间过长，程序就会报错。 广播接收器一般为启动其他组件作用。 发送标准广播 发送标准广播之前，首先要注册一个作为目标的广播接收器。（过程略，只上代码） 新建MyBroadcastReceiver.class 1234567 public class MyBroadcastReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context,"MyBroadcastReceiver",Toast.LENGTH_SHORT).show(); &#125;&#125; 在Xml中注册（静态） 12345&lt;receiver android:name=".MyBroadcastReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.broadcasttest.MyBroad"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; xml中注册一个Button 12345&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="SendBroad" android:text="SendBroad" /&gt; MainActivity中新建 SendBroad()函数 首先构建一个 Intent对象，将自定义的广播值填入。再调用sendBroadcast方法将广播发送出去。 12345 public void SendBroad(View view)&#123; Intent intent = new Intent("com.example.broadcasttest.MyBroad"); sendBroadcast(intent);&#125; 发送的是标准广播。运行效果如下图。 发送有序广播 首先新建一个Broad2 的工程。同样接收Broad发送的广播。 代码如下 1234567 public class AnotherBroadcast extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context," AnotherBroadcast",Toast.LENGTH_SHORT).show(); &#125;&#125; 12345&lt;receiver android:name=".AnotherBroadcast"&gt; &lt;intent-filter android:priority="10"&gt; &lt;action android:name="com.example.broadcasttest.MyBroad"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 测试效果：当摁下发送广播按钮后，弹出两个提示。 修改Broad项目中onClick对应事件。将sendBroadcast(）改为sendOrderedBroadcast();发送有序广播。 12345 public void SendBroad(View view)&#123; Intent intent = new Intent("com.example.broadcasttest.MyBroad"); sendOrderedBroadcast(intent,null);&#125; 效果与发送标准广播相同（还未定义优先级/截断等） 定义优先级，再Broad的AndroidMainfest.xml中修改注册的广播添加android:priority=”100”优先级100 12345&lt;receiver android:name=".MyBroadcastReceiver"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="com.example.broadcasttest.MyBroad"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 在Broad2的AndroidMainfest.xml中添加android:priority=”10”优先级10 12345&lt;receiver android:name=".AnotherBroadcast"&gt; &lt;intent-filter android:priority="10"&gt; &lt;action android:name="com.example.broadcasttest.MyBroad"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 发送广播后MyBroadcastReceiver最先收到广播。 截断广播。有序广播中前一个广播接收器可以截断广播传播。添加 abortBroadcast();即可。 12345678 public class MyBroadcastReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context,"MyBroadcastReceiver",Toast.LENGTH_SHORT).show(); abortBroadcast(); &#125;&#125; 再次点击按钮发送广播，只有MyBroadcastReceiver可以接收到发送的广播。 本地广播 只在app应用内部传递的广播。注册过程类似于动态注册。 定义一个内部类LocalReceiver继承自BroadcastReceiver 123456 public static class LocalReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent)&#123; Toast.makeText(context, "received local broadcast", Toast.LENGTH_SHORT).show(); &#125;&#125; 首先在onCreate()方法中通过localBroadcastManager.getInstan得到一个LocalBroadcastManager的实例，再创建IntentFilter实例和LocalReceiver实例。并在IntentFilter实例中添加广播。随后传入localBroadcastManager.registerReceiver()中注册本地广播。 123456789101112131415161718private IntentFilter intentFilter;private LocalReceiver localReceiver;private LocalBroadcastManager localBroadcastManager;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); localBroadcastManager = localBroadcastManager.getInstance(this); intentFilter = new IntentFilter(); intentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST"); localReceiver = new LocalReceiver(); localBroadcastManager.registerReceiver(localReceiver, intentFilter); &#125; 在Activity的onDestroy()中销毁注册。 12345@Overrideprotected void onDestroy()&#123; super.onDestroy(); localBroadcastManager.unregisterReceiver(localReceiver);&#125; 在Button对应的函数中调用localBroadcastManager.sendBroadcast发送本地广播。 12345 public void SendBroad(View view)&#123; Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST"); localBroadcastManager.sendBroadcast(intent);&#125; 效果基本同上，不加累赘。不过在Broad2中是怎样都搜不到广播了。 本地广播特点 明确广播只在应用内部，传递数据无需担心泄密。 其他程序广播无法发送至程序内部。 本地广播比全局广播更为高效。]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—Fragments]]></title>
    <url>%2F2016%2F12%2F18%2FAndroid%E7%AC%94%E8%AE%B0-Fragments%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) Android官方文档之App Components（Fragments） 编程环境 Android Studio 2.2.3 导语 Fragments的艺术之旅 Fragments简介 Fragment—片段 是Android 在 Android 3.0（API 11 级）中引入了，主要是为了给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持。 可以将多个片段组合在一个 Activity 中来构建多窗格 UI，以及在多个 Activity 中重复使用某个片段。可以将片段视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，可以在 Activity 运行时添加或删除片段（类似于不同 Activity 中重复使用的“子 Activity”） Google官方文档(中文) 创建Fragments fragment创建过程与Activity类似。 创建Fragment，需要继承一个Fragment类，并实现Fragment的生命周期回调方法，如onCreate(), onStart(), onPause(), onStop()等 一般来说，在Fragment中应至少重写以下这些生命周期方法必须重写的时onCreateView()方法. onCreate()：创建Fragment实例时，系统回调的方法。在该方法中，对一些必要的组件进行初始化 onCreateView()：Fragment上绘制UI时，回掉该方法。返回一个View对象，表示Fragment的根视图；若Fragment不需要绑定示图，可以返回null onPause()：当用户离开Fragment时回调。在该方法中，对Fragment的数据信息做持久化的保存工作 创建一个Fragment类 新建first_fragme 继承自Fragment Android Studio中 对应Fragment 包有两个，选择support-v4 _(这个版本可以再Android版本中保持Fragment特性一致) Fragment并非一定要绑定一个布局文件，下面会提到。 1234567public class FirstFragment extends Fragment &#123; @Override public View onCreateView (LayoutInflater inflater, ViewGroup container, Bundle saveInstanceState)&#123; View view = inflater.inflate(R.layout.fragment_firest,container,false); return view; &#125;&#125; 与此对应的fragmentfirest布局文件 LinearLayout加一个Button，背景颜色设置为了靛蓝色。 onCreateView()方法 ViewGroup来自宿主Activity容器布局，Fragment的布局将其作为根视图插入至该视图中。 Bundle用于回传之前占据该位置的Fragment实例所保存的Bundle信息，当该Fragment的新实例处于resume状态时，该参数被回传 inflate() 方法 参数1（int）：需要绑定的Layout的资源ID； 参数2（ViewGroup）：绑定的Layout布局的父视图； 参数3（boolean）：是否需要将参数1的Layout资源依附于，参数2的ViewGroup上，false，表示不依附。（系统已经默认将Layout插入至ViewGroup中，若为true，将添加一层冗余的视图 在XML将fragment添加到activity 在activity_main.xml中添加如下代码。跟添加一个layout没有太大区别。 123456&lt;fragment android:id="@+id/left_fragment" android:name="ljy.com.fragmenttest.fragment_firest" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"/&gt; 至此一个fragment添加完毕。为了对比，再新建一个second_fragment，背景颜色不同，两者同时添加进activity_main中。 一般来说必须为fragment设定唯一的身份标识，以便当宿主Activity为restart状态时可以恢复fragment android:id属性为fragment指定唯一ID android:tag属性为fragment指定唯一字符串标识 未指定，则该fragment的标识为其父容器控件的ID 动态添加碎片 处理片段时，请谨记：Activity 布局必须包含一个可以插入片段的容器 View 添加或移除片段必须使用 FragmentManager 创建 FragmentTransaction， FragmentTransaction将提供添加、移除、替换片段以及执行其他片段事务所需的 API。Activity 内调用 getSupportFragmentManager() 以获取 FragmentManager 12rightfragment right = new rightfragment();FragmentManager fragmentManager = getSupportFragmentManager(); 调用 beginTransaction() 创建一个 FragmentTransaction事务，并调用 add() 添加一个片段，做好更改准备时，调用 commit() 123FragmentTransaction transaction = fragmentManager.beginTransaction();transaction.replace(R.id.right_layout,right);transaction.commit(); 示例： 首先改造一下activitymain.xmlFrameLayout包含一个left_fragment 12345678910111213 &lt;FrameLayout android:id="@+id/right_layout" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"&gt; &lt;fragment android:id="@+id/left_fragment" android:name="com.example.fragment_text.leftfragment" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/FrameLayout&gt; 在MainActivity的onCreate方法中添加fragment 12345678910111213//新建准备替换的Fragment实例rightfragment right = new rightfragment();//新建FragmentManagerFragmentManager fragmentManager = getSupportFragmentManager();// 调用beginTransaction() 创建FragmentTransactionFragmentTransaction transaction = fragmentManager.beginTransaction();//FragmentTransaction内处理添加/替换等。transaction.replace(R.id.right_layout,right);//最后执行commit()方法transaction.commit(); 管理Fragments/执行Fragment事务 Activity中管理Fragment，使用FragmentManager( 1FragmentManager fragmentManager = getFragmentManager(); 可以实现的操作 findFragmentById()方法获取由Activity管辖的绑定了UI的Fragment实例 popBackStack()方法将Fragment从后退栈中弹出 addOnBackStackChangedListener()方法注册监听器，用于监听后退栈的变化 Fragment可实现动态添加、删除、替换 等 操作，每一组向Activity提交的变化称为事务，使用FragmentTransaction这操作事务,调用beginTransaction(）开启一个事务 12FragmentManager fragmentManager = getFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); 可实现对Feagment的操作 add() //添加 remove() //移除 replace() //替换 事务要在Activity中生效，调用commit()方法提交 commit()方法之前，调用addToBackStack()方法，可以将该事物添加到由Activity管辖的Fragment返回栈中。点击Back键即撤销该事物提交的更改 使用FragmentTransaction操作事务时注意 commit()必须在最后调用 一个布局容器中添加多个Fragment，加入的顺序决定了这些Fragment绑定的UI视图在View树中的层级顺序 commit()方法提交后，并不会立即执行事务，UI更新只能在主线程中进行，主线程空闲时，才会执行事务操作Android也提供了 在UI线程中调用executePendingTransactions()方法，使commit()方法调用后立即执行提交的事务（一般用不到） 与 Activity 通信 Fragment 中获取 Activity 实例 getActivity()方法可以获取到 Activity 实例 1MainActivity activity = (MainActivity) getActivity(); 调用Activity中的试图也很简单，使用findViewById()即可，getActivity()方法返回的既是一个Context对象 1View listView = getActivity().findViewById(R.id.list); 在Fragment中使用Context对象，getActivity()方法，只能是在fragment已经依附于Activity后才能调用。当fragment未依附于某个Activity、或fragment已经处于其生命周期的末尾而不再依附于某个Activity时，调用getActivity()方法会直接返回null Activity 中获取 Fragment 实例()FragmentManger提供了findFragmentById()方法 1RightFragment fragment = (RightFragment) getFragmentManager().findFragmentById(R.id.example_fragment); 如果使用的使support-V4包，则 getFragmentManager()改为getSupportFragmentManager()，代码如下： 1RightFragment fragment = (RightFragment)getSupportFragmentManager().findFragmentById(R.id.example_fragment); Fragment与Frangment之间也可以通过宿主Activity，获取到另一个Fragment实例，调用另一个Fragment中的方法 为Activity创建事件回调 占坑， Frangment的生命周期 与Activity极为相似，且 Frangment的生命周期与宿主Activity有很大关联 有3种状态 Resumed继续：宿主Activity处于running，Fragment处于可见状态 Paused暂停：另一个Activity处于前台并获得了焦点，该Fragment的宿主Activity并未被全部遮挡 Stopped停止：Fragment不可见或Fragment已被Activity移除，宿主Activity被回收时，Fragment也将被回收 宿主Activity的影响 重要回调方法 onAttach()：fragment关联Activity时回调 onCreateView()：fragment绑定UI视图(加载布局)时回调 onActivityCreated()：宿主Activity创建完毕 (宿主Activity的onCreate()方法返回) 后调用 onDestroyView()：与fragment绑定的UI视图被移除时回调 onDetach()：fragment不再依附于Activity时回调 Activity 与Fragment在生命周期之间的最显著差异在于它们在其各自返回栈中的存储方式。默认情况下，Activity 停止时会被放入由系统管理的 Activity 返回栈（以便用户通过返回按钮回退到 Activity），Frament仅当您在移除片段的事务执行期间通过调用 addToBackStack() 请求保存实例时，系统才会将Fragment放入由宿主 Activity 管理的返回栈。 一旦Activity处于resume状态时，可以自由地添加或移除fragment，也就是说，只有当Activity的状态为resume时，fragment才能够自由地控制自己的生命周期]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—UI-RecyclerView]]></title>
    <url>%2F2016%2F12%2F16%2FAndroid%E7%AC%94%E8%AE%B0-UI-RecyclerView%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) RecyclerView使用详解—六和敬 RecyclerView使用介绍— Jin Yudong Android RecyclerView 使用完全解析 体验艺术般的控件—鸿洋_ 创建列表与卡片—Android Developer 编程环境 Android Studio 2.2.3 导语 RecyclerView内容较ListView更多，初期只能更新一些基础内容，高级的用法随时更新，长期跟进 简介 RecyclerView是用于取代ListView的组件,第一次出现是在2014年google I/O大会，内置在是Android L及以上版本的SDK中。 对比与ListView，RecyclerView弥补了ListView中的效率问题，同时支持更多的显示效果，代码逻辑更为清晰 基本使用步骤 RecyclerView定义在support库中，使用RecyclerView之前必须在添加依赖 build.gradle中添加 compile &#39;com.android.support:recyclerview-v7:25.1.0&#39; RecyclerView项目结构如下： 要使用RecyclerView，需要指定一个Adapter适配器和一个LayoutManager布局管理器 Adapter适配器：作用与ListView中使用的Adapter相同，都是将数据与对应item的界面进行绑定所不同的是：RecyclerView中适配器必须继承自RecyclerView.Adapter，且 强制使用了ViewHolder LayoutManager布局管理器：每一个item如何进行排列，何时展示和隐藏。重用View时，LayoutManager会向Adapter适配器请求新的数据替换旧的数据，避免了View的冗余和频繁调用findViewById LayoutManager的引入 使得各种布局排列编写，变的格外容易，这也是RecyclerView优于ListView的一个地方 目前RecyclerView 内置3种LayoutManager： LinearLayoutManager 横向/竖向布局 GridLayoutManager 网格布局 StaggeredGridLayoutManager 瀑布流布局 MainActivity中 RecyclerView 设置 创建RecyclerView对象RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycle_view); 设置LayoutManager显示规则 设置适配器recyclerview.setAdapter(adapter); 简单实例由一个简单的实例+详细分析 添加依赖打开app/build.gradle文件，在dependencies闭包下添加依赖库版本与你工程的com.android.support:appcompat-v7:25.1.0版本对应 1compile 'com.android.support:recyclerview-v7:25.1.0' 之后AndroidStudio会开始同步 添加RecyclerView到xml文件,基本与ListView一致，不过RecyclerView并非内置在SDK中，这里需要写出完整的包路径 12345&lt;android.support.v7.widget.RecyclerView android:id="@+id/recycle_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; 要展示的依旧是水果+图片形式，图片资源在第一行代码第二版源码 /chapter3/ListViewTest\app\src\main\res\drawable-hdpi下，同时将Fruit类和fruititem.xml一并复制，这里给出两者源码，不再加分析 Fruit类 1234567891011121314151617public class Fruit &#123;private String name;private int imageId;public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125;public String getName() &#123; return name; &#125;public int getImageId() &#123; return imageId; &#125;&#125; fruititem.xml 123456789101112131415161718&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"android:orientation="horizontal"android:layout_width="match_parent"android:layout_height="match_parent"&gt;&lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="10dp" /&gt;&lt;/LinearLayout&gt; 准备RecyclerView适配器，适配器需要继承自 RecyclerView.Adapter，将泛型指定为 .ViewHolder，(ViewHolder为在适配器的一个内部类)，并重写3个方法 123public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)//创建返回ViewHolder实例public void onBindViewHolder(ViewHolder holder,int pisition)//数据与界面绑定public int getItemCount() // 返回数据的数量 新建 FruitAdapter 继承自 RecyclerView.Adapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 //继承自RecyclerView.Adapter，泛型为 FruitAdapter .ViewHolder public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; //私有Fruit列表 private List&lt;Fruit&gt; mFruitList;//新建内部类ViewHolder继承自RecyclerView.ViewHolde有每个Item的的所有界面元素 static class ViewHolder extends RecyclerView.ViewHolder&#123; ImageView fruitImage; TextView fruitName; //ViewHolder构造函数，传入View，通常为RecyclerView子项的外层布局(本例为fruit_item.xml) public ViewHolder(View view)&#123; super(view); //findViewById获取 Image/Name实例 fruitImage = (ImageView)view.findViewById(R.id.fruit_image); fruitName = (TextView)view.findViewById(R.id.fruit_name); &#125; &#125;//FruitAdapter构造函数，将数据源传入全局变量mFruitList public FruitAdapter(List&lt;Fruit&gt;fruitList)&#123; mFruitList = fruitList; &#125; @Override //创建ViewHolder实例 public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)&#123; //加载布局文件 View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false); //调用ViewHolder构造函数 ViewHolder holder = new ViewHolder(view); //返回ViewHolder实例 return holder; &#125; @Override //对 RecyclerView子项进行赋值，有新的子项进入屏幕显示范围时调用 public void onBindViewHolder(ViewHolder holder,int pisition)&#123; Fruit fruit = mFruitList.get(pisition); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); &#125; @Override //返回 RecyclerView子项数量 public int getItemCount()&#123; return mFruitList.size(); &#125; &#125; MainActivity中使用RecyclerView 创建RecyclerView对象 设置LayoutManager显示规则（默认竖向滚动） 设置适配器 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 public class MainActivity extends AppCompatActivity &#123;//私有列表 private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化Fruits数据 initFruits(); //获取RecyclerView实例 RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycle_view); //创建LinearLayoutManager，并设置入recyclerView LinearLayoutManager layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); //新建适配器，并传入 FruitAdapter adapter = new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); &#125; //初始化Fruits类 private void initFruits() &#123; //循环两遍 怕占不满屏幕 for (int i = 0; i &lt; 2; i++) &#123; Fruit apple = new Fruit("Apple", R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango_pic); fruitList.add(mango); &#125; &#125; &#125; 这样最简单的 RecyclerView 就搭建完了效果如下 代码比ListView稍多，但是逻辑比较清晰。 横向/瀑布流/网格布局 只需要设置相应LayoutManager即可 /手动滑稽 横向 在 LinearLayoutManager 中修改几行代码即可 修改 LinearLayoutManager 代码，添加一行，搞定！ 1layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); 当然需要简单修改一下item的布局文件，LinearLayout改为垂直排列，宽度固定100dp，图片/文字居中效果如下 瀑布流 这需要 StaggeredGridLayoutManager 布局管理器，可以 竖向/横向 滚动 代码如下12//瀑布流布局，3行，竖向StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL); 调整布局文件，效果如下 网格 这需要 GridLayoutManager 布局管理器 代码如下 12//网格布局，两行GridLayoutManager layoutManager = new GridLayoutManager(this,3); 调整布局文件后，效果如下 注册点击事件 RecyclerView 中并没有提供注册监听器的方法，需要子项View自行注册 部分代码如下1234567891011121314151617181920212223242526272829303132333435 static class ViewHolder extends RecyclerView.ViewHolder &#123; View fruitView; ImageView fruitImage; TextView fruitName; public ViewHolder(View view) &#123; super(view); fruitView = view; fruitImage = (ImageView) view.findViewById(R.id.fruit_image); fruitName = (TextView) view.findViewById(R.id.fruit_name); &#125;&#125; @Overridepublic ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); final ViewHolder holder = new ViewHolder(view); holder.fruitView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), "you clicked view " + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); holder.fruitImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), "you clicked image " + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); return holder;&#125;]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记-UI-ListView]]></title>
    <url>%2F2016%2F12%2F13%2FAndroid%E7%AC%94%E8%AE%B0-UI-ListView%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) ListView Android ListView工作原理完全解析，带你从源码的角度彻底理解 ListView是所有原生控件中使用频率最高和最复杂的，涉及知识点也较多，专门抽出一篇来记录，涉及一些过程分析，希望自己能写完 ListView的简单使用 先来看一下一个简单的实例代码如下 在activity_main.xml中添加_ListView 12345&lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt;&lt;/ListView&gt; 修改MainActivity的代码 123456789101112131415161718 //要显示的数组，屏幕长了点，为了显示滑动效果多增加了几项。 private String[] data = &#123;"apple","banana","orange","watermelon","pear","grape","pineapple","strawberry","cherry","mango","A","B","C","D","E","F"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar);//为适配器绑定数据 ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this,android.R.layout.simple_list_item_single_choice,data);//得到ListView对象的引用ListView listView = (ListView) findViewById(R.id.list_view);//适配器内容传递listView.setAdapter(adapter); &#125;); &#125; 效果如图 步骤其实比较简单 准备要显示的数据 ——String[] data数组 构建适配器 ——ArrayAdapter adapter 将适配器添加到ListView ——listView.setAdapter(adapter); 详解 ListView首先是用来展现大量数据的，数据源的来源可以是网络下载，程序内置、数据库提取等，本例中则是简单的定义了一个String类型 data数组。数据源的类型/种类繁多，使得ListView无法直接适配数据源，直接适配数据源将导致代码的臃肿和效率的低下。ListView与数据源之间需要一个过度 适配器：Adapter，Adapter在ListView和数据源之间起到了一个桥梁的作用。正是Adapter的使用ListView的使用变得要比其它控件复杂得多。 Adapter适配器 Adapter适配器在ListView和数据源之间起到了一个桥梁的作用Adapter的接口都是统一的，因此ListView不用担心任何适配方面的问题。 Adapter又是一个接口(interface)，它可以去实现各种各样的子类，每个子类都能通过自己的逻辑来去完成特定的功能，以及与特定数据源的适配操作，比如说ArrayAdapter可以用于数组和List类型的数据源适配，SimpleCursorAdapter可以用于游标类型的数据源适配 这样就解决了数据源适配的难题，并且还拥有相当不错的扩展性 简易的示图(来自 郭霖的博客) 常用Adapter ArrayAdapter——用来绑定一个数组，支持泛型操作 SimpleAdapter——用来绑定在xml中定义的控件对应的数据 SimpleCursorAdapter——用来绑定游标得到的数据 BaseAdapter——通用的基础适配器 实例中使用的是ArrayAdapter，ArrayAdapter具有多个构造函数重载，这里使用的是字符串类型， ArrayAdapter的构造函数 当前上下文 ListView子项的id，本例中使用的是android.R.layout.simple_list_item 这是Android内置的一个布局文件 需要适配的数据之后适配器就构建完成，最后传递进LIstView中即可 自定义适配器 从第一行代码第二版的源码LiseViewTest目录下拷贝drawblehdpi 到你的工程下 新建Fruit类 123456789101112131415161718public class Fruit &#123; private String name; private int imageId; //构造函数 水果名称/水果对应图片资源ID public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125; 在layout目录下新建fruititem.xml 123456789101112131415161718&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="10dp" /&gt;&lt;/LinearLayout&gt; 一个ImageView和TextView ，水平居中显示 自定义适配器继承自ArrayAdapter 泛型指定为fruit类 12345678910111213141516171819202122 //继承自ArrayAdapter public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId;//构造函数 /上下文 ListView子项布局id 数据 public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @Override //当前子元素的的位置， public View getView(int position, View convertView, ViewGroup parent)&#123; Fruit fruit = getItem(position); // 获取当前项的Fruit实例 View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false); ImageView fruitImage = (ImageView)view.findViewById(R.id.fruit_image); TextView fruitName = (TextView)view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125; &#125; getView()方法接受的三个参数，第一个参数position代表当前子元素的的位置，我们可以通过具体的位置来获取与其相关的数据。第二个参数convertView LayoutInflater.inflate()方法来去加载布局。接收3个参数，第三个参数为false表示只在父布局声明的layout属性有效，但不会为这个view添加父布局，最后设定为接下来会对这个view进行一些属性和值的设定，最后将view返回。 修改MainActivity的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; //新建Fruit类的数组 private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);// 初始化水果数据 initFruits(); //设置FruitAdapter适配器 FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); //得到ListView的引用 ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; // 初始化水果数据 private void initFruits() &#123; //填充两遍，占满屏幕 for (int i = 0; i &lt; 2; i++) &#123; Fruit apple = new Fruit("Apple", R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango_pic); fruitList.add(mango); &#125; &#125;&#125; 只需要修改fruititem.xml，即可定制界面 提升ListView的效率convertView参数 针对 Fruit fruit = getItem(position); // 获取当前项的Fruit实例每次滑动ListView时，getView()方法都会将布局都会重新加载一边 convertView参数：将之前加载完成的布局进行缓存。 借助convertView参数，在每次加载View之前查询convertView是否为空，为空则重新加载，不为空则从convertView中取 代码部分如下 12345678View view;Fruit fruit = getItem(position); // 获取当前项的Fruit实例 if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false); &#125;else &#123; view = convertView; &#125; ListView不会再重复加载布局了 ViewHolder ViewHolder不是Android的开发API，而是一种设计方法 针对ImageView fruitImage = (ImageView)view.findViewById(R.id.fruit_image); TextView fruitName = (TextView)view.findViewById(R.id.fruit_name);每次布局实例化后，findViewById都会重新执行获取控件实例 新增内部类 ViewHolder，利用Tag附加到对应View中，即每次加载布局时，对应的 获取控件实例的操作也一并执行，并储存在View中。这样 获取控件实例的操作直接缓存在View中，不会再重复执行 代码如下 12345678910111213141516171819202122232425262728 @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); // 获取当前项的Fruit实例 View view; ViewHolder viewHolder; if (convertView == null) &#123; //加载布局 view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById (R.id.fruit_image); viewHolder.fruitName = (TextView) view.findViewById (R.id.fruit_name); view.setTag(viewHolder); // 将ViewHolder存储在View中 &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); // 重新获取ViewHolder &#125; viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; &#125;//ViewHolder 内部类 class ViewHolder &#123; ImageView fruitImage; TextView fruitName; &#125; ListView中的点击事件 比较简单,再MainActivty的onCreate方法中添加 代码如下 123456listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show(); setOnItemClickListener为ListView注册了一个监听器，点击发生时回掉 onItemClick()方法，该方法通过position参数判断具体子项。该处是执行Toast]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—UI(一)]]></title>
    <url>%2F2016%2F12%2F09%2FAndroid%E7%AC%94%E8%AE%B0-UI(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) 常用控件TextView TextView 显示文本信息 12345678&lt;TextView android:id=&quot;@+id/text_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:textSize=&quot;24sp&quot; android:textColor=&quot;#00ff00&quot; android:text=&quot;This is TextView&quot; /&gt; 效果如下 常用属性详解 android:id 指定当前控件唯一标识符 android:layout_width android:layout_height指定控件的宽度和高度，取值有 match_parent 匹配父布局 wrap_content自适应内容 fill_parent与match_parent 相同 android:gravity 文字对齐方式，可取值 top bottom left right center 可以使用 | 同时使用多个属性 android:text 文本内容 android:textSize android:textColor 文本的大小/颜色 Button Button 按钮 代码 123456&lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Button" android:textAllCaps="false"/&gt; 效果如下 常用属性 android:textAllCaps 系统自动转换文本为大写 true/false 按钮响应(3种) 匿名类注册监听器 代码如下12345678//新建Button对象 //强制类型转换Button button = (Button)findViewById(R.id.button);button.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v)&#123; //添加逻辑 &#125;&#125;); 接口方式实现 代码123456789101112131415161718192021222324 //继承接口 public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //注册监听器 Button button = (Button)findViewById(R.id.button); button.setOnClickListener(this); &#125; @Override //根据button id处理不同逻辑 public void onClick(View view)&#123; switch (view.getId())&#123; case R.id.button: //处理逻辑 break; default: break; &#125; &#125;&#125; android:onClick 匹配在xml中指定android:onClick 指定的方法名称匹配，签名必须完全相同方法要求： 是公共方法 public 具有空返回值 void 以 View 作为唯一参数（这将是之前点击的 View） 代码如下 1android:onClick="Button_onClick" 123public void Button_onClick(View view)&#123; //处理逻辑&#125; EditText EditText 代码如下 123456&lt;EditText android:id="@+id/edit_text" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="输入文字" android:maxLines="2"/&gt; 效果 常用属性 android:hint 指定一些提示性文字，再用户未输入时提示。 android:maxLines 输入内容最大占用行数 提取输入文本 通过findViewById找到EditText 实例，在处理逻辑中调用EditText.getText方法得到输入内容，再由toString转换为字符串。 代码如下12345678910//新建EditTExt对象private EditText editText;//绑定EditText实例editText = (EditText)findViewById(R.id.edit_text);//提取文本String inputText = editText.getText().toString();//Toast显示Toast.makeText(MainActivity.this,inputText,Toast.LENGTH_SHORT).show(); ImageView 将图片放入drawable-xhdpi文件夹 ImageView 代码 12345&lt;ImageView android:id="@+id/image_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/img_1"/&gt; 效果如下 常用属性 android:src 引用资源位置 更改ImageView图片 调用 imageView.setImageResource()方法 代码如下12345private ImageView imageView;imageView = (ImageView)findViewById(R.id.image_view);imageView.setImageResource(R.drawable.img_2); ProgressBar ProgressBar 代码如下 123456&lt;ProgressBar android:id="@+id/progress_bar" android:layout_width="match_parent" android:layout_height="wrap_content" style="?android:attr/progressBarStyleHorizontal" android:max="100"/&gt; 常用属性 android：visibility 是否可见 取值 visible invisible gone style=”?android:attr/progressBarStyleHorizontal”android:max=”100”设定显示方式为横向进度条，进度条最大值100 进度条有关设置 显示/隐藏进度条progressBar.setVisibility()方法 12345678910private ProgressBar progressBar;progressBar = (ProgressBar)findViewById(R.id.progress_bar);//设置ProgressBarif(progressBar.getVisibility() == View.GONE)&#123; progressBar.setVisibility(View.VISIBLE);&#125; else &#123; progressBar.setVisibility(View.GONE);&#125; 设置进度条进度 123int progress = progressBar.getProgress();progress +=10;progressBar.setProgress(progress); AlertDialog AlertDialog 代码如下 123456789101112131415161718AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);dialog.setTitle("This is Dialog");dialog.setMessage("something important");dialog.setCancelable(false);//setPositiveButton设定OK点击事件dialog.setPositiveButton("OK",new DialogInterface.OnClickListener()&#123;@Override public void onClick(DialogInterface dialog,int which)&#123; &#125;&#125;);//setNegativeButton设定Canncel点击事件dialog.setNegativeButton("Canncel",new DialogInterface.OnClickListener()&#123;@Override public void onClick(DialogInterface dialog,int which)&#123; &#125;&#125;);//显示 AlertDialogdialog.show(); ProgressDialog ProgressDialog与AlertDialog类似，但是会额外显示一个进度条 代码如下 12345678910//新建ProgressDialog对象ProgressDialog progressDialog = new ProgressDialog(MainActivity.this);//设置标题progressDialog.setTitle("This is ProgressDialog");//设置内容progressDialog.setMessage("Loading...");//是否可以返回键取消progressDialog.setCancelable(false);//显示progressDialog.show(); 效果如图 PS：progressDialog.setCancelable();属性设置为false时表示ProgressDialog无法通过Back键取消。只能通过progressDialog.dismiss()方法取消 四种基本布局LinearLayout 线性布局 线性方向上依次排列 基础效果如下1234567891011121314151617181920212223242526&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="ljy.com.uilayouttest.MainActivity"&gt; &lt;Button android:id="@+id/button_1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button_1"/&gt; &lt;Button android:id="@+id/button_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button_2"/&gt; &lt;Button android:id="@+id/button_3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button_3"/&gt;&lt;/LinearLayout&gt; 基础属性 android：orientation LinearLayout 的排列方向，取值有两种 horizontal横向和vertical竖向，不指定 android：orientation时，默认 horizontal android:layoutgravity 指定控件在布局中的对齐方式。该属性与 LinearLayout 的排列方向有很大关系。 android:layoutweight 允许使用比例方式指定控件大小,计算控件大小时，系统非将所有控件的android:layoutweight 值相加，当作基底，计算指定的大小比例 EditText和Button常见用法 12345678910111213 &lt;EditText android:id="@+id/button_1" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="Button_1"/&gt;&lt;Button android:id="@+id/button_2" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:text="Button_2"/&gt; 指定android:layoutwidth 为0dp，android:layoutweight=”1”均为1 平分大小 另一种用法 123456789101112 &lt;EditText android:id="@+id/button_1" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="Button_1"/&gt;&lt;Button android:id="@+id/button_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button_2"/&gt; 将Button的android:layout_width设定为wrap_content，EditText 的android:layoutweight=”1”，EditText会占满整个屏幕剩余部分，在适配屏幕时较常用 RelativeLayout相对布局 属性较多，以代码形式说明相对父布局位置 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="ljy.com.uilayouttest.MainActivity"&gt; &lt;Button android:id="@+id/button_1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentLeft="true" android:layout_alignParentTop="true" android:text="Button 1"/&gt; &lt;Button android:id="@+id/button_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentRight="true" android:layout_alignParentTop="true" android:text="Button 2"/&gt; &lt;Button android:id="@+id/button_3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="Button 3"/&gt; &lt;Button android:id="@+id/button_4" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:layout_alignParentLeft="true" android:text="Button 4"/&gt; &lt;Button android:id="@+id/button_5" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:layout_alignParentRight="true" android:text="Button 5"/&gt;&lt;/RelativeLayout&gt; android:layout_alignParentLeft=”true”android:layout_alignParentTop=”true”android:layout_centerInParent=”true”android:layout_alignParentBottom=”true”android:layoutalignParentRight=”true” 简而言之这些属性指定了控件相对父布局的位置 相对控件位置 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="ljy.com.uilayouttest.MainActivity"&gt; &lt;Button android:id="@+id/button_3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="Button 3"/&gt; &lt;Button android:id="@+id/button_1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_above="@id/button_3" android:layout_toLeftOf="@id/button_3" android:text="Button 1"/&gt; &lt;Button android:id="@+id/button_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_above="@id/button_3" android:layout_toRightOf="@id/button_3" android:text="Button 2"/&gt; &lt;Button android:id="@+id/button_4" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@id/button_3" android:layout_toLeftOf="@id/button_3" android:text="Button 4"/&gt; &lt;Button android:id="@+id/button_5" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@id/button_3" android:layout_toRightOf="@id/button_3" android:text="Button 5"/&gt;&lt;/RelativeLayout&gt; 说明 android:layout_above 可以指定一个控件位于指定控件的上方，需要指定ID引用 android:layout_below 指定一个控件位于指定控件的下方，id引用 android:layout_toLeftOf 指定一个控件位于指定控件的左侧，id引用 android:layout_toRightOf 指定一个控件位于指定控件的右侧，id引用。 NOTE：当控件去引用另一个控件的ID时，引用控件一定要在前本例中是id/button3在最前面 FrameLayout帧布局 所有控件默认左上角 代码如下两个控件重合 1234567891011121314&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TextView"/&gt; &lt;ImageView android:id="@+id/image_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher"/&gt;&lt;/FrameLayout&gt; android:layoutgravity 同样可以应用于FrameLayout中，指定对齐方式 PercentFrameLayout百分比布局 PercentFrameLayout并非内置于系统SDK中，使用前要在build.gradle中添加百分比布局的依赖。 修改app/build.gradle文件，在dependencies闭包中增加依赖。 12345678910dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.0.1' //下面一行为增加内容，要与上面的版本号保持一致 compile 'com.android.support:percent:25.0.1' testCompile 'junit:junit:4.12'&#125; 修改完成后，as会开始同步，同步完成即可。 PercentFrameLayout继承了FrameLayout的特性，所有控件默认左上角，需要通过android:layoutgravity 来调整位置 源码如下 12345678910111213141516171819202122232425262728293031323334# PercentFrameLayout 并非系统内置SDK，需要声明完整包路径&lt;android.support.percent.PercentFrameLayout# 随后定义app的命名空间 xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button1" android:text="Button1" android:layout_gravity="left|top" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt; &lt;Button android:id="@+id/button2" android:text="Button2" android:layout_gravity="right|top" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt; &lt;Button android:id="@+id/button3" android:text="Button3" android:layout_gravity="left|bottom" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt; &lt;Button android:id="@+id/button4" android:text="Button4" android:layout_gravity="right|bottom" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt;&lt;/android.support.percent.PercentFrameLayout&gt; 效果如图 与之类似的还有 PercentRelativeLayout，用法不加累赘 自定义控件引入布局 新建title.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/title_bg"&gt; &lt;Button android:id="@+id/title_back" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="5dp" android:background="@drawable/back_bg" android:text="Back" android:textColor="#fff" /&gt; &lt;TextView android:id="@+id/title_text" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_weight="1" android:gravity="center" android:text="Title Text" android:textColor="#fff" android:textSize="24sp" /&gt; &lt;Button android:id="@+id/title_edit" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="5dp" android:background="@drawable/edit_bg" android:text="Edit" android:textColor="#fff" /&gt;&lt;/LinearLayout&gt; 在activitymain.xml 中使用title.xml &lt;include layout=&quot;@layout/title&quot;/&gt; 隐藏系统自带标题栏,在mainActivity的onCreat中添加如下代码。 123 ActionBar actionBar = getSupportActionBar();if (actionBar != null) actionBar.hide(); 效果如下 自定义控件 创建TitleLayout继承自LinearLayout ，代码如下123456789public class TitleLayout extends LinearLayout &#123;//构造函数 public TitleLayout(Context context, AttributeSet attributeSet)&#123; super(context,attributeSet); //调用LayoutInflater.from方法构建LayoutInflater对象， //再调用inflate加载布局文件 LayoutInflater.from(context).inflate(R.layout.title,this); &#125;&#125; 再activitymain.xml 中 添加自定义控件,添加自定义控件时要指明控件的完整类名 123&lt;ljy.com.uicustomviews.TitleLayout android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; 效果与引入布局文件相同 注册按钮点击事件 在TitleLayout的构造函数添加按钮注册点击事件1234567891011121314151617Button titleBack = (Button)findViewById(R.id.title_back);Button titleEdit = (Button)findViewById(R.id.title_edit);titleBack.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //模拟返回键 ((Activity)getContext()).finish(); &#125; &#125;); titleEdit.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //Toast通知 Toast.makeText(getContext(),"clik",Toast.LENGTH_SHORT).show(); &#125; &#125;);]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记—Activity]]></title>
    <url>%2F2016%2F12%2F07%2FAndroid%E7%AC%94%E8%AE%B0-Activity%2F</url>
    <content type="text"><![CDATA[资料来源如下 第一行代码(第二版) Activity基础Activity定义 Activity 是Android四大组件之一，用户可与其提供的屏幕进行交互，以执行操作。 每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口可以充满屏幕，也可浮动。应用通常由多个彼此联系的 Activity 组成。应用中的某个 Activity 为“主”Activity，即首次启动应用时的Activity。 创建Activity 新建FirstAtivity继承自AppCompatActivity 12345public class FirstActivity extends AppCompatActivity&#123;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);&#125; &#125; 创建加载布局 切换到first-layout 1234567891011 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button_1" android:text="button_1" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 在FirestActivity中加载layout 在onCreate中加入 1setContentView(R.layout.first_layout); 在AndroidMainfest文件中注册。 12345678&lt;activity android:name=".FirstActivity" android:label="This is FirstActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 在模拟器中启动apk 使用Toast Toast google官方说明 推送一个短小信息推送给用户 如图（摘自android developer） 使用方法 1Toast.makeText(context, text, duration).show(); 举例 12Toast.makeText(FirstActivity.this, "you clicked button 1", Toast.LENGTH_SHORT).show();/* activity.this 消息内容 显示时间设置 */ 使用Menu 创建菜单 在res下新疆menu文件夹，右击menu文件夹—new—Menu resource file，创建main的菜单文件。 main.xml中添加如下代码 123456789 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@+id/add_item" android:title="Add"/&gt; &lt;item android:id="@+id/remove_item" android:title="Remove"/&gt;&lt;/menu&gt; 这里创建了两个菜单项 Add和Remove 在FirestActivity中重写 onCreateOptionsMenu()方法（快捷键 Ctrl+O） 12345 @Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return true;&#125; getMenuInflater()可以得到MenuInflater对象，再调用.inflate就可以创建菜单。.inflat接受俩个参数，一是资源文件名，二是菜单项添加至那个对象中。onCreateOptionsMenu方法中返回true表示创建菜单并显示。 效果如下。 创建菜单点击响应事件 重写onOptionsItemSelected方法 12345678910111213@Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(this, "Add", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, "Remove", Toast.LENGTH_SHORT).show(); break; default: &#125; return true; &#125; 通过item.getItemId()判断点击选项，弹出不同的Toast 向一个activity 并传递字符串 构建一个Intent Intent intent = new Intent(this, DisplayMessageActivity.class); 构造方法有两个参数： Context 是第一个参数，这里使用了this是因为Activity是Context的子类。 Class 类是系统将要分发的APP组件，在这里，这个Activity将会被启动。 12345678910111213public void sendMessage(View view) &#123; // 创建一个新的intent对象，绑定DisplayMessageActivity Intent intent = new Intent(this, DisplayMessageActivity.class); //创建一个editText对象，绑定xml中editText EditText editText = (EditText) findViewById(R.id.edit_message); //获取editText中输入文字，转成字符串 String message = editText.getText().toString(); //一个Intent对象可以携带被称为extras的键值对。 // putExtra()方法将键放在第一个参数中，将值放在第二个参数中。 intent.putExtra(EXTRA_MESSAGE, message); //启动intent对应Activity startActivity(intent); &#125; 1234567891011121314151617181920protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_display_message); //创建本地intent Intent intent = getIntent(); //取出String类型数据，如果是Int类型就是getIntExtra，Boolean类型就是getBooleanExtra String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE); //显示String //创建新的TextView TextView textView = new TextView(this); //设置文本大小 textView.setTextSize(40); //设置显示内容 textView.setText(message); //绑定xml ViewGroup layout = (ViewGroup) findViewById(R.id.activity_display_message); //ViewGroup中添加TextView layout.addView(textView);&#125; 返回数据给上一个Activity 构建Intent使用startActivityForResult()方法传入请求码，启动下一个Activity在下一个Activity中构建Intent，intent.putExtra存入键值-key，调用setResult()方法，传入finish()结束掉Activity重写第一个Activity中的onActivityResult()方法，调用.getStringExtra取出key对应键值。 startActivityForResult(Intent, int Bundle) Intent与单纯启动Activity的Intent相同，第二个是请求码，下一级 回调提供相同的请求码，以便您应用可以正确识别结果。 12Intent intent = new Intent(FirestActivity.this,ScendActivity.class);startActivityForResult(intent,1); setResult()方法，第一个参数向上级方法处理结果，一般使用RESULT_OK或RESULT_CANCELED，第二个参数 对应Intent 1234567//新建显示IntentIntent intent = new Intent();//存入key-键值intent.putExtra("data_return","Hello Firest");setResult(RESULT_OK,intent);//结束Activityfinish(); onActivityResult()三个参数.第一个startActivityForResult() 传递的请求代码。第二个 Activity 指定的结果代码。成功是 RESULT_OK；失败，则是 RESULT_CANCELED。第三个是传送结果数据的 Intent。 12345678910111213 @Overrideprotected void onActivityResult(int requestCode,int resultCode,Intent data)&#123; //选择不同请求码对应处理逻辑 switch(requestCode)&#123; case 1: //处理结果时候ok if(resultCode == RESULT_OK)&#123; //取出数据 String returnedData = data.getStringExtra("data_return"); Log.d("FirstActivity", returnedData); &#125; &#125;&#125; Activity生命周期 Activity 3种状态 Resumed/继续Activity 处于前台，且用户可以与其交互 Paused/暂停 Activity 被在前台中处于另一个 Activity—部分阻挡。 暂停的 Activity 不会接收用户输入并且无法执行任何代码。 Stopped/停止Activity完全隐藏，对用户完全不可见.当停止时，activity的所有状态信息比如成员变量都会被保留，但是不能再执行任何代码 启动一个Activity onCreate方法 主Activity： 用户点击app图标，启动主Activity 在AndroidManifest.xml中声明1234&lt;intent-filter&gt;&lt;action android:name="android.intent.action.MAIN" /&gt;&lt;category android:name="android.intent.category.LAUNCHER" /&gt;&lt;/intent-filter&gt; 通过调用onCreate方法创建一个Activity实例，onCreate方法在Activity的整个生命周期中只执行一次。 之后系统会很快的调用onStart和onResume方法，Activity进入Resumed/继续模式。直到被其他activity覆盖/屏幕关闭。销毁Activity onDestory方法大多数的APP不需要实现这个方法，因为本地类引用会随着Activity一起总结，不过Activity的清理工作应该放在onPause下或者onStop。 Note:在所有的情况下系统调用onDestory方法之后已经调用过onPause方法与onStop方法，不过有一个例外情况：你在onCreate方法中调用了finish方法。在一些例子中，当你的Activity临时决定要启动另一个Activity，你可能要在onCreate方法内调用finish方法来销毁这个Activity，在这种情况下，系统会立即调用onDestory方法，而不会调用其它任何生命周期方法。 暂停Activity onPause()方法 Activity被其他Activity覆盖/失去用户焦点，系统调用onPause()方法，Activity 进入暂停状态。 note：android7.0及以上版本加入了多窗口模式，当Activity失去用户焦点时，可能处于多窗口模式。 onPause() 常用回调： 检查 Activity 是否可见。不可见则停止可能消耗 CPU 的操作 提交未保存的更改，仅保存用户离开时希望永久性保存此类更改（比如电子邮件草稿）。 释放系统资源，GPS/Camer等 示例 (释放Camer) 123456789public void onPause() &#123;super.onPause(); // Always call the superclass method first// Release the Camera because we don't need it when paused// and other activities might need to use it.if (mCamera != null) &#123; mCamera.release(); mCamera = null;&#125; 注意事项： 在onPause()一般不执行永久性存储用户更改，不执行 CPU 密集型工作，这些工作一般放在onStop() 。 继续 Activity onResume() 方法 暂停状态回到继续状态，Activity第一次启动时也会调用这个方法。 onResume() 以初始化在 onPause() 期间释放的组件。 示例(重新获取Camera)1234567public void onResume() &#123; super.onResume(); // Always call the superclass method first // Get the Camera instance as the activity achieves full user focus if (mCamera == null) &#123; initializeCamera(); // Local method to handle camera init &#125; 停止 Activity note：大多数相对简单的 Activity 而言，系统在 Activity 停止时会将Activity 实例保留在系统内存中，无需实现 onStop() 和 onRestart() 或甚至onStart() 方法。可能只需使用 onPause() 暂停正在进行的操作，并从系统资源断开连接。 onStop() 方法 场景： 用户在最近应用切换到另一个应用 应用中执行开始新 Activity 的操作 Activity使用时，接打电话 调用时，Activity不再可见，释放几乎所有用户不使用时不需要的资源。如果系统内存紧张，则可能销毁内存中的Acitivity实例。 onStop() 方法调用后，Activity不再可见，极端情况下，系统可能会仅终止应用进程，而不调用 onDestroy() ，因此需要使用 onStop() 释放几乎所有用户不使用时不需要的资源。 尽管 onPause() 方法在 onStop()之前调用，在onStop() 执行更大、占用更多 CPU 的关闭操作，比如向数据库写入信息 示例（草稿笔记内容保存在永久存储）12345678910111213141516 protected void onStop() &#123; super.onStop(); // Always call the superclass method first // Save the note's current draft, because the activity is stopping // and we want to be sure the current note progress isn't lost. ContentValues values = new ContentValues(); values.put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText()); values.put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle()); getContentResolver().update( mUri, // The URI for the note to update. values, // The map of column names and new values to apply to them. null, // No SELECT criteria are used. null // No WHERE columns are used. );&#125; 启动/重启 Activity onStart() 方法 Activity 停止转换为继续状态时，系统回调onRestart() 方法+ onStart() 方法.onStop() 方法清理了所有 Activity 的资源，重启 Activity 需要重新实例化它们。同时 Activity 初次创建时重新实例化它们。 出于此，经常使用 onStart() 方法作为 onStop() 方法的对应 示例1234567891011121314151617181920212223 @Overrideprotected void onStart() &#123; super.onStart(); // Always call the superclass method first // The activity is either being restarted or started for the first time // so this is where we should make sure that GPS is enabled LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE); boolean gpsEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER); if (!gpsEnabled) &#123; // Create a dialog here that requests the user to enable GPS, and use an intent // with the android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS action // to take the user to the Settings screen to enable GPS when they click "OK" &#125;&#125;@Overrideprotected void onRestart() &#123; super.onRestart(); // Always call the superclass method first // Activity being restarted from stopped state&#125; 保存 Activity 状态 onSaveInstanceState()方法 默认情况下，Activity 实例被销毁时系统会使用 Bundle 实例状态保存 Activity 布局中有关每个 View 对象的信息。在Activity 重建时，布局状态便自动恢复先前的状态。 默认实现保存有关 Activity 视图层次的状态信息，例如 EditText 小部件中的文本或ListView 的滚动位置 要恢复的更多信息，需要重写 onSaveInstanceState()方法，将键值对添加至 Bundle 对象 note:旋转屏幕时，Activity 将被销毁并重新创建。原因：方向更改时可能需要时加载备用资源（比如布局） 示例12345678910111213static final String STATE_SCORE = "playerScore";static final String STATE_LEVEL = "playerLevel";...@Overridepublic void onSaveInstanceState(Bundle savedInstanceState) &#123; // Save the user's current game state savedInstanceState.putInt(STATE_SCORE, mCurrentScore); savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel); // Always call the superclass so it can save the view hierarchy state super.onSaveInstanceState(savedInstanceState); &#125; 恢复 Activity onCreate() 和 onRestoreInstanceState() 回调方法均接收包含实例状态信息的相同 Bundle onCreate() 方法 调用onCreate() 方法需要区分是创建 Activity 的新实例还是恢复先前的实例，判断 Bundle 是否为 null 示例 1234567891011121314@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Always call the superclass first // Check whether we're recreating a previously destroyed instance if (savedInstanceState != null) &#123; // Restore value of members from saved state mCurrentScore = savedInstanceState.getInt(STATE_SCORE); mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL); &#125; else &#123; // Probably initialize members with default values for a new instance &#125; ...&#125; onRestoreInstanceState()方法 只需要恢复的已保存的状态 示例12345678 public void onRestoreInstanceState(Bundle savedInstanceState) &#123; // Always call the superclass so it can restore the view hierarchy super.onRestoreInstanceState(savedInstanceState); // Restore state members from saved instance mCurrentScore = savedInstanceState.getInt(STATE_SCORE); mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);&#125; 重启Activity其他选择 官方说明 重启应用并恢复大量数据不仅成本高昂，而且会留下糟糕的使用体验，有两个其他选择在配置变更期间保留对象 Activity 因配置变更而重启，则可通过保留 Fragment 来减轻重新初始化 Activity 的负担 当 Android 系统因配置变更而关闭 Activity 时，不会销毁已标记为要保留的 Activity 的片段。 您可以将此类片段添加到 Activity 以保留有状态的对象。 Activity最佳实践知晓当前运行的活动 自定义BaseActivity继承自AppCompatActivity重写onCreate方法，打印当前运行的Activity名app类所有Activity改为继承BaseActivity 代码如下 1234567public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //打印当前类名 Log.d("BaseActivity", getClass().getSimpleName())； &#125; 效果如下 随时退出程序 新建ActivityCollector类作为活动管理器，添加/删除Activity登记,在BaseActivity中添加对应代码。 代码如下 1234567891011121314151617181920 public class ActivityCollector &#123;//新建Activity的列表对象 public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;();//添加Activity进入列表 public static void addActivity(Activity activity) &#123; activities.add(activity); &#125;//在列表中移除Activity public static void removeActivity(Activity activity) &#123; activities.remove(activity); &#125;//for循环列表 结束所有Activity public static void finishAll() &#123; for (Activity activity : activities) &#123; if (!activity.isFinishing()) &#123; activity.finish(); &#125; &#125; &#125; &#125; BaseActivity在onCreate()方法中添加 12//Activity管理器中添加新的活动ActivityCollector.addActivity(this); 重写onDestroy()方法 123456@Overrideprotected void onDestroy()&#123; super.onDestroy(); //Activity管理器中移除活动 ActivityCollector.removeActivity(this);&#125; 在任何地方调用finishAll()方法即可。 启动活动的最近写法 启动下一个Activity并传递数据模块化 在SecondActivity内增加actionStart()方法 12345678910 //调用的Activity，数据1，数据2 public static void actionStart(Context context, String data1, String data2)&#123; //新建Intent，绑定SecondActivity Intent intent = new Intent(context,ScendActivity.class); //存入data1，data2 intent.putExtra("param1",data1); intent.putExtra("param2",data2); //启动Activity context.startActivity(intent);&#125; 启动SecondActivity方式ScendActivity.actionStart(FirestActivity.this,&quot;data1&quot;,&quot;data2&quot;);]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初入树莓派2---初始化+远程桌面]]></title>
    <url>%2F2016%2F11%2F27%2F%E5%88%9D%E5%85%A5%E6%A0%91%E8%8E%93%E6%B4%BE2----%E5%B8%B8%E8%A7%84%E5%88%9D%E5%A7%8B%E5%8C%96%2B%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[初始化启用树莓派root用户 不做物联网终端时启用root用户比较方便 SSH连接树莓派 在命令行下执行 启用root用户 1sudo passwd root 执行后输入两遍你要设定的root密码 在输入1sudo passwd –unlock root root用户解锁完成 执行完毕后依旧无法登陆 执行 1sudo nano /etc/ssh/sshd_config 找到PermitRootLogin without-password 改为PermitRootLogin yes Ctrl + X 、 Y 、 回车 保存 sudo reboot 更换国内镜像地址 &gt; http://blog.lxx1.com/2040 由于众所周知的原因，树莓派链接官方更新源实在太过缓慢，国内有一批不错的镜像地址，可以解决系统/软件更新问题。 收集的树莓派镜像一般使用比较频繁的有下面几个1.阿里云 首推镜像地址，移动/联通/电信网络都有不错的访问速度。2.大连东软信息学院 北方用户比较友好3.中国科学技术大学 教育网有加成，非教育网就慢多了 这里选择 阿里云的镜像 更新 sources.list 执行 1sudo nano /etc/apt/sources.list 删除官方内容或者用#注释掉，添加以下内容 12deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contribdeb-src http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib 删除raspi.list备用更新源(可选) 通常更新sources.list后依旧缓慢，大多是raspi.list的锅 rm /etc/apt/sources.list.d/raspi.list 设置中文字体 系统中缺少中文字库 首先更新字库和输入法 执行 12sudo apt-get install ttf-wqy-zenheisudo apt-get install scim-pinyin 接下来 都点 y 执行 1sudo raspi-config 选择change_locale 空格键在前面打勾或去掉勾（星号=勾） Tab选择OK 去掉en_GB.UTF-8 UTF-8勾选：”en_US.UTF-8 UTF-8”、”zh_CN.UTF-8 UTF-8”、”zh_CN.GBK GBK” OK，下一屏幕, 默认语言选zh_CN.UTF-8 远程桌面 终端执行 1apt-get install xrdp windows端 CMD 执行 mstsc 输入树莓派ip地址 用户名 密码]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub-Pages更新导致Next主题-博客主页空白，解决方案]]></title>
    <url>%2F2016%2F11%2F08%2FGitHub-Pages%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4Next%E4%B8%BB%E9%A2%98-%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A1%B5%E7%A9%BA%E7%99%BD%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[倒腾了俩小时，以为梯子坏了，结果。。。GitHub-Pages更新了！！！ 原因 GitHub-Pages更新， 过滤掉了 source/vendors 目录的访问。 issues入口 解决1更新主题 作者更新了到最新的master分支，解决了这个问题， So： 1git pull https://github.com/iissnan/hexo-theme-next themes/next 解决2更新本地设置（Next最新版） 将 source/vendors 目录修改成 source/lib （或者其他的名称，只是 lib 我测试了可以使用）；同时，修改下主题配置文件_config.yml， 将 _internal: vendors 改成你所修改的名字，例如 _internal: lib。 解决3更新本地设置（Next5.0及以下版本） 将 source/vendors 目录修改成 source/lib （或者其他的名称，只是 lib 我测试了可以使用）；同时，修改下主题配置文件_config.yml， vendors: vendors 改成你所修改的名字，例如 _internal: lib。]]></content>
      <categories>
        <category>点滴</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自建DNS服务器(dnsmasq)，对抗DNS污染]]></title>
    <url>%2F2016%2F10%2F09%2F%E8%87%AA%E5%BB%BADNS%E8%A7%A3%E5%86%B3%E8%BF%90%E8%90%A5%E5%95%86DNS%E6%B1%A1%E6%9F%93%2F</url>
    <content type="text"><![CDATA[背景 学校网络出口劫持严重，上淘宝加返利———-等等等等等等 一直更新hosts不方便，要上google，全平台不好弄 项目组需要 目的 搭建一个可访问个人公网DNS服务器 提高DNS加载速度 规避运营商的DNS劫持 不影响学校内网访问 简单的能上google 准备 一台有公网IP的vps，开放了53端口（端口扫描显示开放了53端口） 装的是linux系统（以 CentOS 6.4 为例） WinSCP（或其他文件管理） putty.exe（或者其他SSH登陆工具） 没了。。。。 DNSmasq原理和说明 DNSmasq是一个小巧且方便地用于配置DNS和DHCP的工具，适用于小型网络。作为域名解析服务器(DNS)，dnsmasq可以通过缓存 DNS 请求来提高对访问过的网址的连接速度。 通过设置DNSmasq的上游DNS地址为无污染DNS来解决运营商的DNS污染。 DNSmasq可以对单独的网址设置DNS服务器。对于学校内网地址设置为学校教育网的DNS解析。对于类似于youtube这种由于DNS污染没法访问的地址，可以先收集无污染的DNS地址，然后交与无污染DNS解析得到正确地址。 DNSmasq再对网址提交上游DNS解析前，可以先通过本地hosts匹配。设置合适hosts可以实现科学上网。 开始！ 步骤安装dnsmasq 1yum install dnsmasq -y 配置Dnsmasq Dnsmasq的配置文件是 /etc/dnsmasq.conf .通过WinSCP加载修改。 dnsmasq.conf设置项说明 此次使用的配置如下 1234567891011 #指定给dnsmasq使用的hosts addn-hosts=/etc/dnsmasq.host #不使用/etc/resolv.conf(VPS默认DNS)来进行上游dns服务器解析需要配置的比较少直接写在dnsmasq.conf文件里了 no-resolv #上游DNS地址这里为腾讯DNS和中科大DNSserver=119.29.29.29server=202.141.162.123server=/google.com/202.141.162.123 #这一行是针对学校内网访问，学校内地址使用学校内网DNS。具体地区调整。server=/.edu.cn/202.141.162.123 上游DNS推荐 这里需要在VPS上测试各个DNS后决定。 常用靠谱DNS 阿里DNS 223.5.5.5 223.6.6.6 114DNS 114.114.114.114 腾讯DNS 119.29.29.29 V2EX DNS 199.91.73.222 178.79.131.110（访问苹果商店有buff加速） 无污染DNS 目前比较稳定的只有中科大DNS和一些自建的小型DNS。小型DNS通过反带来访问google等，会带来一些隐私和安全风险，还是推荐自建DNS/hosts访问。 中科大DNS 202.38.93.153 （教育网） 202.141.176.93 （中国移动） 202.141.162.123 （中国电信） 其他DNS请自行GOOGLE 千万注意！！！ 配置文件中有listen-address配置，网络大多数教程中有listen-address=127.0.0.1这是指Dnsmasq只服务于本机的DNS请求。如果需要搭建公网DNS服务，这个绝对不能有！！ 创建/修改/etc/dnsmasq.host文件 一些常用去广告hosts/科学上网hosts的内容， 具体不多说hosts科学上网是一天比一天死的快。没有找到靠谱的地址推荐。自行搜索把！ 重启Dnsmasq服务 1sudo service dnsmasq restart 测试53端口 1netstat -tunlp|grep 53 如果正常应该如下 123[root@VM_27_70_centos ~]# netstat -tunlp|grep 53tcp 0 0 0.0.0.0:53 0.0.0.0:* LIST EN 4226/dnsmasqudp 0 0 0.0.0.0:53 0.0.0.0:* 4226/dnsmasq 修改本地DNS地址 这个不多说了，不会的自行google了。。 结束语创建完了，本地DNS快多了，访问淘宝再也没有了牛皮癣。 参考文献 http://blog.antior.cn/posts/2015_29.htmlhttp://www.jianshu.com/p/71ccc79aaa9ehttp://www.linuxdown.net/install/soft/2016/0520/5566.htmlhttp://blog.cnwyhx.com/centos-linux-dnsmasq-install-dns/]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android]]></title>
    <url>%2F2016%2F07%2F17%2FAndroid%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Andorid笔记系列1234567891011121314151617181920更新2016.07.20 第一行代码Activity创建部分完成2016.07.21 完成添加了button和menu部分，对应P39页2016.07.22 完成了P55页之前的activity部分。对于activity（二）2016.08.10 基本搞定，UI除ListView以外的部分。4种布局比较熟悉，不再折腾。2016.08.11 开始ListView部分2016.08.14 停更半月2016.09.02 恢复更新2016.09.03 Broadcast部分开坑。2016.09.07 ListView部分除BaseAdapter外完成。BaseAdapter内容，什么时候理解深一点再补上。2016.09.13 完成了Broadcast对应部分2016.10.03 重新按照google的文档查漏补缺.2016.10.03 更名Android笔记，重新开始更新。2016.12.05 第二行代码开始！2016.12.07 重新整理Android系列笔记，从0整合2016.12.08 Activity部分整合完成2016.12.13 UI部分基础完成，LIstView部分完成2016.12.16 RecycleView部分，基础完成，有待进一步填坑 2016.12.22 Fragment完成，有一个占坑2016.12.23 Broadcast完成]]></content>
      <categories>
        <category>Android笔记</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机课程设计总结]]></title>
    <url>%2F2016%2F07%2F09%2F%E5%8D%95%E7%89%87%E6%9C%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[累死人的单片机课程设计终于结束了，忙了两天多。就是个数码管+ADC。看看自己两年多前写的程序。。这感觉。用了一天多重构。。。。之前写程序的那个乱啊。。。重新整理下，自己的库函数。记录于此。 1602库函数1602.h1234567891011121314151617181920212223242526272829303132333435363738/*模 块 名： LCD1602 *//*创 建 人：zyy 日期：2014-11-04 *//*修 改 者：js 日期：2016-07-08 *//*版 本2.1 *//*使用方法：首先调用LCD初始化函数void LcdInit()； 输入一个double类型数据调用void LcdDisplay(double temp); 显示在第二行；如需修改第一行数据可在LcdDisplay函数中修改 *//* BUG : 第二行double数据显示最后一位后，会跟随一位乱码 */#include &lt;stc12c5a60s2.h&gt; #include &lt;intrins.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define uint unsigned int#define uchar unsigned charsbit lcdrs = P1^7;sbit lcden = P2^4;sbit rw = P1^6;#define lcd_data_port P0void sdelay(uint s); //通用延迟函数void write_com(uchar com); //并口写数据void write_data(uchar date); //并口写数据void LcdInit(); //1602初始化void LcdDisplay(double temp,uint t); //显示函数 1602.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//1602.cinclude &lt;1602.h&gt;/*模 块 名： LCD1602 *//*创 建 人：zyy 日期：2014-11-04 *//*修 改 者：js 日期：2016-07-08 *//*版 本2.1 *//**********************************************/void sdelay(uint s) //通用延迟函数&#123; uint x,y; for(x=s;x&gt;0;x--) for(y=250;y&gt;0;y--);&#125;/**********************************************/void write_com(uchar com) //并口写数据&#123; lcdrs=0; lcden=0; lcd_data_port=com; sdelay(1); lcden=1; sdelay(1); lcden=0;&#125;void write_data(uchar date) //并口写数据&#123; lcdrs=1; lcden=0; lcd_data_port=date; sdelay(1); lcden=1; sdelay(1); lcden=0;&#125;/*********************************************************************** 函 数 名: LcdInit* 功能描述: LCD初始化* 函数说明: 初始化数据：0x38 0x0c 0x06 0x01* 调用函数: sdelay（），write_com（）， write_data（）* 输 入: 无* 返 回: 无* 设 计 者：zyy 日期：2014-12-23* 版 本： 1.0***********************************************************************/void LcdInit() //1602初始化&#123; lcden=0; rw=0; write_com(0x38); write_com(0x0c); write_com(0x06); write_com(0x01);&#125;/*********************************************************************** 函 数 名: LcdDisplay* 功能描述: LCD显示* 函数说明: double类型数据转化为字符串，在lcd第二行显示。* 调用函数: sprintf(),write_com(),sdelay()* 全局变量: 无* 输 入: 一个double类型变量值* 返 回: 无* 设 计 者：zyy 日期：2014-12-23* 修 改 者：js 日期：2016-07-08* 版 本： 2.0***********************************************************************/void LcdDisplay(double temp,uint t) //显示函数&#123;static uchar table0[]=&#123;"pm "&#125;; //1602默认第一行static uchar table1[]=&#123;"00.0 "&#125;;uchar num=0;sprintf(table1,"%f",(double)temp);sprintf(table1+8,"%2d",(uint)t); write_com(0x80); for(num=0;num&lt;15;num++) //第一行刷新 &#123; write_data(table0[num]); sdelay(5); &#125; write_com(0x80+0x40); for(num=0;num&lt;16;num++) //第二行显示 &#123;write_data(table1[num]); //0.0195 sdelay(5); &#125;&#125; 数码管 对应电路图如下shu.h12345678910111213141516171819202122232425262728293031323334353637/*模 块 名： 数码管 *//*创 建 人：zy 日期：2014-07-01 *//*版 本1.2 *//*使用方法：调用 Shu_Display(double js)函数，输入一个double类型数据， 固定显示格式为小数点前4位及小数点后两位。 *//*BUG：显示小数点后第二位时，有时会与输入值小1.原因疑似与fmod()函数有关 */#include &lt;stc12c5a60s2.h&gt; #include &lt;intrins.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define uint unsigned int#define uchar unsigned char //端口定义#define io_dm P0 //定义LED显示的段码数据脚sbit io_shu = P2^3; //数码管开关低电平有效sbit io_A = P2^0; //3-8译码器输入sbit io_B = P2^1;sbit io_C = P2^2;sbit io_DP = P0^7; //dp点定义extern uchar du_num[15];void delay_1ms(uchar x); //1ms延迟函数void wei(uchar i); //位选输出函数void Shu_Display(double js);//数码管显示函数 shu.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;shu.h&gt; /*模 块 名： 数码管 *//*创 建 人：zy 日期：2014-07-01 *//*版 本1.2 *///显示数字uchar du_num[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71&#125;;// 0 1 2 3 4 5 6 7 8 9 a b c d e f void delay_1ms(uchar x)//1ms延迟函数&#123; uchar j; while(x--)&#123; for(j=0;j&lt;125;j++) &#123;;&#125; &#125; &#125;void wei(uchar i) //位选信号输入&#123; //i=i+1; switch (i) &#123; case 0:&#123;io_A=0;io_B=0;io_C=0;&#125; break; case 1:&#123;io_A=1;io_B=0;io_C=0;&#125; break; case 2:&#123;io_A=0;io_B=2;io_C=0;&#125; break; case 3:&#123;io_A=1;io_B=1;io_C=0;&#125; break; case 4:&#123;io_A=0;io_B=0;io_C=1;&#125; break; case 5:&#123;io_A=1;io_B=0;io_C=1;&#125; break; case 6:&#123;io_A=0;io_B=1;io_C=1;&#125; break; default: ; break; &#125;&#125; /*********************************************************************** 函 数 名: Shu_Display() * 功能描述: 将数字显示到数码管上，显示格式4+2* 函数说明: 段选位选，动态刷新数码管* 调用函数: delay_1ms fmod()* 全局变量: 无* 输 入: 1个double类型数据* 返 回: 无* 设 计 者：zy 日期：2014-07-01 * 修 改 者：zy 日期：2016-07-08* 版 本： 1.2***********************************************************************/void Shu_Display(double js)&#123;uchar i; //循环变量 static uchar suff[6]; //数据处理暂存数组 static uint cuff[4]; //提取各位有关 static double n=1,y; //与小数截取有关 static uint count; //暂存 y=fmod(js,n); //分离js小数部分 存在y中 count=js; //强制类型转换，取js整数部分 suff[0] = count/1000; //取千位 cuff[0] = count%1000; suff[1] = cuff[0]/100; //取百位 cuff[1] = cuff[0]%100; suff[2] = cuff[1]/10; //取十位 suff[3] = cuff[1]%10; //取个位 count = y*1000; //小数部分。扩大1000倍提取。 cuff[2] = count%1000; suff[4] = cuff[2]/100; //小数点后一位 cuff[3] = cuff[2]%100; suff[5] = cuff[3]/10; //小数点后2位 io_shu=0; //打开3-8译码器 for(i=0;i&lt;6;i++) &#123; wei(i); //位选 io_dm=du_num[suff[i]];//段选 if(i==3) io_DP=1; delay_1ms(1); //延迟 &#125; &#125;]]></content>
      <categories>
        <category>电子类</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网教程（二）——VPS优化加速]]></title>
    <url>%2F2016%2F06%2F27%2FVPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%972%2F</url>
    <content type="text"><![CDATA[12345678910更新2016.06.26 与SSR有关部分基本完成。2016.06.28 TCP优化部分完成2016.06.29 gfw.press、FinalSpeed和锐速部分基本完成。2016.12.11 重新整理相关内容，增加SSR混淆2016.12.15 增加TCP-BBR2017.01.11 整理相关内容，增加锐速配置优化 2017.03.28 更新一部分配置内容，删除无效内容2017.04.02 因91yun被爆隐私问题，删除其对应内容2017.07.03 更新大量锐速/bbr内容，移除GFW.Press和其他内容 TCP优化（非BBR适用）使用建议 建议科学上网服务器都进行一遍TCP优化 与其他加速手段兼容 使用 BBR 加速可以略过此部分(已包含) 具体步骤 适用场景：高延迟搞丢包线路 增加TCP连接数量 1nano /etc/security/limits.conf 添加两行： 12* soft nofile 51200* hard nofile 51200 保存(Ctrl + X —— y ——回车) 设置ulimit： 1ulimit -n 51200 修改内核参数适合的还是hybla（高延迟高丢包率环境）首先看一下VPS现有算法： 1sysctl net.ipv4.tcp_available_congestion_control 没有hybla时，加载hybla算法. 1/sbin/modprobe tcp_hybla 开始修改 1nano /etc/sysctl.conf 复制代码： 1234567891011121314151617181920212223#TCP配置优化(不然你自己根本不知道你在干什么)fs.file-max = 51200#提高整个系统的文件限制net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.core.netdev_max_backlog = 250000net.core.somaxconn = 4096net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_fastopen = 3net.ipv4.tcp_mem = 25600 51200 102400net.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = hybla#END OF LINE 保存(Ctrl + X —— y ——回车) 应用 1sysctl -p 重启SSR 1/etc/init.d/shadowsocks restart 锐速 介绍锐速（ServerSpeeder）加速软件是一种基于ZETATCP加速引擎的软件，只需单边部署就可以起到 显著加速效果的 TCP 加速技术。 使用建议(7.03) 除非对隐私要求特别高，加速手段首先参数锐速 与 BBR 目前不兼容，二者取其一可满足大部分需要加速场景 默认参数即可满足大部分场景，除非很慢，否则不推荐更改配置文件 锐速目前已经基本停止运营，而且母公司LotServer面向企业用户还在运营 以下提供的破解版安装方式，收集自网络。仅供个人实验使用，请支持正版。 锐速安装 安装包来自 @Vicer 感谢原作者！ 锐速一键安装包 参考 https://github.com/0oVicero0/serverSpeeser_Install 安装 1wget --no-check-certificate -qO /tmp/appex.sh "https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh" &amp;&amp; bash /tmp/appex.sh 'install' 中间提示全部输入 y 即可，等待安装完成 卸载 1wget --no-check-certificate -qO /tmp/appex.sh "https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh" &amp;&amp; bash /tmp/appex.sh 'uninstall' 常用命令 启动命令 /appex/bin/lotServer.sh start 状态查询 /appex/bin/lotServer.sh status 停止加速 /appex/bin/lotServer.sh stop 更新许可 /appex/bin/serverSpeeder.sh renewLic 重新启动 /appex/bin/serverSpeeder.sh restart (7.03)锐速配置文件优化 详细配置文档 https://github.com/0oVicero0/serverSpeeder_Install/blob/master/lotServer.pdf 配置文件在/serverspeeder/etc/config 首先确保下面3个参数开启 123rsc="1"advinacc="1"maxmode="1" rsc=”1″ #RSC 网卡驱动模式advinacc=”1″ #流量方向加速maxmode=”1″ #最大传输模式 DO vps还要开启gso 下面是一些个人测试对加速有效果的选项，请结合网络环境自行测试 杂项 initialCwndWan=“64″初始 TCP 发送窗口能够发送的数据包的数量，该值设置的高会获得更好的加速效果，但是可能会造成网络的拥塞。使用值在60以下有效果 l2wQLimit=”1024 4096″从 LAN 到 WAN 加速引擎在缓冲池充满和空闲时分别能够缓存的数据包队列的长度的上限，该值设置的高会获得更好的加速效果，但是会消耗更多的内存。w2lQLimit=”1024 4096″从 WAN 到 LAN 加速引擎在缓冲池充满和空闲时分别能够缓存的数据包队列的长度的上限，该值设置的高会获得更好的加速效果，但是会消耗更多的内存。 halfCwndMinSRtt=”500″halfCwndLossRateShift=”3″以上两个值用于判断网络拥塞，分别为延时和丢包率，丢包率默认值为 3，即1/2^3，当拥塞产生时，退出第三代 Learning-based TCP 算法，采用类似传统 TCP 的算法。此处对于高丢包的线路来说，直接设置为1，即丢包百分之50以上时，才退出Learning-based TCP 算法(这会导致高丢包线路上增加流量消耗) 修改完成后，重启锐速 1/serverspeeder/bin/serverSpeeder.sh restart FinalSpeed 介绍FinalSpeed是高速双边加速软件,可加速所有基于tcp协议的网络服务,在高丢包和高延迟环境下,仍可达到90%的物理带宽利用率,即使高峰时段也能轻松跑满带宽。可以与锐速共存。 使用建议(7.03) FinalSpeed现在已停止更新,建议作为备选加速手段 OVZ虚拟化的vps上只可用udp模式，udp在国内被封杀较严重，导致链接中断等。 安装方法 FinalSpeed现在已停止更新，官方移除了安装方法，以下安装方式来自github备份。 安装命令: 1234rm -f install_fs.shwget https://github.com/dupontjoy/customization/raw/master/Rules/Shadowsocks/Finalspeed/install_fs.shchmod +x install_fs.sh./install_fs.sh 2&gt;&amp;1 | tee install.log 一键安装完成后，vps会自动安装java环境。 卸载： 1sh /fs/stop.sh ; rm -rf /fs 设置开机启动： 12chmod +x /etc/rc.localvi /etc/rc.local 然后加入 1sh /fs/start.sh 每天晚上1点自动重启： 12crontab -e0 1 * * * sh /fs/restart.sh FinalSpeed windows客户端官方最新版本为1.2 更新日志上表明cpu占用降低30%，但是稳定性较差，时常挂掉。推荐FinalSpeed1.12测试版 个人常用版本，很稳定。 这一部分请参考一下网站。 https://blog.kuoruan.com/82.html 常用命令 启动： 1sh /fs/start.sh 停止： 1sh /fs/stop.sh 重新启动： 1sh /fs/restart.sh 运行日志： 1tail -f /fs/server.log Kcptun 小内存VPS可用(64M内存服务器稳定运行)，OVZ架构可用， Go 语言编写 使用建议(7.03) 首次使用，建议作为备选加速手段 不当配置将带来大量流量消耗 安装 Kcptun 基于 KCP 协议的 UDP 隧道，它可以将 TCP 流转换为 KCP+UDP 流。而 KCP 是一个快速可靠协议，能以比 TCP 浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。 Kcptun 服务端安装繁琐，目前没有改为Kcptun加速的需求，收集网络一部分Kcptun搭建教程供参考。 小内存福音，Kcptun Shadowsocks加速方案 https://blog.kuoruan.com/102.html Kcptun 服务端一键安装脚本,喜闻乐见的多用户支持 https://blog.kuoruan.com/110.html SSR混淆参数 作者Jessica Lynn转载自 https://plus.google.com/113582246973758055268/posts/H51ZpzwUFDK?iem=4&amp;gpawv=1&amp;hl=zh-Hans-TW 一些混淆参数（域名） 国内： sz.btfs.mail.ftn.qq.com btrace.video.qq.com ossweb-img.qq.com 1234-wyfqdku4kcgcabalp6rdudo7–1042249034.cmos.greencompute.org aecpm.alicdn.com aldh5.tmall.com at.alicdn.com atanx.alicdn.com g.alicdn.com gtms03.alicdn.com gw.alicdn.com img.alicdn.com 国外： az813057.vo.msecnd.net az817829.vo.msecnd.net azureedge.net media.gettyimages.com origin.cdn77.com TCP-BBR(7.03) BBR (Bottleneck Bandwidth and RTT)是由google工程师编写的新的 TCP 拥塞控制算法，目的是要尽量跑满带宽, 并且尽量不要有排队的情况, 加速效果不比锐速差 使用建议(7.03) 开源，高效，强烈推荐首选！ 同一线路，BBR与锐速可分别试用取舍，一般满足需求！ 修改版 BBR 更为高效 不会造成流量大量浪费 安装 开源地址 测试环境 Debian 7 x64 Vultr 启用TCP-BBR涉及VPS更换内核，所以如果步骤错误，或者VPS不兼容最新的内核，会导致无法开机等错误， 锐速不支持，更换后的 &gt;4.9 内核 安装原版BBR 脚本来自秋水逸冰 系统支持：CentOS 6+，Debian 7+，Ubuntu 12+ 虚拟技术：OpenVZ 以外的，比如 KVM、Xen、VMware 等 内存要求：≥128M 连接SSH，输入下面命令，更新内核 123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启 重连SSH 验证 内核版本 1uname -r 最新内核版本大于4.9即可，最新4.12(7.03) 修改sysctl.conf 1nano /etc/sysctl.conf 复制代码： 1234567891011121314151617181920212223#TCP配置优化(不然你自己根本不知道你在干什么)fs.file-max = 51200#提高整个系统的文件限制net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.core.netdev_max_backlog = 250000net.core.somaxconn = 4096net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_fastopen = 3net.ipv4.tcp_mem = 25600 51200 102400net.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = bbr#END OF LINE 保存(Ctrl + X —— y ——回车) 应用 1sysctl -p 重启SSR 1/etc/init.d/shadowsocks restart 修改版BBR 相对原版更为暴力，加速效果更好 提供 Vicer版 和 魔改版 两个试用后加速效果还不错的版本。 我的测试来看 魔改版 的最高速度高于 Vicer版 ，但 YOUTUBE 来看 Vicer版 高于 魔改版 注意：修改版BBR的一键脚本，支持系统较少，安装前需要确认自己的系统支持，如不在支持列表，自行Google即可，有大量第三方脚本。 支持系统： Debian 8 / Ubuntu16 + /Debian 7(需要手动安装gcc4.9) Debian 7手动安装gcc4.9(以root用户登陆，否则 命令前添加sudo) 修改系统更新源 1nano /etc/apt/sources.list 添加如下两个更新源 12deb http://ftp.cn.debian.org/debian/ jessie main non-free contribdeb http://ftp.uk.debian.org/debian/ jessie main non-free contrib 保存(Ctrl + X —— y ——回车) 执行更新apt-get update 检查可安装 gcc 版本列表apt-cache search gcc输出有gcc4.9 字样即可，数量无所谓 1234567891011121314151617181920libx32gcc-4.8-dev - GCC support library (x32 development files) cpp-4.9 - GNU C preprocessor gcc-4.9 - GNU C compiler gcc-4.9-base - GCC, the GNU Compiler Collection (base package) gcc-4.9-locales - GCC, the GNU compiler collection (native language support files) gcc-4.9-multilib - GNU C compiler (multilib files) gcc-4.9-plugin-dev - Files for GNU GCC plugin development. gcc-4.9-source - Source of the GNU Compiler Collection gccgo-4.9 - GNU Go compiler gccgo-4.9-multilib - GNU Go compiler (multilib files) gcj-4.9 - GCJ byte code and native compiler for Java(TM) gcj-4.9-jdk - GCJ and Classpath development tools for Java(TM) gcj-4.9-jre-lib - Java runtime library for use with gcj (jar files) gdc-4.9 - GNU D compiler (version 2), based on the GCC backend gfortran-4.9 - GNU Fortran compiler gfortran-4.9-multilib - GNU Fortran compiler (multilib files) gobjc++-4.9 - GNU Objective-C++ compiler gobjc++-4.9-multilib - GNU Objective-C++ compiler (multilib files) gobjc-4.9 - GNU Objective-C compiler gobjc-4.9-multilib - GNU Objective-C compiler (multilib files) 命令apt-get install g++-4.9 安装g++-4.9 Vicer版BBR 脚本来自Debian/Ubuntu TCP BBR 改进版/增强版 一键安装 1wget --no-check-certificate -qO &apos;BBR_POWERED.sh&apos; &apos;https://moeclub.org/attachment/LinuxShell/BBR_POWERED.sh&apos; &amp;&amp; chmod a+x BBR_POWERED.sh &amp;&amp; bash BBR_POWERED.sh 遇到 Error! Header not be matched by Linux Kernel. 参看Debian/Ubuntu 开启 TCP BBR 拥塞算法,依照 作者开启bbr 的脚本执行一遍即可。 遇到Error! Install gcc-4.9. debian 7 重新安装一遍 gcc-4.9 ，其他系统 执行 apt-get update 安装完成后 执行lsmod |grep &#39;bbr_powered&#39; 结果不为空,则加载模块成功 重启SSR /etc/init.d/shadowsocks restart 魔改版BBR 一键脚本 1wget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/YankeeBBR/master/bbr.sh &amp;&amp; bash bbr.sh install 之后选择重启系统，重连SSH 输入命令 bash bbr.sh start 即可完成安装 验证 sysctl net.ipv4.tcp_available_congestion_control 返回命令有 tsunami 即可。 重启SSR /etc/init.d/shadowsocks restart 结束]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网教程（一）——VPS上搭建SSR]]></title>
    <url>%2F2016%2F06%2F26%2FVPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617更新2016.06.26 与SSR有关部分基本完成。 2016.09.29 更新SSR部分内容2016.10.09 更新SSR内容，更新Android端接入。2016.11.09 更新SSR混淆相关内容，更新SSR-Android，更新部分介绍。2016.11.20 整合一部分VPS优化内容2016.12.11 删减调整一部分内容2016.12.15 替换锐速优化为 BBR，整合TCP优化2016.12.26 更换TCP BBR 脚本，脚本来自@秋水逸冰 版本，测试通过 2017.01.11 同步更新一部分SSR内容2017.02.17 同步更新，调整删减内容，降低上手难度，增加VPS测速相关内容2017.03.28 调整一部分内容，更新Vps推荐2017.04.08 新增 VPS 安全加固2017.05.24 同步更新内容，更换协议，增加新内容。2017.06.28 删减过时内容，同步更新2017.07.03 更新BBR内容，VPS测速2017.07.12 更换过时截图，修正错误。 安装脚本说明：遇到失效等，请留言或邮件我！ 脚本来源 @秋水逸冰ShadowsocksR一键安装脚本 隐私/后门：(这个结论仅对本文使用脚本负责)文章中所使用的脚本，除默认用户名/密码外，没有任何夹带私货。脚本亦开源，不放心可以下载后自行审计！ https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh SSR 服务器端更新：使用此一键脚本安装的，不能使用其他命令更新，只能通过 备份配置文件，卸载再重新安装！也都不是事，备份一下配置文件，重新安装，覆盖配置文件，重启即可。 基本从0开始的教程，当作自己的备份了。 吐槽作为一个伪程序员，每次最苦恼的就是Android SDK的更新，当初安装Android Studio时候就因为防火墙折腾了整整2周，简直就是把自学Android的那点耐心都磨没了。各种的搜索文档，离了google效率下降70%！科学上网简直成了程序员的必备生存技能了。 谁比较需要单独购买VPS科学上网？ 只是翻墙简单浏览网页，就不必要再单独花费人民币了，蓝灯、和各个网站的免费ss账户，是你的主菜。 偶尔看看视频、不想画太多精力在寻找免费资源上。可以直接购买现成的ss/vpn账户，在G+相应的社区可以找到很多比较靠谱的提供商。 常年泡视频网站又受不了国内视频网站乱七八糟、24h使用google服务、对稳定性和流量有一定要求、愿意使用一点时间来折腾VPS。比较适合单独购买VPS来科学上网。VPS选择如下会提及。 搜索文档，更新软件源、折腾个人网站又不想备案的、折腾开源的 这部分大神谁会来看这个啊，早自己分分钟写个轮子了 VPS选择选择VPS看那几点 一定要根据自己的具体使用场景和网络环境来选择VPS服务。 选择VPS的一般要注意的几点 自己的具体网络环境 简单来说，一般联通的国际出口稳定性大于电信、移动的国际出口看心情有的地区甩电信联通几条街，坏的时候根本没速度。电信网路比较特殊，国际出口充足，但是限速到不能忍，不挤的时候嗖嗖的，高峰期渣到爆炸。 移动网络具体情况不太清楚。 VPS地点。 日本VPS电信网络访问要绕道美国绕道ping一般在200到300了，（9.29）联通直连日本，ping在100！联通目前也分地区有限速。(2.17)联通因为16年年底海底光缆故障损失了30％的国际出口，导致新年到现在出口路由并不稳定，联通-日本ntt延迟有时200有时100.（6.28）目前读者反映ntt比较稳定。 电信目前分地区直连日本，直连ping在100或者多一点。（有运气成分，多刷几个ip试试）(2.17)测速结果来看，目前电信直连的省份反而更多。 美国的VPS联通/电信访问延迟基本相当。一般选择靠近美国西海岸节点旧金山、洛杉矶、纽约等地点。电信限速很厉害，所以一般电信网需要开混淆配合FinaSppeed等加速。 新加坡节点，在靠近南方地区，可以ping在100以内稳定！youtube 4k不卡。但在偏北一些地区ping不稳定。（9.29）Vultr新开新加坡节点，北方部分地区直连。 香港VPS，这个比较特殊，香港的VPS ping值可以低到20几，但是香港本身的国际出口就小，VPS价格也偏高，另外香港毕竟也在政府的直接管辖内，隐私方面风险比其他地区节点要大一些。建议土豪级别的游戏玩家使用。 VPS虚拟化架构 (具体解释请自行google，只说明对科学上网的影响) OpenVZ（简称OVZ） 便宜！但是没法进行修改内核、加锐速之类的优化操作。访问速度基本取决于你的本地网络环境优化的可能性。（不是没有可以加速的手段，就是在基本相同情况下，不如其他架构的vps可以榨干VPS的传输性能）。加速手段：Finaspeed（已停止更新） 和net-speeder。 Xen性能较好，实际用的不多，不做更多评论 Hyper-VH完美支持Windows系统，Hyper-V同样可以超售内存和硬盘，如果服务商超卖较多可能会有性能问题，Linux操作系统性能较低。 KVM全功能虚拟化架构，可上传ISO手动安装系统。KVM VPS相对其它架构的VPS较为自由。虚拟化性能比Xen略低。可以使用TCP优化和锐速，价格比一半OVZ的要高一些。（本教程以KVM为例。。速度需求大的最好使用KVM） VPS提供商 这个就比较多了，尽量选择购买人较多的，而且一般支持支付宝的服务商被国人玩半残居多（比如搬瓦工。。超售严重），所以购买不支持支付宝的vps提供商要靠谱一点。注册paypal国际版（注：是国际版paypal 不是国内的贝宝！）一般的vps提供商都支持paypal付款。与使用信用卡相比，具体的优惠政策不同，详情请自行google。 (6.28)支持支付宝/微信的服务商良莠不齐，第一次购买需要注意退款政策，虚拟化架构等，最好按月支付。现在使用的是洛杉矶的KVM机器，配合BBR基本3网通吃，除个别时段非常稳定。 推荐几个 VPS 的评测网站，相对更新很快。 http://www.laozuo.org/myvpshttps://doub.io/https://www.91yun.org/ （3.28）Vultr-仅相关参考(已过时！) 来源：https://www.v2ex.com/t/302347 目前 Vultr 已经推出 2.5刀/月 的套餐，配合新注册赠余额，性价比很高，但同时也被搞烂了，好用的ip段，看运气了。NTT的线路，在华北地区高峰期一直爆炸。。 刷ip地址可以使用Vultr的reserved IP功能，实测是在一个小时后可以删除无用ip 日本节点-IP（2017.2.17）目前Vultr东京节点可以开出不少45.6 /45.4/104等以下结论仅供参考！注意以下结论仅供参考，实际不同网络不同ip表现不一定相同 108.开头普遍反应较好，电信/联通稳定性比45开头要好，比较难刷到。 45.7X-youtube-1080p，无压力 45.3X-youtube-1080p ，略卡 美国节点 IP 以108开头最为稳定/丢包延迟都较其他ip好一些 位置首选洛杉矶，但联通部分地区连接较卡顿，以实测为准。 西雅图节点，论坛反映较为稳定(仅供参考) VPS测速常用VPS提供商测速地址 vultr http://www.vultrvps.com/test-server 搬瓦工 http://www.64mb.biz/tips/4ip.html 其他待更新，其实只要搜索 测速地址+vps提供商名称就好 以vultr东京节点为例 有的vps提供商只提供测速网址，而测速大多以ip地址为主，ping命令可以获取 测速网址 对应的ip地址 最简单的命令 PING (延迟测试) win+r组合键打开运行栏 输入cmd，回车 如图 输入 ping 你需要测试的ip地址 这里是 1ping hnd-jp-ping.vultr.com 应答如下 这里可以看到具体的测速ip地址为 108.61.201.151 选中 Ctrl + C复制下来 延迟141 左右，还在接受范围内。丢包大致作为参考即可，只有4个包发送，不足以作为结果注意这里的延迟只是ping检测的结果，可以作为实际访问延迟的参考值，而不是绝对准确！ 测速相关网站 查询ip地址归属地不要使用 百度搜索查询ip地址 那些数据国内尚可，vps一般对应国外网站，百度等则错误不少，推荐：ipip.net https://www.ipip.net/ip.html 全国ping检测有时ss属于合租服务器，可能在不同省份，需要评估ip到不同省份的延迟，这个时候就需要 全国范围内的ping检测首推：站长之家ping检测 http://ping.chinaz.com/ 路由追踪 Best Trace Best Trace是由 IPIP.NET 开发的路由追踪检测工具官方地址下载 路由追踪 即 检测数据 从你的本地宽带开始 到 vps 的整个过程中走的路径，例如 北京联通 到 vultr东京 从北京直接连到日本，而 河南电信到 vultr东京 则是先到美国，再去日本。 上图说话(图片来自91yun) 这款软件几乎没有上手难度 具体介绍如下 http://www.laozuo.org/8277.html 丢包率 WinMTR 具体介绍如下，91yun介绍很详细，并附带下载地址，此处就不多言了 https://www.91yun.org/zh/archives/1120 VPS自身测试（7.03） vps网络测试 https://teddysun.com/444.html vps性能测试 https://teddysun.com/245.html vps部署 我选择的是Vultr VPS。2.5刀/月，500G流量 怎么折腾都够了。 本节内容转载/删节/修正自 https://mpc2008cn.github.io/2015/10/22/vps/就是从这开始折腾的，有删减和修改。 Vultr 通过下面链接注册，你可以免费获得 10美元同时 也能帮助我获得一些奖励，谢谢！ Vultr地址 服务器选择 选择东京或者美国西海岸的服务器,速度相对比较快 操作系统 推荐选择Debian 7 x64此版本搭建SSR/锐速/bbr基本没有遇到故障其他版本也可，请自行选择 选择硬件 一个月可以免费用$5的配置,科学上网就够了，建站等需求需要更大的。 创建vps 等待完成。 VPS测试(可忽略，但是推荐进行) 你可以使用上面提到的 VPS测试软件，来查看 自己的vps到本地的 路由追踪 时候与 官方测试地址 相同，丢包率/延迟如何等 现在几乎所有的vps运营商 都有大量的国人涌入，有一点概率你开到的IP 是被 长城防火墙 阻断过，被废弃的ip。在正式搭建 科学上网 服务之前，请确保自己 VPS 的可访问性 配置securecrt(不必在意ip地址) 下载securecrt 复制服务器的IP地址,初始用户名,初始密码 securecrt连接vps 解压下载的secure crt,双击\SecureCRT_EN\SecureCRT\中的SecureCRT.exe 输入IP地址,用户名,点击connect 弹出框点击Accept&amp;Save 输入密码,勾选save password,OK 出现如图所示,标签变绿就说明连接成功啦. 部署ShadowSocksR 为什么选择SSR而不是原版的SS主要原因如下 可以直接启用chacha20加密，在移动设备上比较好使 TFO(TCP Fast Open)直接自带，减少握手次数。 二次混淆和抗重放等附加功能 shadowsocksR的相关争论在以下网址中，至于用户而言，现在ssr开源，一定的网络环境下比原版的ss稳定就够了。 一些争议如下 https://www.librehat.com/about-shadowsocks-r-and-the-security-of-shadowsocks/ SSR有关网址 (2.17)在2016.12月之前很长一段时间SSR只在 ZeroNet 中更新，17年以后到现在恢复在github上更新！望周知！ ShadowsocksR github主页 https://github.com/breakwa11/shadowsocks-rss ShadowsocksR C#(windows版)下载地址 https://github.com/shadowsocksr/shadowsocksr-csharp/releases shadowsocksr-android版下载地址 https://github.com/shadowsocksr/shadowsocksr-android/releases 用到的一键安装脚本@秋水逸冰(感谢！) https://shadowsocks.be/9.html ZeroNet(目前更新状态未知) SSR-ZeroNet http://127.0.0.1:43110/shadowsocksr.bit（10.9）不安装ZeroNet，直接访问地址https://bit.no.com:43110/shadowsocksr.bit/ ZeroNet简介和接入 http://www.williamlong.info/archives/4574.html 安装SSR 复制以下代码到登陆成功的securecrt 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 如图，回车。 输入设定初始密码，也可以直接回车。 输入初始端口，也直接回车 嗯，回车 等待一段时间的滚屏，最后会提示——成功 shadowsocks.json配置文件 shadowsocks.json文件中定义SSR的访问端口，加密方式等，我们使用 WinSCP软件进行编辑修改(更为友好)，直接使用 securecrt 等工具 使用 vim 命令修改也可，此文中暂不涉及 WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。同时支持 SCP 协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件. 下载WinSCP绿色中文版。 解压缩打开winscp，保持默认配置不变，输入VPS的ip地址、用户名、密码。点击登陆。 默认在/root文件夹下，要进入/etc文件夹下找到shadowsocks.json 编辑shadowsocks.json文件 下面是一个 shadowsocks.json的注释模板直接复制粘贴 无注释版本 覆盖原始文件即可，或者在原文件上修改（建议先看一下注释，了解一下shadowsocks.json的大致内容） 参考资料网址shadowsocks.json文件各项配置说明 https://github.com/breakwa11/shadowsocks-rss/wiki/Server-Setup 混淆插件说明 https://github.com/breakwa11/shadowsocks-rss/wiki/obfs 注释 12345678910111213141516171819202122232425262728&#123; "server":"0.0.0.0", "server_ipv6":"::", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; #纯 SS 不带混淆 端口25 密码为123456. "25":"123456", #端口443，密码123456 ，protocol选择auth_chain_a。obfs选择tls1.2_ticket_auth，具体插件的介绍如下参考资料中 "443":&#123;"protocol":"auth_chain_a", "password":"123456", "obfs":"tls1.2_ticket_auth", "obfs_param":""&#125;, #注意无论怎么变化，最后一个端口设置，不带逗号！ "3389":&#123;"protocol":"auth_aes128_md5", "password":"123456", "obfs":"tls1.2_ticket_auth", "obfs_param":""&#125;#此处没有逗号！ &#125;, "timeout":400, #默认全局的加密方式，即上边各个端口的默认加密方式。一般为aes-256-cfb， 此处，选择为chacha20，移动设备性能较好。 "method":"chacha20", #protocol.协议定义插件的默认值，origin即使用原版SS协议，不混淆。即上面端口配置中，你没有设置 protocol 和 obfs 情况下，使用的默认值。 "protocol": "origin", "protocol_param": "", #protocol.协议定义插件的默认值，plain即使用原协议，不混淆。 "obfs": "plain", "obfs_param": "", "redirect": "", "dns_ipv6": true, #TCP FAST OPEN ，打开 "fast_open": true, "workers": 1&#125; 无注释版本，直接复制粘贴覆盖原始文件，或者在原文件上修改 12345678910111213141516171819202122&#123; "server":"0.0.0.0", "server_ipv6":"::", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "25":"123456", "443":&#123;"protocol":"auth_chain_a", "password":"123456", "obfs":"tls1.2_ticket_auth", "obfs_param":""&#125;, "3389":&#123;"protocol":"auth_aes128_md5", "password":"123456", "obfs":"tls1.2_ticket_auth", "obfs_param":""&#125; &#125;, "timeout":400, "method":"chacha20", "protocol": "origin", "protocol_param": "", "obfs": "plain", "obfs_param": "", "redirect": "", "dns_ipv6": true, "fast_open": true, "workers": 1&#125; 重启SSR 配置完成后，重启SSR,以root账户登陆securecrt，复制以下代码，重启ssr。 1/etc/init.d/shadowsocks restart 会提示shadowsocksr重启成功。（如图） 更新SSR vps端，需要先令存 shadowsocks.json文件。再执行卸载 1./shadowsocksR.sh uninstall 之后重新执行安装脚本即可 混淆选择(新手可略过)混淆插件简介 ShadowsocksR目前支持的混淆插件（此类型的插件用于定义加密后的通信协议）： plain ,http_simple ,http_post,random_head ,tls1.2_ticketauth 协议定义插件(用于定义加密前的协议): origin, auth_sha1, auth_sha1_v2, auth_sha1_v4, auth_aes128_md5/auth_aes128_sha1 auth_aes128_md5/auth_aes128_sha1 支持 单端口多用户，即一个端口 可以配置 几个不同的密码，稍后更新。 ShadowsocksR 协议插件文档 混淆插件选择(5.24) 通用 推荐auth_chain_a+tls1.2_ticket_auth这种组合目前混淆效果最好，有利于个人VPS的长时间使用。 （5.24）auth_chain_a可不使用用加密，即加密方式None（SSR作者语），但是吧，性能差不多的情况下，加个密没毛病。 auth_aes128_md5或auth_aes128_sha1+随意，即使使用rc4加密亦可（SSR作者语） 玩游戏，或对延迟有要求，不要使用tls1.2_ticket_auth 网络封锁/监控环境下 例如学校教育网/公司内网/广电宽带等等，封杀了BT/禁止访问网盘等等等等。 使用http_simple、http_post或tls1.2_ticket_auth 混淆访问的目标网址。再配合443/80端口通常可以解决问题。 Android (5.24)最好使用auth_chain_a。 如果之前使用的是auth_aes128_md5，推荐以auth_chain_a替换 手机运算能力较差的推荐使用auth_sha1_v4替换auth_aes128_md5 单端口多用户！！！推荐！！！ https://doub.io/ss-jc48/ 逗比根据地的介绍，很详细，搭配最新的auth_chain_a 混淆，很好用。https://breakwa11.blogspot.ru/2017/01/shadowsocksr-mu.html?m=1 官方 ShadowsocksR单端口多用户配置方法 域名申请，免费！ https://my.freenom.com/clientarea.php DNS解析申请，注册用Google搜索临时邮箱即可 https://www.cloudxns.net/ VPS优化 详情在科学上网教程（二）——VPS优化加速 这里只提及 原版BBR BBR目前有很多修改版本，效果很好，BBR属于内核级别，不推荐新手 安装修改版BBR，内核挂掉，新手一般很难处理。 修改版BBR 详情见科学上网教程（二）——VPS优化加速 TCP优化 增加TCP连接数量 1nano /etc/security/limits.conf 添加两行： 12* soft nofile 51200* hard nofile 51200 保存(Ctrl + X —— y ——回车) 设置ulimit： 1ulimit -n 51200 TCP-BBR(推荐) 脚本来自于@秋水逸冰 敬告： 锐速不支持，更换后的 4.9及以后 内核 加速效果与具体网络状态有关 不推荐新手直接安装修改版BBR，挂掉后很难恢复。 BBR (Bottleneck Bandwidth and RTT)是由google工程师编写的新的 TCP 拥塞控制算法，目的是要尽量跑满带宽, 并且尽量不要有排队的情况, 加速效果不比锐速差，完全开源，对隐匿性要求高而无法使用锐速的人士，也可以放心使用开源地址 启用TCP-BBR涉及VPS更换内核，所以如果步骤错误，或者VPS不兼容最新的内核，会导致无法开机等错误 目前在 Vultr / DO 上测试通过。其他主机提供商，请自行测试 连接SSH，运行下面的命令 123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 提示需要重启 VPS，输入 y 并回车后重启，重连SSH 脚本会自动更新匹配的4.xx版本内核(6.28 目前是4.11），并启用TCP BBR 验证 输入 1uname -r 有4.9.0 以上就 表示 更新成功 输入 1lsmod | grep bbr 返回值有 tcpbbr 即bbr已启动。 添加一些优化内容修改sysctl.conf 1nano /etc/sysctl.conf 复制代码： 1234567891011121314151617181920212223#TCP配置优化(不然你自己根本不知道你在干什么)fs.file-max = 51200#提高整个系统的文件限制net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.core.netdev_max_backlog = 250000net.core.somaxconn = 4096net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_fastopen = 3net.ipv4.tcp_mem = 25600 51200 102400net.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = bbr#END OF LINE 保存(Ctrl + X —— y ——回车) 应用 1sysctl -p 重启SSR 1/etc/init.d/shadowsocks restart VPS安全加固( 安全性是重中之重！) 必须进行的步骤，安全性是重中之重！详情在科学上网教程（三）——VPS安全加固 shadowsocksR 客户端配置shadowsocksR C# windows版本 (6.28)最新的4.6.0客户端(注意MD5校验) 支持hosts文件实验性质，稳定后加入 shadowsocksR C# windows版本 https://github.com/shadowsocksr/shadowsocksr-csharp/releases 解压ShadowsocksR-win-4.6.1.7z（以具体客户端版本为准），打开。 对应上文中SSR服务端配置输入对应端口配置，ip地址，密码等。 25端口（单SS） 443端口 3389端口 右键shadowsocks快捷图标,选择启用系统代理现在应该可以访问 谷歌了:) 使用Chrome+SwitchyOmega 推荐！！ Chrome下插件SwitchyOmega可以根据要访问的网址判断是否需要经过代理，做到智能的科学上网。并且现在这个插件的配置可以云同步，再也不用本地保存了！具体教程如下SwitchyOmega使用ss代理 http://www.ihacksoft.com/chrome-switchyomega.html 配合gfwlist https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList SSR-Android SSR-Android端(注意MD5校验) https://github.com/shadowsocksr/shadowsocksr-android/releases (12.11) ssr-android更新到3.2.7.14.版，增加auth_aes128_md5和auth_aes128_sha1,推荐更新！ (1.11)ssr-android更新到3.3.3.1推荐更新！ (2.17)ssr-android更新到3.3.4.5 推荐更新! (6.28)SSR-android更新3.4.0.5 android端使用 可以直接输入SSR配置，较为繁琐 在SSR C#版本，中输入完毕，保存。直接扫描二维码即可！二维码必须在光标移到 SSR链接 处才会出现 结束]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开端，起始。]]></title>
    <url>%2F2016%2F06%2F21%2F%E5%BC%80%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[总算是博客搭建完了，依附在github上，自己的域名什么的先不买了。 评论系统、RSS、留言、统计、访问量 基本有个独立博客的样子了。之前一直以为独立博客要花很长时间才可以完成，其实也就那些东西，真正厉害的是造轮子的人。 马上大四了，反而找到了自己的兴趣，不知道是高兴还是悲伤，做了三年的单片机最后发现最喜欢的是软件，造化弄人吧。 开始更新自己的经历和心情，基本不用担心审查和备案，反正服务器又不在国内。只能说走一步再走一步了用好剩下的时间。前路和期许很难，但是就这么熬着，总有意外的一天。]]></content>
      <categories>
        <category>随</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初入树莓派1安装系统+进入SSH]]></title>
    <url>%2F2016%2F06%2F21%2F%E5%88%9D%E5%85%A5%E6%A0%91%E8%8E%93%E6%B4%BE1----%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F%2B%E8%BF%9B%E5%85%A5SSH%2F</url>
    <content type="text"><![CDATA[为了更好的从事程序员事业、填坑linux、为学弟打下第一手资料、留下linux培训教材…… 实际就是为了搭个路由器，玩玩 入了树莓派3b +电源+外壳+sd卡—300大洋——–肉疼 树莓派系统安装 树莓派3b的耗电量还是挺大的 推荐买个2.5A的电源 系统选择 树莓派支持 数十款操作系统，一般新手推荐的是raspbian Raspbian是为树莓派设计，基于Debian的操作系统，不隶属于树莓派基金会[1]，但被列为官方支持的操作系统， Raspbian镜像地址(最好在FQ下，否则会很慢的。你要用IDM当我没说) Raspbian有两个版本，简单区别如下 RASPBIAN JESSIE WITH PIXEL带有完整的桌面体验，安装包1.4G左右 RASPBIAN JESSIE LITE没有X-server 套件，没有 Qt 和 GTK+ 的函式库。等于去掉了桌面。安装包400Mb上下。 所要用到的工具是： 1.多功能读卡器一个 2.TF卡一张（4G以上） 烧写器官方推荐是win32diskimager但是文件路径不支持中文。 个人推荐 USB Image Tool故障率最低的是1.7版本。 插上读卡器，烧写系统开始！ 烧写系统 打开USB Image Tool注意左上角是Device Mode，不是Volume Mode！ 选择下载后解压的img文件 写入等待进度条完成即可。 错误原因 USB Image Tool 在win7以上系统中必须要以管理员权限运行 USB Image Tool运行需要.net环境 直接使用系统默认加载的即可。 烧写完成后接入电源 进入SSH管理（没有显示设备时） 第一次进入系统时直接利用网线接入路由器，将电脑接入同一个wifi下。在路由器管理界面查找树莓派对应得IP地址。也可以扫描一下局域网设备中开启22端口的设备. 使用SSH管理工具，这里以putty为例。打开软件，填入树莓派ip地址。 打开软件，填入树莓派ip地址。默认登陆界面 默认用户名pi 密码raspberry。 登陆成功！ 参考 http://blog.csdn.net/longerzone/article/details/36034619]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F06%2F18%2Fhellowworld%2F</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>随</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Linux</tag>
        <tag>VPS</tag>
        <tag>python</tag>
        <tag>单片机</tag>
        <tag>开源</tag>
      </tags>
  </entry>
</search>
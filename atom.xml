<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>默</title>
  <subtitle>为了生存，而一点点淡忘了最初的本意。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-19T15:40:57.178Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jasper</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法—KMP</title>
    <link href="http://yoursite.com/2018/09/19/%E7%AE%97%E6%B3%95%E2%80%94KMP%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/09/19/算法—KMP搜索/</id>
    <published>2018-09-19T04:00:00.000Z</published>
    <updated>2018-09-19T15:40:57.178Z</updated>
    
    <content type="html"><![CDATA[<hr>
<ul>
<li><p>记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演.</p>
</li>
<li><p>初步涉及KMP时,有些蒙蔽,还好遇到了 阮一峰 的讲解,才啃下来.博文图来自资料链接.</p>
</li>
</ul>
<p>资料来源如下</p>
<ul>
<li><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="external">从头到尾彻底理解KMP（2014年8月22日版）</a></li>
<li><a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="external">如何更好的理解和掌握 KMP 算法? - 海纳的回答 - 知乎</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="external">字符串匹配的KMP算法 阮一峰</a></li>
</ul>
<hr>
<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h2><ul>
<li><p>搜索字符串时最常用的是暴力搜索,</p>
<ul>
<li>一个字符一个字符去比较,第一位相同,比较第二位</li>
<li>遇到不同字符,目标字符指针后移一位,重复.</li>
<li>直到遇到模式字符终止符.返回目标字符指针位置.</li>
</ul>
</li>
<li><p>以下是暴力搜素的C语言一个实现版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ViolentMatch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</div><div class="line">  <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</div><div class="line">  &#123;</div><div class="line">      <span class="keyword">if</span> (s[i] == p[j])</div><div class="line">      &#123;</div><div class="line">          <span class="comment">//①如果当前字符匹配成功（即S[i] == P[j]），则i++，j +</span></div><div class="line">          i++;</div><div class="line">          j++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">      &#123;</div><div class="line">          <span class="comment">//②如果失配（即S[i]! = P[j]），令i = i - (j - 1) j = 0</span></div><div class="line">          i = i - j + <span class="number">1</span>;</div><div class="line">          j = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//匹配成功，返回模式串p在文本串s中的位置，否则返回-1</span></div><div class="line">  <span class="keyword">if</span> (j == pLen)</div><div class="line">      <span class="keyword">return</span> i - j;</div><div class="line">  <span class="keyword">else</span></div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对暴力搜索而言,整个流程上改进空间不大,主要集中在当搜索过程.见示例</p>
<ul>
<li><img src="https://my.mixtape.moe/lnrhnh" alt="1"></li>
<li><img src="https://my.mixtape.moe/illbyk" alt="2"></li>
<li><img src="https://my.mixtape.moe/nxjjii" alt="3"></li>
<li><img src="https://my.mixtape.moe/kdmsqe" alt="4"></li>
</ul>
</li>
<li><p>可以看到整个搜索过程,最明显的一个缺陷是,搜索到模式字符串的中间很长一段了,遇到一个坏字符,目标字符串指针移位1.模式字符还是要从头开始比较,模式字符在上一轮坏字符之前的比较相当于白做了.</p>
</li>
</ul>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><ul>
<li><p>当空格与D不匹配时，前面六个字符是”ABCDAB”已知。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置” <code>j</code> 移回已经比较过的位置，而是继续把它向后移。</p>
</li>
<li><p>经过KMP处理六个字符已知字符串”ABCDAB”后,可以得到一个表格,对应模式字符串每一位可前移的位数.如图<br><img src="https://my.mixtape.moe/ugeiwn.png" alt="8"></p>
</li>
<li><p>于是整个过程优化如下.</p>
<ul>
<li><img src="https://my.mixtape.moe/lnrhnh" alt="1"></li>
<li><img src="https://my.mixtape.moe/illbyk" alt="2"></li>
<li><img src="https://my.mixtape.moe/nxjjii" alt="3"></li>
<li>但空格与D失配,其前一位 (B-&gt;2),所以 <code>j=2</code></li>
<li><img src="https://my.mixtape.moe/cnvoyd" alt="5"></li>
<li>但空格与C依旧失配.其前一位 (B-&gt;0),所以 <code>j=0</code></li>
<li><img src="https://my.mixtape.moe/kxqsqy" alt="6"></li>
</ul>
</li>
<li><p>对应c代码变化如下</p>
<ul>
<li><p>最主要的变化是引入next[]数组(方便).</p>
<p>因为c语言数组元素由0开始,上文的表格右移一位.0位填充-1.得到next数组.</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> * t, <span class="keyword">char</span> * p)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</div><div class="line">  <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++</span></div><div class="line">    <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</div><div class="line">    &#123;</div><div class="line">      i++;</div><div class="line">      j++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]</span></div><div class="line">      <span class="comment">//next[j]即为j所对应的next值</span></div><div class="line">      j = next[j];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//匹配成功，返回模式串p在文本串s中的位置，否则返回-1</span></div><div class="line">  <span class="keyword">if</span> (j == pLen)</div><div class="line">      <span class="keyword">return</span> i - j;</div><div class="line">  <span class="keyword">else</span></div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="部分匹配表-Partial-Match-Table-next-数组"><a href="#部分匹配表-Partial-Match-Table-next-数组" class="headerlink" title="部分匹配表(Partial Match Table),next[]数组"></a>部分匹配表(Partial Match Table),next[]数组</h2><ul>
<li><p>这里大量摘录了<a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="external">如何更好的理解和掌握 KMP 算法? - 海纳的回答 - 知乎</a>的答案.</p>
</li>
<li><p>上文提及的表格即部分匹配表.</p>
</li>
<li><p>字符串的前缀和后缀。</p>
<ul>
<li>前缀: 如果字符串A和B，存在A=BS，其中S是任意的非空字符串，那就称B为A的前缀。例如，”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。</li>
<li>后缀: 后缀A=SB， 其中S是任意的非空字符串，那就称B为A的后缀，例如，”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。</li>
<li>要注意的是，字符串本身并不是自己的后缀。</li>
</ul>
</li>
<li><p>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度,如图<br><img src="https://my.mixtape.moe/sqrlty" alt="前后缀"></p>
</li>
<li><p>这里换一组字符串<code>“abababca”</code>说明next数组求法</p>
</li>
<li>求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。</li>
<li><p>具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行字符串搜索(KMP)。 在任一位置，能匹配的最长长度(<code>j值</code>)就是当前位置的next值。如下图所示。</p>
</li>
<li><p>如图</p>
<ul>
<li><img src="https://my.mixtape.moe/rcqxxn.jpg" alt="1"></li>
<li><img src="https://my.mixtape.moe/ifpzhm.jpg" alt="2"></li>
<li><img src="https://my.mixtape.moe/tlzuyg.jpg" alt="3"></li>
<li><img src="https://my.mixtape.moe/vhgima.jpg" alt="4"></li>
<li><img src="https://my.mixtape.moe/fsfjkq.jpg" alt="5"></li>
</ul>
</li>
<li><p>c语言实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>* p,<span class="keyword">int</span> next[])</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</div><div class="line">  next[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">int</span> k = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">//p[k]表示前缀，p[j]表示后缀</span></div><div class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])</div><div class="line">    &#123;</div><div class="line">      ++k;</div><div class="line">      ++j;</div><div class="line">      next[j] = k;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      k = next[k];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>流程(部分):</p>
<ul>
<li>next[6]=4</li>
<li>p[6] != p[4]; k = next[4] = 2</li>
<li>p[6] != p[2]; k = next[2] = 0</li>
<li>p[6] != p[0]; k = next[0] = -1</li>
<li>k == -1; ++k; ++j; next[7]=k=0;</li>
<li>……</li>
</ul>
</li>
<li><p>回到字符串”ABCDAB”,得到的next数组如下<br><img src="https://my.mixtape.moe/jiksho" alt="next"></p>
</li>
</ul>
<h2 id="next-数组改进"><a href="#next-数组改进" class="headerlink" title="next[]数组改进"></a>next[]数组改进</h2><ul>
<li>当 <code>j</code> 沿着next[]数组回溯时,可能产生一种情况是:连续几次回溯到的字符相同,即连续几次比较了模式字符串里相同的字符.</li>
<li><p>如上一节流程部分.</p>
<ul>
<li>p[4] p[2] p[0]都为元素a,实际只需要与 p[6] 比较一次即可.</li>
</ul>
</li>
<li><p>未避免这种情况,可以对next[]数组回溯链上,连续相同的字符合并,直接取前一个字符对应位置next[]数组的值.由此产生的数组叫<code>nextval数组</code>.</p>
</li>
<li><p>c代码实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextval</span><span class="params">(<span class="keyword">char</span>* p,<span class="keyword">int</span> next[])</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</div><div class="line">  next[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">int</span> k = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">//p[k]表示前缀，p[j]表示后缀</span></div><div class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])</div><div class="line">    &#123;</div><div class="line">      ++k;</div><div class="line">      ++j;</div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="keyword">if</span>(p[k]==p[j])</div><div class="line">      &#123;</div><div class="line">        next[j] = next[k];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">      &#123;</div><div class="line">        next[j] = k;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      k = next[k];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初步涉及KMP时,有些蒙蔽,还好遇到了 阮一峰 的讲解,才啃下来.博文图来自资料链接.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;资料来源如下&lt;/
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记—编译LineageOS源码</title>
    <link href="http://yoursite.com/2018/07/29/Android%E7%AC%94%E8%AE%B0%E2%80%94%E7%BC%96%E8%AF%91LineageOS%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2018/07/29/Android笔记—编译LineageOS源码/</id>
    <published>2018-07-29T04:00:00.000Z</published>
    <updated>2018-08-08T13:50:46.676Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>资料来源如下</p>
<ul>
<li><a href="https://www.isthnew.com/archives/build-lineageos.html" target="_blank" rel="external">记录下编译LINEAGEOS的过程</a></li>
<li><a href="https://www.htcp.net/741.html" target="_blank" rel="external">Ubuntu 16.04 LTS 下编译 LineageOS 源码</a></li>
<li><a href="https://wiki.lineageos.org/devices/klte/build#turn-on-caching-to-speed-up-build" target="_blank" rel="external">Build for klte</a></li>
</ul>
<p>编程环境</p>
<ul>
<li>Ubuntu16.04</li>
</ul>
<p>导语</p>
<ul>
<li>记录编译LineageOS 15.1的过程,备忘.</li>
</ul>
<hr>
<h1 id="编译LineageOS源码"><a href="#编译LineageOS源码" class="headerlink" title="编译LineageOS源码"></a>编译LineageOS源码</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><p>硬件上</p>
<ul>
<li>大于100G的硬盘剩余空间.SSD加速有奇效.</li>
<li>推荐i7+8G以上配置.(4代i7+16G+SSD编译时间2.5h参考)</li>
</ul>
</li>
<li><p>软件</p>
<ul>
<li>google官方的教程是ubuntu版本为14.04,这里使用16.04</li>
<li>全翻墙的环境,下载的话源码大约20GB.</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>足够耐心,相信大半问题都是网络导致的.</li>
<li>以下默认科学上网良好情况下进行.</li>
</ul>
</li>
</ul>
<h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><ul>
<li><p>依赖组件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt install -y bc bison build-essential curl flex gcc-multilib git git-core gnupg gperf g++-multilib libesd0-dev libgl1-mesa-dev liblz4-tool libncurses5-dev libreadline6-dev \</div><div class="line">libsdl1.2-dev libwxgtk3.0-dev libxml2 libxml2-utils libx11-dev lib32ncurses5-dev lib32z1-dev lzop pngcrush schedtool squashfs-tools \</div><div class="line">unzip xsltproc zip zlib1g-dev</div></pre></td></tr></table></figure>
</li>
<li><p>额外组件，可能会使用.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install imagemagick libbz2-dev libssl-dev lzma ncftp bash-completion</div></pre></td></tr></table></figure>
</li>
<li><p>LineageOS 14.1以上需要openjdk-8,这里是LineageOS 15.1.直接安装且不需要配置环境变量.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install -y openjdk-8-jdk</div></pre></td></tr></table></figure>
<ul>
<li>安装完成后输入<code>java -version</code>,返回<code>1.8</code>即正确安装.</li>
</ul>
</li>
</ul>
<h2 id="安装repo"><a href="#安装repo" class="headerlink" title="安装repo"></a>安装repo</h2><ul>
<li><p>repo是google用来管理android源码的工具,基于git实现.android源码的代码量级,直接使用git….你可以试试….</p>
</li>
<li><p>repo实际上是个python2的脚本.</p>
</li>
<li><p>下载并设置环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir -p ~/bin</div><div class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</div><div class="line">chmod a+x ~/bin/repo</div><div class="line"><span class="built_in">echo</span> <span class="string">"export PATH=~/bin:<span class="variable">$PATH</span>"</span> &gt;&gt; ~/.bashrc</div><div class="line"><span class="built_in">source</span> ~/.bashrc</div></pre></td></tr></table></figure>
</li>
<li><p>ps</p>
<ul>
<li>实在下载不下来,手动拖下来.</li>
<li>或者转清华源.</li>
</ul>
</li>
</ul>
<h2 id="初始化-LineageOS-存储库"><a href="#初始化-LineageOS-存储库" class="headerlink" title="初始化 LineageOS 存储库"></a>初始化 LineageOS 存储库</h2><ul>
<li><p>设置git</p>
<ul>
<li><p>设置邮箱</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.email <span class="string">"you@example.com"</span></div><div class="line">git config --global user.name <span class="string">"Your Name"</span></div></pre></td></tr></table></figure>
</li>
<li><p>生成SSH key 添加到 github (LineageOS代码现在托管在github)<br>过程自行google吧.</p>
</li>
</ul>
</li>
<li><p>初始化存储</p>
<ul>
<li><p>新建目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p ~/lineage-15.1</div></pre></td></tr></table></figure>
</li>
<li><p>初始化LineageOS的repo</p>
<ul>
<li><p>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repo init -u https://github.com/LineageOS/android.git -b lineage-15.1</div></pre></td></tr></table></figure>
</li>
<li><p>Enable color display in this user account (y/N)? y</p>
</li>
<li><p>ubuntu16即使设置了终端使用http代理,但git还是需要手动设置才能通过代理访问网络(本地http代理端口为80)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global http.proxy <span class="string">"localhost:80"</span></div></pre></td></tr></table></figure>
</li>
<li><p>这里可能因为网络或其他原因失败,删除 lineage-15.1/.repo文件夹,重新初始化即可.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>同步源码</p>
<ul>
<li><p>同步命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repo sync -f -j4 -c --no-clone-bundle</div></pre></td></tr></table></figure>
</li>
<li><p>注解:<br>-f : 强制<br>-j4 : 4线程,梯子良好情况下,更多线程无意义.<br>–no-clone-bundle : 忽略 clone 失败的信息</p>
</li>
<li>源码大约20G,国内的网络环境下需要很长一段时间了.</li>
<li>如果遇到同步失败,网络没问题情况下,执行<code>repo sync</code>即可,已经下载的数据不会再次重复.</li>
</ul>
</li>
<li><p>同步设备代码(这里是Galaxy S5 代号 klte )</p>
<ul>
<li><p>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> build/envsetup.sh</div><div class="line">breakfast klte</div></pre></td></tr></table></figure>
</li>
<li><p>执行后会同步 S5 对应的设备文件,大约1G.</p>
</li>
<li><p>获取设备vendor文件</p>
<ul>
<li><p>通过设备adb获取.<br>确保手机已经连接电脑，然后进入 <code>~/android/system/device/&lt;厂商&gt;/&lt;设备&gt;</code> 目录。然后执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./extract-files.sh</div></pre></td></tr></table></figure>
</li>
<li><p>或者在<a href="github.com/TheMuppets">TheMuppets</a>获取.</p>
<ul>
<li>手动下载添加.</li>
<li><p>或者在<code>LineageOS/.repo/local_manifests/roomservice.xml</code>最后添加</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"TheMuppets/proprietary_vendor_samsung"</span>  <span class="attr">path</span>=<span class="string">"vendor/samsung"</span>  <span class="attr">remote</span>=<span class="string">"github"</span>/&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>执行<code>repo sync</code>会将三星的所有设备vendor文件同步到本地</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul>
<li><p>设置ccache,这里设置缓存50G</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt install ccache -y</div><div class="line"><span class="built_in">echo</span> <span class="built_in">export</span> USE_CCACHE=1 &gt;&gt; ~/.bashrc</div><div class="line">prebuilts/misc/linux-x86/ccache/ccache -M 50G</div></pre></td></tr></table></figure>
</li>
<li><p>设置 jack 使用更多的内存</p>
<ul>
<li><p>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> ANDROID_JACK_VM_ARGS=<span class="string">"-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4G"</span></div><div class="line"><span class="built_in">source</span> ~/.bashrc</div></pre></td></tr></table></figure>
</li>
<li><p>有时需要重启jack</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">out/host/linux-x86/bin/jack-admin <span class="built_in">kill</span>-server</div><div class="line">out/host/linux-x86/bin/jack-admin start-server</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>编译变量</p>
<ul>
<li>带root <code>export WITH_SU=true</code></li>
<li>设置编译变量 <code>. ./build/envsetup.sh</code></li>
</ul>
</li>
<li><p>编译</p>
<ul>
<li><p>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">croot</div><div class="line">brunch klte</div></pre></td></tr></table></figure>
</li>
<li><p>之后是相当漫长的等待了.i7 16G SSD 2.5h.</p>
</li>
</ul>
</li>
</ul>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><ul>
<li><p>在OUT文件夹中,有编译完成的ROM.<br><code>lineage-15.1-20180729-UNOFFICIAL-klte.zip</code></p>
</li>
<li><p>ROM的其他修改及优化,待续.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;资料来源如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.isthnew.com/archives/build-lineageos.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;记录下编译LINEAGEOS的过程
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Android随手记—Attempt to invoke interface method &#39;&#39;on a null object reference</title>
    <link href="http://yoursite.com/2018/07/27/Android%E9%9A%8F%E6%89%8B%E8%AE%B0-Attempt%20to%20invoke%20interface%20method%20&#39;&#39;on%20a%20null%20object%20reference/"/>
    <id>http://yoursite.com/2018/07/27/Android随手记-Attempt to invoke interface method &#39;&#39;on a null object reference/</id>
    <published>2018-07-27T04:00:00.000Z</published>
    <updated>2018-07-27T14:35:57.731Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>编程环境</p>
<ul>
<li>Android Studio 3.1.2</li>
</ul>
<hr>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>myprivacy测试中一些应用在进入第二个activity时时常闪退,爆出空对象错误.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Attempt to invoke <span class="class"><span class="keyword">interface</span> <span class="title">method</span> '<span class="title">boolean</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">inputmethod</span>.<span class="title">InputConnection</span>.<span class="title">finishComposingText</span>()' <span class="title">on</span> <span class="title">a</span> <span class="title">null</span> <span class="title">object</span> <span class="title">reference</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>但本身Activity跳转之间并没有输入控件.</p>
</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul>
<li>Google到了,类似故障.<blockquote>
<p><a href="https://github.com/facebook/react-native/issues/18884" target="_blank" rel="external">https://github.com/facebook/react-native/issues/18884</a></p>
</blockquote>
</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li>关闭 Android Studio的<code>Advanced Profiling</code>即可,非代码错误</li>
</ul>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul>
<li>无</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;编程环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android Studio 3.1.2&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;
    
    </summary>
    
      <category term="Android随手记" scheme="http://yoursite.com/categories/Android%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
    
      <category term="Android Studio" scheme="http://yoursite.com/tags/Android-Studio/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>python—分析日志</title>
    <link href="http://yoursite.com/2018/06/26/python%E2%80%94%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2018/06/26/python—分析日志/</id>
    <published>2018-06-26T02:17:11.000Z</published>
    <updated>2018-06-26T14:50:14.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析日志"><a href="#分析日志" class="headerlink" title="分析日志"></a>分析日志</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li>简单分析日志文件中两个时间差.</li>
<li>计算平均值,中位数,方差等.</li>
<li>图形化展示.</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li><p>用到的功能</p>
<ul>
<li>系统io,只需要按行读入即可,当然需要指定gbk编码</li>
<li>科学计算的函数库</li>
<li>简单的画图库</li>
</ul>
</li>
<li><p>python库</p>
<ul>
<li>系统的 <code>io</code> 库即可</li>
<li><code>numpy</code> 库,大材小用</li>
<li><code>matplotlib.pyplot</code>,大材小用</li>
</ul>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li><p>按行读入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(path,encoding=<span class="string">'gbk'</span>) <span class="keyword">as</span> f:  </div><div class="line">  <span class="keyword">for</span> number, line <span class="keyword">in</span> enumerate(f):</div><div class="line">      <span class="comment">#去空格</span></div><div class="line">      line = line.strip().replace(<span class="string">' '</span>,<span class="string">''</span>)</div><div class="line">      <span class="comment">#匹配字符串</span></div><div class="line">      <span class="keyword">try</span>:</div><div class="line">          ln1 = line.index(str1)</div><div class="line">      <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</div><div class="line">          ln1 = <span class="number">1</span></div></pre></td></tr></table></figure>
</li>
<li><p>得到一个list 统计</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"数量"</span>,len(time))</div><div class="line">print(<span class="string">"平均值"</span>,np.mean(time))</div><div class="line">print(<span class="string">"最大值"</span>,np.max(time))</div><div class="line">print(<span class="string">"最小值"</span>,np.min(time))</div><div class="line">print(<span class="string">"方差"</span>,np.var(time))</div></pre></td></tr></table></figure>
</li>
<li><p>画图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#格式化转化为时间</span></div><div class="line"><span class="keyword">for</span> ts <span class="keyword">in</span> x :</div><div class="line">  tx.append(datetime.datetime.fromtimestamp(ts/<span class="number">1000</span>))</div><div class="line"></div><div class="line">plt.plot(tx,time)  </div><div class="line">plt.title(<span class="string">'len%d, mean%d, max%d, min%d'</span> % (len(time),np.mean(time),np.max(time),np.min(time))) <span class="comment"># 添加图形标题</span></div><div class="line">plt.show()</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分析日志&quot;&gt;&lt;a href=&quot;#分析日志&quot; class=&quot;headerlink&quot; title=&quot;分析日志&quot;&gt;&lt;/a&gt;分析日志&lt;/h1&gt;&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h
    
    </summary>
    
      <category term="python笔记" scheme="http://yoursite.com/categories/python%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>初入树莓派4----自建无污染DNS</title>
    <link href="http://yoursite.com/2018/06/26/%E5%88%9D%E5%85%A5%E6%A0%91%E8%8E%93%E6%B4%BE4----%E8%87%AA%E5%BB%BA%E6%97%A0%E6%B1%A1%E6%9F%93DNS/"/>
    <id>http://yoursite.com/2018/06/26/初入树莓派4----自建无污染DNS/</id>
    <published>2018-06-26T02:17:11.000Z</published>
    <updated>2018-06-26T14:50:38.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自建无污染DNS"><a href="#自建无污染DNS" class="headerlink" title="自建无污染DNS"></a>自建无污染DNS</h1><ul>
<li>GFW ISP 还有无良的第三方,搞的上个网 DNS 被污染的不成样子.</li>
</ul>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li>国内/国外分流,国内网站交给国内DNS,国外的交给墙外无污染DNS.</li>
<li>对CDN友好,访问百度,我在广州,你DNS分配个青岛的地址要闹那样.</li>
<li>带有DNS缓存,加速解析.</li>
<li>跨平台(小),出门不能一直带着路由器啊.</li>
</ul>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul>
<li>国内/国外分流</li>
<li><p>分流可使用ChinaDNS.</p>
<ul>
<li>无污染DNS<ul>
<li>墙外DNS,但udp-53端口,基本被劫持.需要特别方式规避.<ul>
<li>非标准DNS端口 例如 opendns的udp-5353端口 tcp-443端口</li>
<li>DNS over HTTPS ,支持最好的是google-dns及 Cloudflare-dns,其中google-dns比较麻烦,还需要自行寻找可用的google ip地址.</li>
<li>DNS over TLS ,与上一个类似.</li>
<li>DNSCrypt ,支持此项的公共DNS很多,与此被干扰的也比较厉害.</li>
</ul>
</li>
<li>ss/ssr-vpn-v2ray 等代理解析dns.</li>
<li>一直可用的中科大DNS 北方还好.</li>
</ul>
</li>
</ul>
</li>
<li><p>对CDN友好选择支持EDNS的上游DNS,国内主流都支持了,除了114.</p>
</li>
<li>带有DNS缓存,这个用的较多的 dnsmasq ,当作下游DNS.</li>
<li>跨平台(大雾),一般都在路由器搞搞.</li>
</ul>
<h2 id="最终定型"><a href="#最终定型" class="headerlink" title="最终定型"></a>最终定型</h2><ul>
<li><p>dnsmasq(可选) + <a href="https://github.com/shawn1m/overture" target="_blank" rel="external">overture</a> + 上游加密DNS(可选)</p>
</li>
<li><p>overture DNS分流净化器,go语言编写,解决chinadns不稳定而编写.</p>
<ul>
<li>得益于go的跨平台能力,基本通吃.</li>
<li>已经支持DNS缓存</li>
<li>支持tcp / udp DNS查询</li>
<li>比chinadns更加稳定.</li>
</ul>
</li>
<li><p>实际上如果只需要一个纯净DNS,只使用<code>overture</code>就足够了.</p>
</li>
<li>当需要广告过滤时,添加dnsmasq.</li>
<li><code>overture</code>可使用 非标准dns端口查询dns,解决上游DNS污染问题.非标准端口被大量干扰或dns查询全程保密,才需要使用DNSCrypt DNS over HTTPS等额外措施.</li>
</ul>
<h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><ul>
<li><p>下载<a href="https://github.com/shawn1m/overture/releases" target="_blank" rel="external">最新releases</a></p>
</li>
<li><p>解压 以win-64为例,打开配置文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">"BindAddress": ":53",//本地监听端口</div><div class="line">"PrimaryDNS": [//主DNS (国内) 可设置多组</div><div class="line">    &#123;</div><div class="line">    "Name": "DNSPod",</div><div class="line">    "Address": "119.29.29.29:53",//腾讯DNS还可以 支持EDNS</div><div class="line">    "Protocol": "udp",//UDP查询 TCP查询</div><div class="line">    "SOCKS5Address": "",</div><div class="line">    "Timeout": 6,</div><div class="line">    "EDNSClientSubnet": &#123;//EDNS支持</div><div class="line">        "Policy": "auto",//disable 关闭 auto启用</div><div class="line">        "ExternalIP": ""//EDNS查询用IP ,设置则使用此IP</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">],</div><div class="line">"AlternativeDNS": [//无污染DNS 可设置多组</div><div class="line">    &#123;</div><div class="line">    "Name": "OpenDNS",//OpenDNS</div><div class="line">    "Address": "208.67.222.222:5353",//非标准dns端口</div><div class="line">    "Protocol": "udp",//走udp</div><div class="line">    "SOCKS5Address": "",</div><div class="line">    "Timeout": 6,</div><div class="line">    "EDNSClientSubnet": &#123;//edns只支持udp so 选择了udp的非标准端口</div><div class="line">        "Policy": "auto",</div><div class="line">        "ExternalIP": ""</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">],</div><div class="line">"OnlyPrimaryDNS": false,//只启用主DNS?</div><div class="line">"RedirectIPv6Record": false,//重定向 IPV6 DNS ?</div><div class="line">"IPNetworkFile": "./ip_network_sample",//ip文件</div><div class="line">"DomainFile": "./domain_sample",//域名文件</div><div class="line">"DomainBase64Decode": true,//域名文件使用Base64编码?</div><div class="line">"HostsFile": "./hosts_sample",//host文件</div><div class="line">"MinimumTTL": 0,//dns的 ttl设置,0禁用</div><div class="line">"CacheSize" : 500,//域名缓存的数量.按照实际使用习惯配置</div><div class="line">"RejectQtype": [255]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>保存文件</p>
</li>
<li>启动exe即可</li>
<li>windows 下可以使用 nssm 包装成windows的server,做到开机启动.</li>
<li>linux 下,各种脚本为所欲为.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;自建无污染DNS&quot;&gt;&lt;a href=&quot;#自建无污染DNS&quot; class=&quot;headerlink&quot; title=&quot;自建无污染DNS&quot;&gt;&lt;/a&gt;自建无污染DNS&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;GFW ISP 还有无良的第三方,搞的上个网 DNS 被污染的不成样子.&lt;/li
    
    </summary>
    
      <category term="树莓派" scheme="http://yoursite.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>算法—查找</title>
    <link href="http://yoursite.com/2018/06/03/%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2018/06/03/算法-查找/</id>
    <published>2018-06-03T04:00:00.000Z</published>
    <updated>2018-06-04T12:12:21.913Z</updated>
    
    <content type="html"><![CDATA[<hr>
<ul>
<li>记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演.</li>
</ul>
<p>资料来源如下</p>
<ul>
<li>算法第四版</li>
</ul>
<hr>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><ul>
<li>基于符号表的抽象来组织查找有关内容.分为 key-value ,有时又称字典.</li>
<li>分别介绍 二叉查找树 红黑树 及 散列表 3种经典的实现.</li>
</ul>
<h1 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h1><ul>
<li>定义: 存储键值对的数据结构,支持<code>put</code>插入 及 <code>get</code>查找操作.</li>
<li><p>API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value val)</span></span></div><div class="line">Value <span class="title">get</span><span class="params">(Key key)</span></div><div class="line"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></div><div class="line"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span></div><div class="line"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></div><div class="line"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></div><div class="line">Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></div></pre></td></tr></table></figure>
</li>
<li><p>规则</p>
<ul>
<li>没有重复key</li>
<li>key不能为空</li>
<li>value不能为空</li>
<li>删除操作即使实现.</li>
<li>key为不可变类型数据.</li>
</ul>
</li>
<li><p>成本</p>
<ul>
<li>使用比较次数来统计成本.</li>
<li>内循环不进行比较时,统计数组访问次数.</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>有序符号表</p>
<ul>
<li>额外API</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">main()</div><div class="line">max()</div><div class="line">floor(Key key)</div><div class="line">select(<span class="keyword">int</span> k)</div></pre></td></tr></table></figure>
</li>
<li><p>无序符号表</p>
<ul>
<li>经典的基于链表实现.</li>
</ul>
</li>
</ul>
<h1 id="二叉查找树BST"><a href="#二叉查找树BST" class="headerlink" title="二叉查找树BST"></a>二叉查找树BST</h1><ul>
<li><p>数据结构:结点</p>
<ul>
<li>一个唯一key</li>
<li>对应value</li>
<li>一条左链接</li>
<li>一条右链接</li>
<li>一个节点计数器(该节点的子节点总数)</li>
</ul>
</li>
<li><p><code>get</code>方法<br>表中存在对应方法即返回对应值,否则返回空.<br>代码:递归实现</p>
<ul>
<li>实现<code>get(Node x,Key key)</code><ul>
<li>查找Key 对应值,没有返回null</li>
<li>对比 x 与 key 值.</li>
<li>根据结果返回 <code>get(x.right,key)</code> or <code>get(x.left,key)</code></li>
</ul>
</li>
<li>get由传入根节点调用 <code>get(Node x,Key key)</code></li>
</ul>
</li>
<li><p><code>put</code>方法<br>存在则更新值,不存在则插入新值.<br>代码:递归实现</p>
<ul>
<li>实现<code>Node put(Node x,Key key,Value val)</code><ul>
<li>x为空,则创建新节点并插入key val</li>
<li>对比x key 值</li>
<li>x = key,则更新值.</li>
<li>根据结果返回 <code>put(x.right,key,val)</code> or <code>put(x.left,key,val)</code></li>
<li>更新节点计数器</li>
</ul>
</li>
<li>put传入根节点 调用<code>Node put(Node x,Key key,Value val)</code></li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>如同<code>union-find</code>问题,二叉树生长的方式及平均深度对查找及插入的影响很大.<strong>二叉查找树性能非常依赖于 key分布足够随机.</strong></li>
</ul>
</li>
</ul>
<h2 id="有序符号表"><a href="#有序符号表" class="headerlink" title="有序符号表"></a>有序符号表</h2><ul>
<li><p>最大最小</p>
<ul>
<li>传入节点左链接是否为空? 返回传入节点 : 递归调用min(x.left)</li>
<li>传入节点左链接是否为空? 返回传入节点 : 递归调用mam(x.right)</li>
</ul>
</li>
<li><p>向上/下取整</p>
<ul>
<li>递归<ul>
<li>传入节点左链接 为空.返回 null</li>
<li>传入节点左链接 = key-value 返回 传入节点</li>
<li>传入节点左链接 &lt; key-value 返回 递归传入左链接</li>
<li>传入节点左链接 &gt; key-value 递归传入右链接<ul>
<li>判断返回值t 为空?<ul>
<li>不为空返回 t</li>
<li>为空返回传入节点.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>递归调用.</li>
</ul>
</li>
<li><p>排名</p>
<ul>
<li>与节点计数器有关.</li>
<li>key = 传入节点,返回左子树节点总数.</li>
<li>key &lt; 传入节点,返回 递归左子树.</li>
<li>key &gt; 传入节点,返回 递归右子树.</li>
</ul>
</li>
<li><p>删除最大/最小键</p>
<ul>
<li>删除最大/最小值,因其子链接均为空,无妨.</li>
</ul>
</li>
<li><p>删除 -二叉树中间呢?</p>
<ul>
<li>查找到要删除的节点</li>
<li>保存 父链接 左右子链接.</li>
<li>选择右子树,查找最小节点.(不断选择左子树,直到遇到左子链接为空元素)</li>
<li>将 右子树最小元素 移植到 已删除元素位置.</li>
<li>处理 右子树最小元素 右子链接(直接链接到父节点)</li>
<li>可能存在性能问题.</li>
</ul>
</li>
<li><p>范围查找</p>
<ul>
<li>首先遍历操作<ul>
<li>递归要不要简单</li>
<li>x为空? 返回</li>
<li>过程处理.</li>
<li>不为空, 递归左节点 递归右节点.</li>
</ul>
</li>
<li>在过程处理中进行过滤操作.</li>
<li>因二叉树数值相对有序,舍弃掉不存在想要值的子树.</li>
</ul>
</li>
</ul>
<h1 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a>平衡查找树</h1><hr>
<ul>
<li>只使用二叉树而保持树生长的平衡,代价很高.</li>
<li>so,对节点的基础数据结构动一些手脚,引入 2-3 树.</li>
<li>最大的变化在于插入新元素.但随之带来的完美平衡的 2-3 树,让数据结构复杂度很值.</li>
</ul>
<hr>
<ul>
<li>节点可以保存2个key,3个子链接.代表 <a ,a<="" <b="" ,="">b 3种.</a></li>
<li><p>随之带来的好处,树可以一直保持为 完美平衡.所有空链接,到根节点的距离相同.</p>
</li>
<li><p>查找</p>
<ul>
<li>相对二叉树变动不大.依旧是递归实现.</li>
<li>在判断时加入了2 3节点的指向判断,难度不大,直到遇到空链接为止.</li>
</ul>
</li>
<li><p><strong>插入</strong></p>
<ul>
<li>我们所设想的依旧是通过递归的方式实现.尽量统一实现方式.</li>
<li><p>过程类似,查找插入位置-&gt;插入数据-&gt;恢复</p>
<ul>
<li>空节点<ul>
<li>直接插入数据即可</li>
</ul>
</li>
<li>2节点<ul>
<li>将2节点,变更为3节点.</li>
</ul>
</li>
<li><p>3节点(比较麻烦)</p>
<ul>
<li>父节点为空: 直接存入数据-&gt;节点变为4节点-&gt;4节点分解为3个 2节点,深度+1.</li>
<li>父节点为2节点: 直接存入数据-&gt;节点变为4节点-&gt;将父节点变为3节点-&gt;4节点分解为两个 2节点.</li>
<li>父节点为3节点: 直接存入数据-&gt;节点变为4节点-&gt;将父节点变为4节点-&gt;父节点向上反推过程,直到遇到2节点为止-&gt;4节点分解为两个2节点.</li>
<li>整个过程: 存入变4节点,向上反推 直到遇到空节点/2节点为止.分解恢复2-3树.</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li>即使最坏情况下,大小为N的 2-3 树,插入及查找操作访问节点必然不超过 lgN ,因为2-3树保持了完美的平衡.</li>
<li>但额外的维护代码冗余,由此引出红黑树.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ul>
<li>将2-3树中 1个 3节点 拆分为 2个2节点,中间使用红色链接.</li>
<li>插入/删除 相较于2-3树,复杂.但基础数据结构简单.</li>
<li><p>牺牲一些平衡性,换来 程序设计的便利.</p>
</li>
<li><p>前置要求</p>
<ul>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
</li>
<li><p>数据结构</p>
<ul>
<li>在二叉树基础上增加了节点颜色一项.其他不变.</li>
</ul>
</li>
</ul>
<h2 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ul>
<li><p>右/左旋</p>
</li>
<li><p>颜色变化</p>
</li>
<li><p>查找</p>
<ul>
<li>与二叉树查找相同.</li>
</ul>
</li>
<li><p>插入</p>
<ul>
<li>类比2-3树,更加复杂,但基本过程一致.</li>
<li>查找位置-&gt;插入节点-&gt;修复红黑树.</li>
<li>插入</li>
</ul>
</li>
</ul>
<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;资料来源如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法第四版&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;he
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法—优先队列&amp;堆排序&amp;排序应用</title>
    <link href="http://yoursite.com/2018/06/02/%E7%AE%97%E6%B3%95-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97&amp;%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/06/02/算法-优先队列&amp;堆排序/</id>
    <published>2018-06-02T04:00:00.000Z</published>
    <updated>2018-06-02T13:25:19.724Z</updated>
    
    <content type="html"><![CDATA[<hr>
<ul>
<li>记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演.</li>
</ul>
<p>资料来源如下</p>
<ul>
<li>算法第四版</li>
</ul>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>优先队列是一种抽象数据结构.支持删除最大元素及插入元素.</li>
<li>有很多不同的实现方式,最经典的是基于二叉堆的实现.</li>
<li>排序的逻辑:<ul>
<li>将数组输入优先队列</li>
<li>通过优先队列 取最大元素</li>
<li>直到取完为止,排序完成.</li>
</ul>
</li>
<li>但是请注意,<strong>优先队列的应用远远不止于此.</strong></li>
</ul>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><ul>
<li><p>概念: 一种抽象数据模型,有两个必须支持的操作</p>
<ul>
<li>删除最大元素</li>
<li>插入元素.</li>
</ul>
</li>
<li><p>API定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">Key <span class="title">delMax</span><span class="params">()</span><span class="comment">//返回并 删除最大元素</span></span></div><div class="line"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span><span class="comment">//插入元素</span></div><div class="line"><span class="keyword">void</span> <span class="title">MaxPQ</span><span class="params">()</span><span class="comment">//初始化优先队列</span></div><div class="line"><span class="keyword">void</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> max)</span><span class="comment">//初始化max容量优先队列</span></div><div class="line"><span class="keyword">void</span> <span class="title">MaxPQ</span><span class="params">(Key[] a)</span><span class="comment">//初始化 a[]的优先队列</span></div><div class="line">Key <span class="title">Max</span><span class="params">()</span><span class="comment">//返回最大值</span></div><div class="line"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span><span class="comment">//是否为空</span></div><div class="line"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="comment">//优先队列大小</span></div></pre></td></tr></table></figure>
<ul>
<li>最重要的的方法是<code>delMax()</code>及 <code>insert()</code></li>
<li>后面重要的改进都是针对这两个方法.</li>
</ul>
</li>
<li><p>实现方式</p>
<ul>
<li>有序数组<ul>
<li>每进来一个元素,就进行一次排序.</li>
<li><code>delMax()</code> 1, <code>insert()</code> 看排序算法.大于线性.</li>
</ul>
</li>
<li>无需数组<ul>
<li>添加新元素不操作,删除最大元素再查找.</li>
<li><code>delMax()</code> N, <code>insert()</code> 1.</li>
</ul>
</li>
<li>二叉堆<ul>
<li>使用二叉堆来实现优先队列.</li>
<li>平衡了<code>delMax()</code> 及 <code>insert()</code></li>
<li><code>delMax()</code> logN, <code>insert()</code> logN`.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><ul>
<li><ul>
<li>基于二叉堆实现的优先队列  <code>delMax()</code> logN, <code>insert()</code> logN`.</li>
</ul>
</li>
<li><p>这里使用数组而不是指针表示二叉树.</p>
<ul>
<li>数组中位置k的节点,父节点位置 为[k/2],子节点位置 [2k] 及 [2k+1].数组0 位置不启用.</li>
</ul>
</li>
<li><p>一个大小为N的完全二叉树,高度为 lgN .</p>
</li>
<li><p><strong>父节点值大于两个子节点值</strong>,当此条件全部节点满足时,称为 堆有序.</p>
</li>
<li><p>API <strong>重点!</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">swim()<span class="comment">//上浮</span></div><div class="line">sink()<span class="comment">//下沉</span></div><div class="line">`</div></pre></td></tr></table></figure>
<ul>
<li>上浮: 某个节点大于其父节点,将此节点向上浮动直到到达正确位置.</li>
<li>下沉: 某个节点小于其子节点,将此节点向下下沉,直到到达正确位置.</li>
<li>代码实现较容易,不再累赘.</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li><code>insert()</code> : 将元素插入数组末尾,上浮至正确位置,堆恢复有序.</li>
<li><code>delMax()</code> : 删除根节点,将数组最后一个元素迁移至根节点,下沉至正确位置,堆恢复有序.</li>
</ul>
</li>
<li><p>与之相对的,查找删除最小元素.一切相同.</p>
</li>
</ul>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><ul>
<li><p>逻辑</p>
<ul>
<li>堆构造 : 将数组使用转化为二叉堆表示.</li>
<li>下沉排序: 依次取出 最大/最小 元素,下沉恢复堆有序,直到最后一个元素为止.</li>
<li>有趣的是,堆排序 完全不需要额外空间.</li>
</ul>
</li>
<li><p>堆构造</p>
<ul>
<li>上浮构造,类似优先队列的<code>insert()</code>. 由左向右,遍历整个数组,一个一个插入新元素,同时恢复堆有序.<br>保证待插入元素左侧,一直处于堆有序,直到全部插入为止.</li>
<li>下沉构造,类似<code>delMax()</code>,由右向左,不断将新元素下沉方式,保证带插入元素,右侧堆有序.</li>
<li>上浮构造,是一个有序堆,从0 开始生长到N,下沉构造则利用了数组的每个位置已经是一个子堆根节点,只需要扫描一般的元素即可</li>
</ul>
</li>
<li><p>下沉构造.无需多言,递归的取根节点,不断恢复堆有序.直到排序完成.</p>
</li>
<li><p>分析</p>
<ul>
<li>堆排序是目前已知的唯一可以同时最优的利用空间和时间啊的算法.</li>
<li>但!,堆缓存的利用率太低,总是比较位置相差很远的元素.缓存未命中几率远远大于其他排序.</li>
</ul>
</li>
</ul>
<h1 id="排序应用"><a href="#排序应用" class="headerlink" title="排序应用"></a>排序应用</h1><ul>
<li>快速排序是目前最快的通用排序算法.</li>
<li><p>库函数有实现时,才考虑自行编写.</p>
</li>
<li><p>嗯,排序部分,结束…😂…</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;资料来源如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法第四版&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;he
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法—排序</title>
    <link href="http://yoursite.com/2018/06/02/%E7%AE%97%E6%B3%95%E2%80%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/06/02/算法—排序/</id>
    <published>2018-06-02T03:00:00.000Z</published>
    <updated>2018-06-02T13:21:10.876Z</updated>
    
    <content type="html"><![CDATA[<hr>
<ul>
<li>记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演.</li>
</ul>
<p>资料来源如下</p>
<ul>
<li>算法第四版</li>
</ul>
<hr>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ul>
<li><p>步骤</p>
<ul>
<li>寻找数组内最小的元素</li>
<li>与未排列的第一个元素交换位置.</li>
<li>重复1 2 知道数组排列完成.</li>
</ul>
</li>
<li><p>代码</p>
<ul>
<li>内循环 比较当前元素与已知最小元素</li>
<li>外循环 交换元素位置</li>
</ul>
</li>
<li><p>性质</p>
<ul>
<li>运行时间与输入无关..数组有序无序不影响时间.</li>
<li>数据移动最少.交换次数 与 数组长度 为线性关系.</li>
<li>长度为N的数组 , 选择排序 N2/2 次比较,及N次交换.</li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>最直观的排序算法.</li>
<li>无法利用数组的初始状态进行优化.(后续重点)</li>
</ul>
</li>
</ul>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ul>
<li><p>步骤</p>
<ul>
<li>遍历未排列数组,比较两个相邻元素,依照规则 交换/不交换位置.</li>
<li>重复1,直到完成数组排序.</li>
</ul>
</li>
<li><p>代码</p>
<ul>
<li>内循环 冒泡整个未排序数组</li>
<li>外循环 控制内循环 冒泡范围</li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>可能是效率最差的</li>
<li>实际效率与选择排序差不多.</li>
</ul>
</li>
</ul>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><ul>
<li><p>步骤</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素,比较已排序序列,找到新元素位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤直到排序完成.</li>
</ul>
</li>
<li><p>代码</p>
<ul>
<li>取出新元素</li>
<li>内循环查找新元素位置</li>
<li>插入新元素</li>
<li>外循环控制</li>
</ul>
</li>
<li><p>性质</p>
<ul>
<li>随机数组N, 平均需要 ~ N2/4 次比较及 ~N2/4 次交换.</li>
<li>最坏 N2/2 次比较 N2/2 次交换</li>
<li>最好 N-1 次比较 0 次交换(已经排序好的….😂)</li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>考虑了数组的初始状态,对于大多数元素有序的数组,插入排序可能是最快的.</li>
<li>但对于随机数组 还不够.</li>
</ul>
</li>
<li><p>优化</p>
<ul>
<li>查找新元素位置: 二分法查找.而不是遍历.</li>
<li>插入新元素时,算法第四版 建议,内循环改为类似冒泡方式,将大元素右移</li>
</ul>
</li>
</ul>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><ul>
<li>对插入排序分析时,有这样的结论: 对于大多数元素有序的数组,插入排序时间最快,时间为线性级别.<br>将任意输入的数组 大多数元素有序,然后最后使用 插入排序.</li>
<li>插入排序对于 随机数组的瓶颈 在于,一个元素到达正确位置,一次只能移动一位.那么一次可以移动多位,交换至很远位置,可以改善插入排序的性能.</li>
<li>思路: 将数组等间隔 <code>h</code> 分裂,进行插入排序.拆分后的子数组,插入排序成本较低,进行插入排序.</li>
<li><p>完成后,原数组的有序性增加 插入排序成本降低,之后再进行颗粒度更细的拆分-排序.一级一级的降低 插入排序成本.直到最后进行 <code>h=1</code>的插入排序.</p>
</li>
<li><p>步骤</p>
<ul>
<li>对数组进行间隔 h 的插入排序.</li>
<li>依照递增序列,取 h 值,直到 h = 1,为止,排序完成.</li>
</ul>
</li>
<li><p>代码</p>
<ul>
<li>内循环为 间隔 h 的插入排序</li>
<li>外循环为 计算 h 值的递增序列.</li>
</ul>
</li>
<li><p>性质</p>
<ul>
<li>希尔排序的性质并不容易概括,实际上没有完整概括.</li>
<li>目前可以证明的:希尔排序的运行时间 达不到 N2 级别.</li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>考虑了数组初始状态.是如今提到的排序算法中,第一个可以适用与大容量数组排序的.</li>
<li>h 递增序列的选择,会很大程度上影响希尔排序效果.实际工程中适用那种,需要自行选择.</li>
<li>嵌入式系统中没有快排等库函数可选时,首选希尔排序.之后再考虑其他排序算法.</li>
</ul>
</li>
</ul>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><ul>
<li>归并排序的实现与插入/希尔/选择排序不同.</li>
<li><p>归并排序依赖于 归并操作.</p>
<ul>
<li>归并 : 将两个有序数组 合并 为1个有序数组.</li>
</ul>
</li>
<li><p>自顶向下 递归</p>
<ul>
<li>实际上是一个 sort 的递归调用.</li>
<li>将数组分为 两个子数组</li>
<li>对子数组调用 调用sort</li>
<li>再对第二层子数组 调用 sort</li>
<li>直到最终子数组元素个数为1.递归返回 开始执行 merge()操作.</li>
</ul>
</li>
<li><p>自底而上 迭代</p>
<ul>
<li>直接归并 子元素为1 的各个数组到 子元素为2的数组.</li>
<li>再归并子元素为2 的各个数组 到子元素为4的数组.</li>
<li>最后 可能存在 数组元素不相等,但是不影响归并.</li>
<li>直到归并的数组元素为 N.</li>
</ul>
</li>
<li><p>实际上 两者执行的过程是一样的,只是调用的角度不同.</p>
</li>
<li><p>性质</p>
<ul>
<li>空间复杂度不是最优.</li>
<li>时间复杂度 NlogN</li>
<li>空间复杂度 N</li>
</ul>
</li>
<li><p>优化</p>
<ul>
<li>原理相同,对小的子数组 使用其他高效排序,再归并.</li>
</ul>
</li>
</ul>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><ul>
<li>应用最为广泛. 原地排序 时间成本 NlogN</li>
<li><p><strong>但是!</strong> 坑不少…</p>
</li>
<li><p>原理</p>
<ul>
<li>对于数组中 某个元素 都进行切分操作,大于/小于 该元素的所有元素 都在 一边. 将数组切分为2个子数组. 递归,直到切分子数组元素个数为1,完成排序.</li>
<li>与归并排序 在数组分解上 一致.</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li>取出数组中某个元素 作为切分元素.</li>
<li>对数组执行切分.</li>
<li>对子数组执行 1 2 直到子数组元素个数为1.递归.</li>
</ul>
</li>
<li><p>坑</p>
<ul>
<li>原地切分,创建大量新对象性能上不可接受</li>
<li>保证访问不越界.</li>
<li>慎重处理最大最小元素.</li>
<li>相同元素谨慎处理.</li>
</ul>
</li>
<li><p>性能改进</p>
<ul>
<li>切分元素对性能影响及其重要.<ul>
<li>最糟糕情况: 大部分元素有序,使用极值去切分.</li>
<li>为避免这种情况,快排之前,将输入数组乱序处理.</li>
<li>对于大型数组 取切分元素时 考虑去3 选 1.</li>
</ul>
</li>
<li>小数组<ul>
<li>使用切换到插入排序.</li>
</ul>
</li>
<li>重复元素<ul>
<li>一分为二,对于存在大量重复元素的数组,无效的比较次数较多.</li>
<li>改为 三取样切分</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三切分取样"><a href="#三切分取样" class="headerlink" title="三切分取样"></a>三切分取样</h2><ul>
<li>切分时,不再一分为二,改为 &lt; = &gt;.三部分</li>
<li>三项切分的信息量最优.</li>
<li>对于存在大量重复元素的数组,三切分取样,直接将时间 由 NlogN 降低到了 N .</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;资料来源如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法第四版&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法— union-find</title>
    <link href="http://yoursite.com/2018/05/31/%E7%AE%97%E6%B3%95%E2%80%94union-find/"/>
    <id>http://yoursite.com/2018/05/31/算法—union-find/</id>
    <published>2018-05-31T04:00:00.000Z</published>
    <updated>2018-05-31T15:32:30.516Z</updated>
    
    <content type="html"><![CDATA[<hr>
<ul>
<li>记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演.</li>
</ul>
<p>资料来源如下</p>
<ul>
<li>算法第四版</li>
</ul>
<hr>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ul>
<li><p>白话文: 一堆网点,随机相连,设计一个算法快速检查两个点是否联通.</p>
</li>
<li><p>物理对应: 闲的一堆金属触点,随机用导线连接,快速查找两个点电路通不通.</p>
</li>
<li><p>精确描述:</p>
<ul>
<li><p>定义如下API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UF(<span class="keyword">int</span> N) ;<span class="comment">//初始化 N 个点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span><span class="comment">//连接p q</span></span></div><div class="line"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//N个点的分量标识符</span></div><div class="line"><span class="keyword">boolean</span> <span class="title">conneted</span><span class="params">(<span class="keyword">int</span> p ,<span class="keyword">int</span> q)</span><span class="comment">//p q联通返回true</span></div><div class="line"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span><span class="comment">//连通分量数量</span></div></pre></td></tr></table></figure>
</li>
<li><p>设计算法的任务分解为</p>
<ul>
<li>定义数据结构高效表示连通.</li>
<li>高效实现API方法.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h1><ul>
<li>叙述原理,不拘泥于代码</li>
</ul>
<h2 id="quick-find"><a href="#quick-find" class="headerlink" title="quick-find"></a>quick-find</h2><ul>
<li><p>第一印象,所谓连通两个点,类似物理上的通路,表示两个点的id的值 相同即可.</p>
</li>
<li><p>p q 连通,则标识量置为相同值.</p>
</li>
<li><p>分析</p>
<ul>
<li>非常直观</li>
<li>find conneted 非常快.</li>
<li>union随着需要连接的节点数量而增大,每次执行 union 都需要遍历整个网格.时间复杂度平方.</li>
<li>大型网格union成本不可接收.</li>
</ul>
</li>
<li><p>改进</p>
<ul>
<li>从标识量入手,降低 union 复杂度,即使意味着 find conneted 等成本上升.</li>
<li>平衡各个方法成本.</li>
</ul>
</li>
</ul>
<h2 id="quick-union"><a href="#quick-union" class="headerlink" title="quick-union"></a>quick-union</h2><ul>
<li><p>肯定要对标识量下手了,极端一点,将标识量 改为类似树木生长的实现,每个连通拥有一个根元素.<br>conneted 判断两个节点的根元素是否相同.<br>union 连通 即将两个连通的根元素 链接.<br>find 直接返回根节点.</p>
</li>
<li><p>这样 union 的复杂度降低,找到根节点,新建一个链接即可完成.</p>
</li>
<li><p>分析</p>
<ul>
<li>逻辑上也比较好理解,类似 连通节点,用绳子串起来了.</li>
<li>union 的时间复杂度 降低到了线性级别.</li>
<li>但 find 的成本在最糟糕情况下到了 平方 级别.</li>
<li>最糟糕生长情况,从上到下,一个深度只有一个节点.</li>
</ul>
</li>
<li><p>改进</p>
<ul>
<li>由导致 find 最糟糕情况入手,避免这种情况.关注点在 树生长的过程.</li>
</ul>
</li>
</ul>
<h2 id="加权quick-union"><a href="#加权quick-union" class="headerlink" title="加权quick-union"></a>加权quick-union</h2><ul>
<li><p>我们的目标 控制树的生长,即控制树生长的深度,尽力减少平均深度.</p>
</li>
<li><p>主要做法: union 时,区分大小树,(节点多的树为大),小树只能链接到大树.代码上 要增加一个 数组来标识 一个连通的节点数.</p>
</li>
<li><p>分析</p>
<ul>
<li>可以很好控制 树生长的高度.</li>
<li>各个方法的时间复杂度,平衡很好.</li>
<li>但是还不是最完美.</li>
</ul>
</li>
<li><p>改进</p>
<ul>
<li>继续改进 union 时操作,控制树生长的高度.</li>
</ul>
</li>
</ul>
<h2 id="路径压缩的加权quick-union"><a href="#路径压缩的加权quick-union" class="headerlink" title="路径压缩的加权quick-union"></a>路径压缩的加权quick-union</h2><ul>
<li><p>对 union 操作似乎无法继续改进.</p>
</li>
<li><p>但是从直觉上考虑,要控制树的深度,最直接的情况就是所有节点直接连接到根节点.</p>
</li>
<li><p>so,在 find 操作中 加入这个转换,将所有节点 直接 连接到根节点.</p>
</li>
<li><p>分析</p>
<ul>
<li>这是我们目前可以找到的最优解.</li>
<li>但不是所有操作都可以在场数级别.</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>完整详细定义问题,找到解决问题所必须的抽象操作并定义 <code>API</code></li>
<li>对于搜索类操作,改进算法的一个方面是: 增加一个数据点可以访问的维度.不限于周围元素,通过某种对应关系,拓展维度.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;记录学习数据结构的总结,希望可以不拘泥于细节和语言,重视应用与推演.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;资料来源如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法第四版&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vscode系列-python</title>
    <link href="http://yoursite.com/2018/05/24/Vscode%E7%B3%BB%E5%88%97-python/"/>
    <id>http://yoursite.com/2018/05/24/Vscode系列-python/</id>
    <published>2018-05-24T04:00:00.000Z</published>
    <updated>2018-05-24T13:50:43.939Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>环境</p>
<ul>
<li>vscode 1.20.x</li>
<li>ubuntu</li>
</ul>
<hr>
<ul>
<li>备注:<br>  转载自<a href="https://www.cnblogs.com/bloglkl/archive/2016/08/23/5797805.html" target="_blank" rel="external">用VSCode写python的正确姿势</a></li>
</ul>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>写嵌入式的c语言太难搞了,受够了盗版 sourceinsight 艰难的代码提示和补全之后,尝试换一款编辑器.</li>
<li>跨平台,支持多种语言,自由度高.</li>
<li>vim 和 Emacs 命令行 有一点学习成本.</li>
<li>最后选定了 vscode 业余写点 python 和 java 写写 markdown 博客等等 (看pdf也行…).</li>
</ul>
<hr>
<ul>
<li>注意vscode首先是个编辑器,其他的功能都是通过 插件 + 后端 实现的.</li>
</ul>
<hr>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ul>
<li><p>代码补全&amp;语法检查</p>
<ul>
<li>pip安装flake8,在配置文件配置一下就可以使用.</li>
</ul>
</li>
<li><p>代码格式化</p>
<ul>
<li>pip安装yapf,在配置文件配置一下就可以使用.</li>
</ul>
</li>
<li><p>编译&amp;运行</p>
<ul>
<li>vscode官方python插件</li>
</ul>
</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li><p>当然是<code>python3</code>了.不否认python2还在很多库中使用,但是面向未来,学习还是以最新为主.</p>
</li>
<li><p>windows / Linux 下 python3 和 vscode 安装不需多言.</p>
</li>
</ul>
<h2 id="python插件"><a href="#python插件" class="headerlink" title="python插件"></a>python插件</h2><ul>
<li><p>打开VScode，Ctrl+p</p>
</li>
<li><p>输入 “ext install python”，搜索时间可能会比较长</p>
</li>
<li><p>下载微软<code>Microsoft</code>出品的<code>Python</code>,全局翻墙最佳,要不然外网服务器,你懂的</p>
</li>
<li><p>重新加载后,直接F5即可运行.</p>
</li>
</ul>
<h2 id="flake8"><a href="#flake8" class="headerlink" title="flake8"></a>flake8</h2><ul>
<li><p>命令行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install flake8</div></pre></td></tr></table></figure>
</li>
<li><p>文件-&gt;首选项-&gt;用户设置，在settings.json文件中输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"python.linting.flake8Enabled"</span>: <span class="literal">true</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="yapf"><a href="#yapf" class="headerlink" title="yapf"></a>yapf</h2><ul>
<li><p>命令行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install yapf</div></pre></td></tr></table></figure>
</li>
<li><p>文件-&gt;首选项-&gt;用户设置，在settings.json文件中输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"python.formatting.provider"</span>: <span class="string">"yapf"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul>
<li>没了,vscode对前端和高级语言支持真的很好.基本上手即用.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vscode 1.20.x&lt;/li&gt;
&lt;li&gt;ubuntu&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;备注:&lt;br&gt;  转载自&lt;a href=&quot;https://www.cnblogs.com/bloglkl/archive/
    
    </summary>
    
      <category term="linux笔记" scheme="http://yoursite.com/categories/linux%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Android随手记—AndroidStudio启动0xc0000005</title>
    <link href="http://yoursite.com/2018/05/05/Android%E9%9A%8F%E6%89%8B%E8%AE%B0-AndroidStudio%E5%90%AF%E5%8A%A80xc0000005/"/>
    <id>http://yoursite.com/2018/05/05/Android随手记-AndroidStudio启动0xc0000005/</id>
    <published>2018-05-05T04:00:00.000Z</published>
    <updated>2018-05-05T08:21:37.904Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>编程环境</p>
<ul>
<li>Android Studio 3.1.2</li>
</ul>
<hr>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li>升级win10 到了4月份更新1803,启动AS给我来了个 0xc0000005</li>
</ul>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ul>
<li>一切正常升级,除了自己手贱把 Windows Defender 升级到1803 额外的安全全部打开..</li>
</ul>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ul>
<li><p>万能的stackoverflow 给了答案.问题就在于 Windows Defender 下的 ALSR 好像是内存随机化..(具体意义不太明确)</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/47500401/android-studio-cannot-be-initialized-0xc0000005" target="_blank" rel="external">https://stackoverflow.com/questions/47500401/android-studio-cannot-be-initialized-0xc0000005</a></p>
</blockquote>
</li>
<li><p>翻译成中文:</p>
<ul>
<li>Windows Defender -&gt; 应用与程序控制 -&gt;Exploit Protection -&gt;程序设置 -&gt;添加程序自定义</li>
<li>找到android stuido安装目录下的 /bin/studio64.exe <strong>一定要完整目录</strong>.编辑</li>
<li>找到两个ASLR相关项.强制化ASLR 和 自下而上ASLR ,替换系统设置,关掉.重启AS.</li>
</ul>
</li>
</ul>
<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><ul>
<li>win10高级选项 别乱动…</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;编程环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android Studio 3.1.2&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;升
    
    </summary>
    
      <category term="Android随手记" scheme="http://yoursite.com/categories/Android%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
    
      <category term="Android Studio" scheme="http://yoursite.com/tags/Android-Studio/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>python—生成测试文件</title>
    <link href="http://yoursite.com/2018/04/29/python%E2%80%94%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/04/29/python—生成测试文件/</id>
    <published>2018-04-29T02:17:11.000Z</published>
    <updated>2018-04-30T16:35:31.285Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>需要一些原始数据,简单记录</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> string</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWhitList_Size</span><span class="params">(ListSize)</span>:</span></div><div class="line">    numCount=ListSize</div><div class="line"></div><div class="line">    i=<span class="number">0</span></div><div class="line">    filePath=<span class="string">"List.txt"</span></div><div class="line">    <span class="keyword">with</span> open(filePath, <span class="string">"w"</span>, encoding=<span class="string">"GBK"</span>) <span class="keyword">as</span> f:</div><div class="line">    <span class="keyword">while</span> i&lt;numCount:</div><div class="line">        f.write(<span class="string">''</span>.join(random.choices(string.ascii_uppercase + string.digits, k=<span class="number">6</span>)))</div><div class="line">        f.write(<span class="string">"\n"</span>)</div><div class="line">        i=i+<span class="number">1</span></div><div class="line"></div><div class="line">getWhitList_Size(<span class="number">50000</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>python文件操作:</p>
<ul>
<li>其他语言也大同小异.</li>
<li>open write close</li>
</ul>
</li>
<li><p>核心是 随机生成字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">''</span>.join(random.choices(string.ascii_uppercase + string.digits, k=<span class="number">6</span>))</div></pre></td></tr></table></figure>
<p><code>random.choices(population, weights=None, *, cum_weights=None, k=1)</code><br>从population集群中随机抽取K个元素 weights是相对权重列表 cum_weights是累计权重 两个参数不能同时存在.<br>(注:random.choices是python3.6后新增方法)</p>
<ul>
<li><code>string.ascii_uppercase + string.digits</code> 是string包下代表大写字母和字符串的集合.</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要一些原始数据,简单记录&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
      <category term="python笔记" scheme="http://yoursite.com/categories/python%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>linux笔记—共享内存</title>
    <link href="http://yoursite.com/2018/04/19/linux%E7%AC%94%E8%AE%B0%E2%80%94%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2018/04/19/linux笔记—共享内存/</id>
    <published>2018-04-19T02:17:11.000Z</published>
    <updated>2018-04-30T16:33:39.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><ul>
<li>即多进程之间直接对读写同一段内存.相比较管道及消息队列,显而易见的好处是速度快,所有的IPC方法中效率最高.但共享内存并未提供同步机制,需要自行实现.</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li><p>顾名思义，共享内存就是说两个不同的进程A、B可以共同享有一块内存区域<br><img src="https://i.loli.net/2018/04/27/5ae2e1a5719a2.png" alt="20150124140604078.png"></p>
</li>
<li><p>整个处理流程是</p>
<ul>
<li>进程A第一次访问该页中的数据时, 生成一个缺页中断. 内核读入此页到内存并更新页表使之指向此页.</li>
<li>进程B访问同一页面而出现缺页中断,内核只将进程B的页表登记项指向次页即可.</li>
<li>进程A.B 即可访问同一段内存.</li>
</ul>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><p>shmget函数<br>shmget被用来开辟/初始化一段共享内存.其他进程使用相同的key 通过 shgat 获取同一段共享内存.，只有shmget函数才直接使用信号量键,所有其他的信号量函数使用由semget函数返回的信号量标识符.</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</div></pre></td></tr></table></figure>
<p>key : 与信号量的semget函数一样，使用共享内存key（非0整数）shmget函数成功时返回一个与key相关的共享内存标识符(非负整数),用于多进程的共享.调用失败返回-1.<br>size : 开辟的共享内存大小(字节).<br>shmflg : 权限控制,与IPC_CREAT做或操作,控制其他进程对共享内存权限. 0644即代表其他进程只有读的权限.</p>
</li>
<li><p>shmat函数<br>用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg)</span></span>;</div></pre></td></tr></table></figure>
<p>shm_id: 由shmget函数返回的共享内存标识.<br>shm_addr: 指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址.<br>shm_flg: 标志位，通常为0.</p>
</li>
<li><p>shmdt函数<br>将共享内存从当前进程中分离,使该共享内存对当前进程不再可用.</p>
<p>函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</div></pre></td></tr></table></figure>
<p>shmaddr: shmat函数返回的地址指针，调用成功时返回0，失败时返回-1.</p>
</li>
<li><p>shmctl函数<br>控制共享内存.</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span></div></pre></td></tr></table></figure>
<p>shm_id: shmget函数返回的共享内存标识符</p>
<p>command: 要采取的操作,以下三个值 ：</p>
<ul>
<li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值.</li>
<li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值</li>
<li>IPC_RMID：删除共享内存段</li>
</ul>
<p>buf: 结构指针,指向共享内存模式和访问权限的结构.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">shmid_ds结构至少包括以下成员：</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">uid_t</span> shm_perm.uid;</div><div class="line">    <span class="keyword">uid_t</span> shm_perm.gid;</div><div class="line">    <span class="keyword">mode_t</span> shm_perm.mode;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="系统限制及规避"><a href="#系统限制及规避" class="headerlink" title="系统限制及规避"></a>系统限制及规避</h2><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><ul>
<li>linux默认限制共享内存总大小由 SHMMAX 值确定.默认值未32MB</li>
<li><p>读取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/kernel/shmmax</div></pre></td></tr></table></figure>
</li>
<li><p>当超过系统限制时 提示 <code>unable to attach to shared memory</code>.</p>
</li>
<li><p>规避</p>
<ul>
<li><p>直接修改/proc.无需重启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"2147483648"</span> &amp;gt; /proc/sys/kernel/shmmax</div></pre></td></tr></table></figure>
<p>可以将命令写入启动脚本 /etc/rc.local中.保证重启生效</p>
</li>
<li><p>使用 sysctl 命令修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -w kernel.shmmax=2147483648</div></pre></td></tr></table></figure>
<p>可以将此参数插入到 /etc/sysctl.conf 启动文件中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"kernel.shmmax=2147483648"</span> &amp;gt;&amp;gt; /etc/sysctl.conf</div></pre></td></tr></table></figure>
<p>永久生效.</p>
</li>
</ul>
</li>
</ul>
<h3 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h3><ul>
<li>与大小类似的,共享内存创建的总数量由 SHMMNI 参数确定.</li>
<li><p>读取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/kernel/shmmni</div></pre></td></tr></table></figure>
<p>默认情况下是 4096.</p>
</li>
<li><p>一般不需要修改.</p>
</li>
</ul>
<h3 id="同一进程多次shmat"><a href="#同一进程多次shmat" class="headerlink" title="同一进程多次shmat"></a>同一进程多次shmat</h3><ul>
<li>shmat即挂载共享内存到进程的进程空间.</li>
<li><p>当同一进程多次调用shmat 挂载同一共享内存时,shamat每次返回的地址都不同,相当于在进程的线性空间中存在多个实际指向同一块共享内存.直到最后进程线性空间消耗殆尽.</p>
</li>
<li><p>解决:<br>需要在挂载共享内存前,判断申请的共享内存指针是否为空,为 NULL ,则第一次加载此共享内存.否则不再重复加载.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* p = <span class="literal">NULL</span>;</div><div class="line"><span class="comment">/*其他操作*/</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == p)</div><div class="line">&#123;</div><div class="line">   p = shmat(shmid,p,<span class="number">0666</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多个进程相同key多次创建共享内存"><a href="#多个进程相同key多次创建共享内存" class="headerlink" title="多个进程相同key多次创建共享内存"></a>多个进程相同key多次创建共享内存</h3><ul>
<li><p>共享内存创建有大小之分.key相同情况下,容量小的共享内存会获得之前创建的大的共享内存的内容.有可能导致之前创建共享内存的进程崩溃.</p>
</li>
<li><p>解决</p>
<ul>
<li><p>在shmage使用IPC_EXCL标记.现行判断共享内存是否已创建.如果已创建则挂载,没有创建返回失败后,再创建.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Shmid = Shmget(key, size,IPC_CREATE|IPC_EXCL); </div><div class="line"><span class="keyword">if</span> (<span class="number">-1</span> != shmid) </div><div class="line">&#123;</div><div class="line">  <span class="comment">/*错误处理*/</span></div><div class="line">  Shmid = Shmget(key, size,IPC_CREATE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>不通过key 标记同一块共享内存.<br>shmget使用 kry = IPC_PRIVATE ,linux会忽略key值,直接新建一块共享内存.返回标识,通过管道/文件方式共享给其他进程使用.</p>
</li>
</ul>
</li>
</ul>
<h3 id="共享内存删除"><a href="#共享内存删除" class="headerlink" title="共享内存删除"></a>共享内存删除</h3><ul>
<li>调用shmctl 删除共享内存后,共享内存并不会立刻被系统清理.</li>
<li><p>首先共享内存的 shmid_ds结构中的 shm_nattch 减一.该共享内存从调用shmctl的进程剥离.但 shm_nattch 不为 0 的情况下,即仍然有别进程连接的情况下.共享内存并不会立刻清除. 只有在 shm_nattch 为 0 ,没有任何进程连接的情况下,系统才会清理 这段共享内存.</p>
</li>
<li><p>该段共享内存被任何连接的进程执行 shmctl 删除操作后, 新的进程将无法连接到该段共享内存. </p>
</li>
<li>与之对应的 Shmdt ,只是将共享内存由 调用的进程空间剥离.不会影响其他进程连接到该段共享内存.</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>多进程共享数据.以链表为例.</li>
<li><p>有两种方式:</p>
<ul>
<li>开辟一段共享内存,之后存入整个链表.将共享内存连接到各个进程.<ul>
<li>优点:<ul>
<li>对原有代码改动少.</li>
</ul>
</li>
<li>缺点:<ul>
<li>封装链表操作时,各个进程头节点偏移量不同,不能简单的通过 <code>*p-&gt;next</code> 访问.</li>
<li>有共享内存大小限制.</li>
</ul>
</li>
</ul>
</li>
<li>每一个链表节点对应一个共享内存.开辟同等数量的共享内存.<ul>
<li>优点<ul>
<li>可以随用随创,相对节省内存.</li>
<li>链表节点next 存储相对链表头节点偏移即可,访问操作相对单一共享内存容易.</li>
</ul>
</li>
<li>缺点<ul>
<li>受限于 linux 默认 4096的总数量限制.且总数不易更改.</li>
<li>开辟新链表节点相对复杂.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>实际使用中第一种较为常见.</p>
</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ul>
<li>与共享内存类似的信号量,也是跨进程的.信号量是比较一种比较方便配合共享内存同步的方式.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;共享内存&quot;&gt;&lt;a href=&quot;#共享内存&quot; class=&quot;headerlink&quot; title=&quot;共享内存&quot;&gt;&lt;/a&gt;共享内存&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;即多进程之间直接对读写同一段内存.相比较管道及消息队列,显而易见的好处是速度快,所有的IPC方法中效率最高.但共
    
    </summary>
    
      <category term="linux笔记" scheme="http://yoursite.com/categories/linux%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Android随手记—Rxjava2</title>
    <link href="http://yoursite.com/2018/04/14/Android%E9%9A%8F%E6%89%8B%E8%AE%B0-Rxjava2/"/>
    <id>http://yoursite.com/2018/04/14/Android随手记-Rxjava2/</id>
    <published>2018-04-14T04:00:00.000Z</published>
    <updated>2018-04-30T16:35:48.917Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>编程环境<ul>
<li>Android Studio 3.2</li>
</ul>
</li>
</ul>
<hr>
<h2 id="解除订阅"><a href="#解除订阅" class="headerlink" title="解除订阅"></a>解除订阅</h2><ul>
<li>CompositeDisposable:<ul>
<li>得到一个Disposable实例时</li>
<li>调用CompositeDisposable.add()添加到订阅</li>
<li>生命周期结束 CompositeDisposable.clear() 可快速解除.</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;编程环境&lt;ul&gt;
&lt;li&gt;Android Studio 3.2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android随手记" scheme="http://yoursite.com/categories/Android%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
    
      <category term="Android Studio" scheme="http://yoursite.com/tags/Android-Studio/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题汇总—Android</title>
    <link href="http://yoursite.com/2018/04/07/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB-Android/"/>
    <id>http://yoursite.com/2018/04/07/面试汇总-Android/</id>
    <published>2018-04-07T04:00:00.000Z</published>
    <updated>2018-04-06T06:42:46.897Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>资料来源如下</p>
<blockquote>
<p><a href="https://github.com/AweiLoveAndroid/CommonDevKnowledge" target="_blank" rel="external">常用的Android开发的一些技能点以及BAT公司面试题汇集</a></p>
</blockquote>
<ul>
<li><p>感觉自己白学了////😂////</p>
</li>
<li><p>一道一道的找答案..</p>
</li>
</ul>
<hr>
<h1 id="Android面试题"><a href="#Android面试题" class="headerlink" title="Android面试题"></a>Android面试题</h1><p>Android面试题除了Android基础之外，更多的问的是一些源码级别的、原理这些等。所以想去大公司面试，一定要多看看源码和实现方式，常用框架可以试试自己能不能手写实现一下，锻炼一下自己。</p>
<h3 id="一、Android基础知识点"><a href="#一、Android基础知识点" class="headerlink" title="一、Android基础知识点"></a>一、Android基础知识点</h3><ul>
<li>四大组件是什么</li>
<li>四大组件的生命周期和简单用法</li>
<li>Activity之间的通信方式</li>
<li>Activity各种情况下的生命周期</li>
<li>横竖屏切换的时候，Activity 各种情况下的生命周期</li>
<li>Activity与Fragment之间生命周期比较</li>
<li>Activity上有Dialog的时候按Home键时的生命周期</li>
<li>两个Activity 之间跳转时必然会执行的是哪几个方法？</li>
<li>前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。</li>
<li>Activity的四种启动模式对比</li>
<li>Activity状态保存于恢复</li>
<li>fragment各种情况下的生命周期</li>
<li>Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？</li>
<li>如何实现Fragment的滑动？</li>
<li>fragment之间传递数据的方式？</li>
<li>Activity 怎么和Service 绑定？</li>
<li>怎么在Activity 中启动自己对应的Service？</li>
<li>service和activity怎么进行数据交互？</li>
<li>Service的开启方式</li>
<li>请描述一下Service 的生命周期</li>
<li>谈谈你对ContentProvider的理解</li>
<li>说说ContentProvider、ContentResolver、ContentObserver 之间的关系</li>
<li>请描述一下广播BroadcastReceiver的理解</li>
<li>广播的分类</li>
<li>广播使用的方式和场景</li>
<li>在manifest 和代码中如何注册和使用BroadcastReceiver?</li>
<li>本地广播和全局广播有什么差别？</li>
<li>BroadcastReceiver，LocalBroadcastReceiver 区别</li>
<li>AlertDialog,popupWindow,Activity区别</li>
<li>Application 和 Activity 的 Context 对象的区别</li>
<li>Android属性动画特性</li>
<li>如何导入外部数据库?</li>
<li>LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。</li>
<li>谈谈对接口与回调的理解</li>
<li>回调的原理</li>
<li>写一个回调demo</li>
<li>介绍下SurfView</li>
<li>RecycleView的使用</li>
<li>序列化的作用，以及Android两种序列化的区别</li>
<li>差值器</li>
<li>估值器</li>
<li>Android中数据存储方式</li>
</ul>
<h3 id="二、Android源码相关分析"><a href="#二、Android源码相关分析" class="headerlink" title="二、Android源码相关分析"></a>二、Android源码相关分析</h3><ul>
<li>Android动画框架实现原理</li>
<li>Android各个版本API的区别</li>
<li>Requestlayout，onlayout，onDraw，DrawChild区别与联系</li>
<li>invalidate和postInvalidate的区别及使用</li>
<li>Activity-Window-View三者的差别</li>
<li>谈谈对Volley的理解</li>
<li>如何优化自定义View</li>
<li>低版本SDK如何实现高版本api？</li>
<li>描述一次网络请求的流程</li>
<li>HttpUrlConnection 和 okhttp关系</li>
<li>Bitmap对象的理解</li>
<li>looper架构</li>
<li>ActivityThread，AMS，WMS的工作原理</li>
<li>自定义View如何考虑机型适配</li>
<li>自定义View的事件</li>
<li>AstncTask+HttpClient 与 AsyncHttpClient有什么区别？</li>
<li>LaunchMode应用场景</li>
<li>AsyncTask 如何使用?</li>
<li>SpareArray原理</li>
<li>请介绍下ContentProvider 是如何实现数据共享的？</li>
<li>AndroidService与Activity之间通信的几种方式</li>
<li>IntentService原理及作用是什么？</li>
<li>说说Activity、Intent、Service 是什么关系</li>
<li>ApplicationContext和ActivityContext的区别</li>
<li>SP是进程同步的吗?有什么方法做到同步？</li>
<li>谈谈多线程在Android中的使用</li>
<li>进程和 Application 的生命周期</li>
<li>封装View的时候怎么知道view的大小</li>
<li>RecycleView原理</li>
<li>AndroidManifest的作用与理解</li>
</ul>
<h3 id="三、常见的一些原理性问题"><a href="#三、常见的一些原理性问题" class="headerlink" title="三、常见的一些原理性问题"></a>三、常见的一些原理性问题</h3><ul>
<li>Handler机制和底层实现</li>
<li>Handler、Thread和HandlerThread的差别</li>
<li>handler发消息给子线程，looper怎么启动？</li>
<li>关于Handler，在任何地方new Handler 都是什么线程下?</li>
<li>ThreadLocal原理，实现及如何保证Local属性？</li>
<li>请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系</li>
<li>请描述一下View事件传递分发机制</li>
<li>Touch事件传递流程</li>
<li>事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？</li>
<li>View和ViewGroup分别有哪些事件分发相关的回调方法</li>
<li>View刷新机制</li>
<li>View绘制流程</li>
<li>自定义控件原理</li>
<li>自定义View如何提供获取View属性的接口？</li>
<li>Android代码中实现WAP方式联网</li>
<li>AsyncTask机制</li>
<li>AsyncTask原理及不足</li>
<li>如何取消AsyncTask？</li>
<li>为什么不能在子线程更新UI？</li>
<li>ANR产生的原因是什么？</li>
<li>ANR定位和修正</li>
<li>oom是什么？</li>
<li>什么情况导致oom？</li>
<li>有什么解决方法可以避免OOM？</li>
<li>Oom 是否可以try catch？为什么？</li>
<li>内存泄漏是什么？</li>
<li>什么情况导致内存泄漏？</li>
<li>如何防止线程的内存泄漏？</li>
<li>内存泄露场的解决方法</li>
<li>内存泄漏和内存溢出区别？</li>
<li>LruCache默认缓存大小</li>
<li>ContentProvider的权限管理(解答：读写分离，权限控制-精确到表级，URL控制)</li>
<li>如何通过广播拦截和abort一条短信？</li>
<li>广播是否可以请求网络？</li>
<li>广播引起anr的时间限制是多少？</li>
<li>计算一个view的嵌套层级</li>
<li>Activity栈</li>
<li>Android线程有没有上限？</li>
<li>线程池有没有上限？</li>
<li>ListView重用的是什么？</li>
<li>Android为什么引入Parcelable？</li>
<li>有没有尝试简化Parcelable的使用？</li>
</ul>
<h3 id="四、开发中常见的一些问题"><a href="#四、开发中常见的一些问题" class="headerlink" title="四、开发中常见的一些问题"></a>四、开发中常见的一些问题</h3><ul>
<li>ListView 中图片错位的问题是如何产生的?</li>
<li>混合开发有了解吗？</li>
<li>知道哪些混合开发的方式？说出它们的优缺点和各自使用场景？（解答：比如:RN，weex，H5，小程序，WPA等。做Android的了解一些前端js等还是很有好处的)；</li>
<li>屏幕适配的处理技巧都有哪些?</li>
<li>服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？</li>
<li>动态布局的理解</li>
<li>怎么去除重复代码？</li>
<li>画出 Android 的大体架构图</li>
<li>Recycleview和ListView的区别</li>
<li>ListView图片加载错乱的原理和解决方案</li>
<li>动态权限适配方案，权限组的概念</li>
<li>Android系统为什么会设计ContentProvider？</li>
<li>下拉状态栏是不是影响activity的生命周期</li>
<li>如果在onStop的时候做了网络请求，onResume的时候怎么恢复？</li>
<li>Bitmap 使用时候注意什么？</li>
<li>Bitmap的recycler()</li>
<li>Android中开启摄像头的主要步骤</li>
<li>ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化？</li>
<li>点击事件被拦截，但是想传到下面的View，如何操作？</li>
<li>微信主页面的实现方式</li>
<li>微信上消息小红点的原理</li>
<li>CAS介绍（这是阿里巴巴的面试题，我不是很了解，可以参考博客: <a href="http://blog.csdn.net/jly4758/article/details/46673835" target="_blank" rel="external">CAS简介</a>）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;资料来源如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/AweiLoveAndroid/CommonDevKnowledge&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;常用的Android
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Vscode系列—c语言</title>
    <link href="http://yoursite.com/2018/03/24/Vscode%E7%B3%BB%E5%88%97-c%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2018/03/24/Vscode系列-c语言/</id>
    <published>2018-03-24T04:00:00.000Z</published>
    <updated>2018-03-23T18:12:36.802Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>环境</p>
<ul>
<li>vscode 1.20.x</li>
<li>ubuntu</li>
</ul>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>写嵌入式的c语言太难搞了,受够了盗版 sourceinsight 艰难的代码提示和补全之后,尝试换一款编辑器.</li>
<li>跨平台,支持多种语言,自由度高.</li>
<li>vim 和 Emacs 命令行 有一点学习成本.</li>
<li>最后选定了 vscode 业余写点 python 和 java 写写 markdown 博客等等 (看pdf也行…).</li>
</ul>
<hr>
<ul>
<li>注意vscode首先是个编辑器,其他的功能都是通过 插件 + 后端 实现的.</li>
</ul>
<hr>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ul>
<li>代码补全 最重要的<strong>c语言的结构体补全!!!</strong>.<ul>
<li>结构体补全曾经深深折磨这我,直到遇到了clang….</li>
<li>顺带着解决了语法检查,clang的语法检查很是好用.</li>
<li>插件: C/C++ Clang Command Adapter</li>
<li><img src="https://i.loli.net/2018/03/23/5ab4f9c678732.png" alt="auto.png"></li>
<li><img src="https://i.loli.net/2018/03/23/5ab4f9c6ec147.png" alt="autoa.png"></li>
</ul>
</li>
<li>语法检查<ul>
<li>常规clang足矣,但还不够.</li>
<li>clang是编译器,但有些错误编译器还是无能为力,祭出Cppcheck,C/C++代码缺陷静态检查工具.</li>
<li>插件: cppcheck</li>
<li><img src="https://i.loli.net/2018/03/23/5ab4f9c64e3af.png" alt="err.png"></li>
</ul>
</li>
<li>代码格式化<ul>
<li>眼瞅着clang 配套的clang-format .</li>
<li>插件: Clang-Format</li>
</ul>
</li>
<li>函数跳转<ul>
<li>微软官方c/c++插件就行了,但官方插件自带代码补全和语法检查,不怎么好,一定要关掉否则会与clang冲突.</li>
<li>插件: C/C++ for Visual Studio Code</li>
<li><img src="https://i.loli.net/2018/03/23/5ab4f9c702d2c.png" alt="jump.png"></li>
</ul>
</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li><p>上文书说到,vscode实现编辑器以外的功能都需要插件+后端的形式 so 一般的安装步骤如下:</p>
</li>
<li><p>安装后端,如clang 、cppcheck 等.</p>
</li>
<li>安装对应插件</li>
<li><p>修改配置文件(json格式)</p>
</li>
<li><p>最后针对处理头文件等.</p>
</li>
</ul>
<h2 id="代码补全-语法检查"><a href="#代码补全-语法检查" class="headerlink" title="代码补全/语法检查"></a>代码补全/语法检查</h2><ul>
<li>代码补全/语法检查都依赖于后端clang,而ubunt自带的clang 3.8版本,而clang最新的稳定版本为5.0,这里选择5.0版本.</li>
<li>参考 &gt; <a href="https://apt.llvm.org/" target="_blank" rel="external">https://apt.llvm.org/</a></li>
</ul>
<h3 id="安装clang-5-0"><a href="#安装clang-5-0" class="headerlink" title="安装clang-5.0"></a>安装clang-5.0</h3><ul>
<li><p>修改ubuntu源 /etc/apt/source.list 添加llvm官方源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">deb http://apt.llvm.org/trusty/ llvm-toolchain-trusty-5.0 main</div><div class="line">deb-src http://apt.llvm.org/trusty/ llvm-toolchain-trusty-5.0 main</div></pre></td></tr></table></figure>
</li>
<li><p>添加llvm源的 密钥</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add -</div></pre></td></tr></table></figure>
</li>
<li><p>更新软件列表,这样就可以安装5.0版本了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div></pre></td></tr></table></figure>
</li>
<li><p>安装clang5.0</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install clang-5.0 lldb-5.0</div></pre></td></tr></table></figure>
<p>或者安装全部llvm root用户下(太多偷个懒)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install clang-5.0 clang-tools-5.0 clang-5.0-doc libclang-common-5.0-dev libclang-5.0-dev libclang1-5.0 libclang1-5.0-dbg libllvm-5.0-ocaml-dev libllvm5.0 libllvm5.0-dbg lldb-5.0 llvm-5.0 llvm-5.0-dev llvm-5.0-doc llvm-5.0-examples llvm-5.0-runtime clang-format-5.0 python-clang-5.0 libfuzzer-5.0-dev</div></pre></td></tr></table></figure>
</li>
<li><p>完整安装需要良好的网络,llvm大概300M,等下就好.</p>
</li>
<li><p>验证</p>
<ul>
<li>命令行输入 clang-5.0 不会提示无此命令即可.</li>
</ul>
</li>
</ul>
<h3 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h3><ul>
<li><p>ubuntu自带版本3.8</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install clang</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="clang插件及配置"><a href="#clang插件及配置" class="headerlink" title="clang插件及配置"></a>clang插件及配置</h3><ul>
<li><p>插件名 C/C++ Clang Command Adapter,在vscode中搜索下载即可.<br>网络环境限制还可以在vscode官网下载vsix格式的文件,离线安装.</p>
</li>
<li><p>安装完成后,进入重头戏,也是初次上手vscode最难适应的地方.</p>
</li>
<li><p>进入vscode的设置 <code>setting.json</code> ,分为 用户区设置 和 工作区设置.</p>
<ul>
<li>用户区设置,是用户自定义全局设置,覆盖vscode默认设置,每个工程都有效.</li>
<li>工作区设置,是针对本工程的个性化设置,只在本工程生效.</li>
<li>简易是将clang等设置 保存在用户区,工作区保存追对 clang 的头文件设置.</li>
</ul>
</li>
<li><p>用户区设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">"clang.executable": "clang-5.0",</div><div class="line">"clang.completion.triggerChars": [</div><div class="line">      ".",</div><div class="line">      ":",</div><div class="line">      "&gt;"],</div></pre></td></tr></table></figure>
<ul>
<li>clang.executable : 后端clang的路径,这里是 clang-5.0 ,也可以写入 clang 的安装目录.</li>
<li>clang.completion.triggerChars : 触发代码补全的输入,常用的 . : &gt;.</li>
</ul>
</li>
<li><p>工作区设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">"clang.cflags": [</div><div class="line">      "-std=c99",</div><div class="line">      "-I$&#123;cwd&#125;",</div><div class="line">      "-I/usr/include",</div><div class="line">      "-I/usr/include/c++/5",</div><div class="line">      "-I/usr/include/x86_64-linux-gnu/c++/5",</div><div class="line">      "-I/usr/include/c++/5/backward",</div><div class="line">      "-I/usr/lib/gcc/x86_64-linux-gnu/5/include",</div><div class="line">      "-I/usr/local/include",</div><div class="line">      "-I/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed",</div><div class="line">      "-I/usr/include/x86_64-linux-gnu",</div><div class="line">      "-I/usr/include",</div><div class="line">      "-I$&#123;workspaceRoot&#125;",</div><div class="line">      "-I$&#123;workspaceRoot&#125;/Include",</div><div class="line">      "-I$&#123;workspaceRoot&#125;/Libs/Cjson/Include"</div><div class="line">  ],</div></pre></td></tr></table></figure>
<ul>
<li>clang.cflags : <code>&quot;-std=c99&quot;</code> clang语法检查时 c/c++ 语言标准,要兼容历史项目,这就选的 c99 ,新项目简易 直接 c11.clang进行代码补全/语法检查的头文件路径, 格式是 <code>-I路径</code> ,支持直接和间接路径(${workspaceRoot}).</li>
<li>头文件一定要写全,否则一直会有错误提示.</li>
</ul>
</li>
<li><p>保存后,代码补全/语法检查 全部如上图所示.</p>
</li>
</ul>
<h2 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h2><ul>
<li>这里特指 cppcheck</li>
</ul>
<h3 id="安装cppcheck"><a href="#安装cppcheck" class="headerlink" title="安装cppcheck"></a>安装cppcheck</h3><ul>
<li><p>我没有追求最新,直接通过ubuntu官方源安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install cppcheck</div></pre></td></tr></table></figure>
</li>
<li><p>安装完成,执行 cppcheck 命令,不提示无此命令即可.</p>
</li>
</ul>
<h3 id="cppcheck插件及配置"><a href="#cppcheck插件及配置" class="headerlink" title="cppcheck插件及配置"></a>cppcheck插件及配置</h3><ul>
<li><p>搜索安装 cppcheck</p>
</li>
<li><p>同样配置分为用户区和工作区.工作区对应头文件设置.</p>
</li>
<li><p>用户区</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">"cppcheck.cppcheckPath": null,</div><div class="line">"cppcheck.standard": [</div><div class="line">      "c99",</div><div class="line">  ],</div><div class="line">"cppcheck.language": "c",</div></pre></td></tr></table></figure>
<ul>
<li>cppcheck.cppcheckPath : null时,会使用 cppcheck 命令指向的版本,也可以使用自定义路径.</li>
<li>cppcheck.standard : cppcheck 检查时 c/c++版本,历史原因我这里还是 c99.</li>
<li>cppcheck.language : 前置检查时 以 c 或者 c++ 检查.我这里都是 c 项目,填写 c .</li>
</ul>
</li>
<li><p>工作区</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">"cppcheck.includePaths": [</div><div class="line">  "$&#123;cwd&#125;",</div><div class="line">  "/usr/include",</div><div class="line">  "/usr/include/c++/5",</div><div class="line">  "/usr/include/x86_64-linux-gnu/c++/5",</div><div class="line">  "/usr/include/c++/5/backward",</div><div class="line">  "/usr/lib/gcc/x86_64-linux-gnu/5/include",</div><div class="line">  "/usr/local/include",</div><div class="line">  "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed",</div><div class="line">  "/usr/include/x86_64-linux-gnu",</div><div class="line">  "/usr/include",</div><div class="line">  "$&#123;workspaceRoot&#125;",</div><div class="line">  "$&#123;workspaceRoot&#125;/Include",</div><div class="line">  "$&#123;workspaceRoot&#125;/Code/APP/Code/Libs/Cjson/Include"</div><div class="line">],</div><div class="line">"cppcheck.force": true</div></pre></td></tr></table></figure>
<ul>
<li>cppcheck.includePaths : 头文件路径,这里没有 <code>-I</code> ,直接输入路径即可.支持直接和间接路径.</li>
<li>cppcheck.force : 强制检查所有枚举所有可能配置,有多个项目同时在工作,这里我放到工作区了,如果代码量小的工程建议放在用户区,作为全局配置.</li>
</ul>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>左下角,点击cppcheck 如图<br><img src="https://i.loli.net/2018/03/23/5ab4f7f51181a.png" alt="cppcheck.png"></p>
</li>
<li><p>3个选择</p>
<ul>
<li>分析当前打开文件</li>
<li>分析工作区所有文件</li>
<li>其他…没用过..</li>
</ul>
</li>
</ul>
<h2 id="函数跳转"><a href="#函数跳转" class="headerlink" title="函数跳转"></a>函数跳转</h2><ul>
<li>直接使用微软的 C/C++ for Visual Studio Code 即可.</li>
<li>官方的很强大,带代码补全和语法检查,,可惜表现不太好.函数跳转很好用.</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li><p>搜索安装 C/C++ for Visual Studio Code</p>
</li>
<li><p>不用安装后端了,对应的配置就稍微麻烦了.</p>
</li>
<li><p>在项目根目录下 查找 .vscode文件夹,进入.应该由 setting.json文件,对应工作区设置.</p>
</li>
<li><p>新建c_cpp_properties.json ,写入以下内容.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"configurations"</span>: [</div><div class="line">      &#123;</div><div class="line">          <span class="attr">"name"</span>: <span class="string">"Mac"</span>,</div><div class="line">          <span class="attr">"includePath"</span>: [</div><div class="line">              <span class="string">"/usr/include"</span>,</div><div class="line">              <span class="string">"/usr/local/include"</span>,</div><div class="line">              <span class="string">"$&#123;workspaceRoot&#125;"</span></div><div class="line">          ],</div><div class="line">          <span class="attr">"defines"</span>: [],</div><div class="line">          <span class="attr">"intelliSenseMode"</span>: <span class="string">"clang-x64"</span>,</div><div class="line">          <span class="attr">"browse"</span>: &#123;</div><div class="line">              <span class="attr">"path"</span>: [</div><div class="line">                  <span class="string">"/usr/include"</span>,</div><div class="line">                  <span class="string">"/usr/local/include"</span>,</div><div class="line">                  <span class="string">"$&#123;workspaceRoot&#125;"</span></div><div class="line">              ],</div><div class="line">              <span class="attr">"limitSymbolsToIncludedHeaders"</span>: <span class="literal">true</span>,</div><div class="line">              <span class="attr">"databaseFilename"</span>: <span class="string">""</span></div><div class="line">          &#125;,</div><div class="line">          <span class="attr">"macFrameworkPath"</span>: [</div><div class="line">              <span class="string">"/System/Library/Frameworks"</span>,</div><div class="line">              <span class="string">"/Library/Frameworks"</span></div><div class="line">          ]</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">          <span class="attr">"name"</span>: <span class="string">"Linux"</span>,</div><div class="line">          <span class="attr">"includePath"</span>: [</div><div class="line">              <span class="string">"/usr/include/c++/5"</span>,</div><div class="line">              <span class="string">"/usr/include/x86_64-linux-gnu/c++/5"</span>,</div><div class="line">              <span class="string">"/usr/include/c++/5/backward"</span>,</div><div class="line">              <span class="string">"/usr/lib/gcc/x86_64-linux-gnu/5/include"</span>,</div><div class="line">              <span class="string">"/usr/local/include"</span>,</div><div class="line">              <span class="string">"/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed"</span>,</div><div class="line">              <span class="string">"/usr/include/x86_64-linux-gnu"</span>,</div><div class="line">              <span class="string">"/usr/include"</span>,</div><div class="line">              <span class="string">"$&#123;workspaceRoot&#125;"</span>,</div><div class="line">              <span class="string">"$&#123;workspaceRoot&#125;/Include"</span></div><div class="line">          ],</div><div class="line">          <span class="attr">"defines"</span>: [],</div><div class="line">          <span class="attr">"intelliSenseMode"</span>: <span class="string">"clang-x64"</span>,</div><div class="line">          <span class="attr">"browse"</span>: &#123;</div><div class="line">              <span class="attr">"path"</span>: [</div><div class="line">                  <span class="string">"/usr/include/c++/5"</span>,</div><div class="line">                  <span class="string">"/usr/include/x86_64-linux-gnu/c++/5"</span>,</div><div class="line">                  <span class="string">"/usr/include/c++/5/backward"</span>,</div><div class="line">                  <span class="string">"/usr/lib/gcc/x86_64-linux-gnu/5/include"</span>,</div><div class="line">                  <span class="string">"/usr/local/include"</span>,</div><div class="line">                  <span class="string">"/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed"</span>,</div><div class="line">                  <span class="string">"/usr/include/x86_64-linux-gnu"</span>,</div><div class="line">                  <span class="string">"/usr/include"</span>,</div><div class="line">                  <span class="string">"$&#123;workspaceRoot&#125;"</span>,</div><div class="line">                  <span class="string">"$&#123;workspaceRoot&#125;/Include"</span></div><div class="line">              ],</div><div class="line">              <span class="attr">"limitSymbolsToIncludedHeaders"</span>: <span class="literal">true</span>,</div><div class="line">              <span class="attr">"databaseFilename"</span>: <span class="string">""</span></div><div class="line">          &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">          <span class="attr">"name"</span>: <span class="string">"Win32"</span>,</div><div class="line">          <span class="attr">"includePath"</span>: [</div><div class="line">              <span class="string">"C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/include"</span>,</div><div class="line">              <span class="string">"$&#123;workspaceRoot&#125;"</span></div><div class="line">          ],</div><div class="line">          <span class="attr">"defines"</span>: [</div><div class="line">              <span class="string">"_DEBUG"</span>,</div><div class="line">              <span class="string">"UNICODE"</span>,</div><div class="line">              <span class="string">"_UNICODE"</span></div><div class="line">          ],</div><div class="line">          <span class="attr">"intelliSenseMode"</span>: <span class="string">"msvc-x64"</span>,</div><div class="line">          <span class="attr">"browse"</span>: &#123;</div><div class="line">              <span class="attr">"path"</span>: [</div><div class="line">                  <span class="string">"C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/include/*"</span>,</div><div class="line">                  <span class="string">"$&#123;workspaceRoot&#125;"</span></div><div class="line">              ],</div><div class="line">              <span class="attr">"limitSymbolsToIncludedHeaders"</span>: <span class="literal">true</span>,</div><div class="line">              <span class="attr">"databaseFilename"</span>: <span class="string">""</span></div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  ],</div><div class="line">  <span class="attr">"version"</span>: <span class="number">3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们只关注linux下的设置,将常用头文件路径添加到 <code>includePath</code> 和 <code>&quot;browse&quot;-&gt;&quot;path&quot;</code>下.<br><strong>可以不用手工添加</strong>,项目文件下,光标 指向提示找不到的 include 头文件 ,会有 💡 提示添加路径到path中,搞定!</p>
</li>
<li><p>至此代码跳转应该可以使用了.</p>
<ul>
<li>ctrl 悬浮提示,点击跳转.还有其他快捷键爽翻天.</li>
</ul>
</li>
</ul>
<h3 id="特别提醒"><a href="#特别提醒" class="headerlink" title="特别提醒"></a>特别提醒</h3><ul>
<li><p>上文提到 C/C++ for Visual Studio Code 会与 clang 的代码提示和语法检查冲突,所以一定要记得在用户区设置关闭自带.</p>
</li>
<li><p>用户区设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"C_Cpp.autocomplete": "Disabled",</div><div class="line">"C_Cpp.errorSquiggles": "Disabled",</div><div class="line">"C_Cpp.formatting": "Disabled",</div></pre></td></tr></table></figure>
<ul>
<li>关闭自动补全 错误提示 和 代码格式化.</li>
</ul>
</li>
</ul>
<h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h2><ul>
<li>使用clang-5.0 配套的 clang-format-5.0即可.</li>
<li>clang-format可以通过配置文件控制很多格式化细节,推荐使用.</li>
</ul>
<h3 id="安装clang-format"><a href="#安装clang-format" class="headerlink" title="安装clang-format"></a>安装clang-format</h3><ul>
<li><p>进行过 安装clang-5.0 后,执行如下命令即可.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install clang-format-5.0</div></pre></td></tr></table></figure>
</li>
<li><p>ubuntu官方源 为3.8版本,也可以安装使用.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install clang-format</div></pre></td></tr></table></figure>
</li>
<li><p>最好与clang版本保持一致.</p>
</li>
</ul>
<h3 id="clang-format配置"><a href="#clang-format配置" class="headerlink" title="clang-format配置"></a>clang-format配置</h3><ul>
<li><p>这里使用配置文件形式详细自定义格式化.(也可以直接使用自带的几种格式,同样够用)</p>
</li>
<li><p>用户区设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">"clang-format.assumeFilename": ".clang-format",</div><div class="line">"clang-format.executable": "clang-format-5.0",</div></pre></td></tr></table></figure>
<ul>
<li>clang-format.assumeFilename : 制定格式化的标准,这里是通过文件 .clang-format 来配置.还可以留空通过<code>clang-format.fallbackStyle</code>指定 LLVM, Google, Chromium, Mozilla, WebKit 之一为格式化标准.</li>
<li>clang-format.executable : clang-format路径,这里安装的是 clang-format-5.0.</li>
</ul>
</li>
<li><p>指定通过.clang-format文件为格式化标准后,在项目根目录下 新建 .clang-format 文件.</p>
</li>
<li><p>每个版本的 clang-format 都有对应的详细定制说明.5.0版本<a href="http://releases.llvm.org/5.0.0/tools/clang/docs/ClangFormatStyleOptions.html" target="_blank" rel="external">对应说明</a></p>
</li>
<li><p>官方有几个风格实例:</p>
<ul>
<li><p>Linux Kernel style</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BasedOnStyle: LLVM</div><div class="line">IndentWidth: 8</div><div class="line">UseTab: Always</div><div class="line">BreakBeforeBraces: Linux</div><div class="line">AllowShortIfStatementsOnASingleLine: <span class="literal">false</span></div><div class="line">IndentCaseLabels: <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>效果如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">switch</span> (x) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                do_something();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                do_something_else();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (condition)</div><div class="line">                do_something_completely_different();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (x == y) &#123;</div><div class="line">                q();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; y) &#123;</div><div class="line">                w();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                r();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Visual Studio style</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">UseTab: Never</div><div class="line">IndentWidth: 4</div><div class="line">BreakBeforeBraces: Allman</div><div class="line">AllowShortIfStatementsOnASingleLine: <span class="literal">false</span></div><div class="line">IndentCaseLabels: <span class="literal">false</span></div><div class="line">ColumnLimit: 0</div></pre></td></tr></table></figure>
<p>效果如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span> (suffix)</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        do_something();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        do_something_else();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (condition)</div><div class="line">        do_somthing_completely_different();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (x == y)</div><div class="line">    &#123;</div><div class="line">        q();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; y)</div><div class="line">    &#123;</div><div class="line">        w();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        r();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最后是我的自定义配置(中文说明),从网上收集+官方文档.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 配置以什么语言format当前文件</span></div><div class="line"><span class="comment"># CPP: C, C++, Objective-C, ObjectiveC++;</span></div><div class="line">Language: Cpp</div><div class="line"></div><div class="line"><span class="comment">#在llvm的配置基础上加定制配置</span></div><div class="line">BasedOnStyle: LLVM </div><div class="line"></div><div class="line"><span class="comment">#someLongFunction(argument1,</span></div><div class="line"><span class="comment">#                 argument2);</span></div><div class="line">AlignAfterOpenBracket: Align</div><div class="line"></div><div class="line"><span class="comment"># true: 表示对齐连续的紧跟注释（连续行使用双斜杠注释，包括在函数体内），多用于Model定义、property说明、私有成员变量说明；</span></div><div class="line">AlignTrailingComments: <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#对齐连续赋值运算符</span></div><div class="line">AlignConsecutiveAssignments : <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#若true，则对齐连续声明.</span></div><div class="line">AlignConsecutiveDeclarations : <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#换行符选项 左对齐</span></div><div class="line">AlignEscapedNewlines: Left</div><div class="line"></div><div class="line"><span class="comment">#水平对齐二目运算符和三目运算符的操作数</span></div><div class="line">AlignOperands : <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment"># true：允许较短(一般只有一行，多为内联C函数)的Function在一行显示,如“int f() &#123; return 1; &#125;”，规定设为false；</span></div><div class="line">AllowShortFunctionsOnASingleLine: <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment">#true: 允许较短的if判断在一行显示，否则换行显示（没有自动加花括号）；</span></div><div class="line">AllowShortIfStatementsOnASingleLine: <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#??? true 允许较短的循环（while、for）在一行显示，否则换行显示（没有自动加花括号）；</span></div><div class="line">AllowShortLoopsOnASingleLine: <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#true：允许只有Break语句的case标签在一行显示，false：不允许（自动换行显示）, 规范为不允许</span></div><div class="line">AllowShortCaseLabelsOnASingleLine: <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment">#true：允许将较长的literal－String字符串分割成多行显示；</span></div><div class="line">AlwaysBreakBeforeMultilineStrings: <span class="literal">false</span></div><div class="line"></div><div class="line">BreakBeforeBraces: Allman</div><div class="line"></div><div class="line"><span class="comment">#连续行的缩进长度（通常缩进＋设置值）， 一般用于首参数小于后续参数的method名字、多行的String－literals</span></div><div class="line">ContinuationIndentWidth: 4</div><div class="line"></div><div class="line"><span class="comment">#设置代码的最大长度（回自动对代码长度进行换行显示，并对注释自动换行；当长度加大的时候，AllowAllParametersOfDeclarationOnNextLine＝true失效）</span></div><div class="line">ColumnLimit: 100</div><div class="line"></div><div class="line"><span class="comment">#如果为真（true）, 分析最常见的格式化文件中“&amp;”和“\*”的对齐方式。pointeralignment则仅作为后备。</span></div><div class="line">DerivePointerAlignment: <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#true: 将switch的case标签从switch表达式缩进一级；否则将switch表达式对齐；</span></div><div class="line">IndentCaseLabels: <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#缩进字符长度</span></div><div class="line">IndentWidth:     4</div><div class="line"></div><div class="line"><span class="comment">#所有位置的指针星号（＊）或取地址符号（&amp;）对齐位置：Left、Middle、Right，当作为乘号时候居中 （规范为Right）</span></div><div class="line">PointerAlignment: Right</div><div class="line"></div><div class="line"><span class="comment">#整个文件任意位置最大能够保持的连续空行数（如果超过MAX值，减少到Max行，小于不管；）</span></div><div class="line">MaxEmptyLinesToKeep: 2</div><div class="line"></div><div class="line"><span class="comment">#true:在赋值运算符之前添加一个空格，否则去掉；(规范为添加)</span></div><div class="line">SpaceBeforeAssignmentOperators: <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#是否在括号之前添加一个空格，Never：任何情况都不添加；ControlStatements：只在控制结构（for、if、while）的地方添加空格；AlWays: 除开在function－like的的宏定义之外在任何地方都需要添加空格；（规范为ControlStatements）</span></div><div class="line">SpaceBeforeParens: ControlStatements</div><div class="line"></div><div class="line"><span class="comment">#在紧跟注释之前所留空格数，一般建议为2个空格</span></div><div class="line">SpacesBeforeTrailingComments: 2</div><div class="line"></div><div class="line">UseTab: Never</div><div class="line"></div><div class="line"><span class="comment"># 格式兼容C++11</span></div><div class="line">Standard: Cpp11</div><div class="line"></div><div class="line"><span class="comment">#当前配置生效开关，true：打开，false：关闭</span></div><div class="line">DisableFormat: <span class="literal">false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="编译-调试"><a href="#编译-调试" class="headerlink" title="编译/调试"></a>编译/调试</h1><ul>
<li>待续</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul>
<li>至此,vscode 编写c语言的体验就十分完整了.跨平台一致化的体验真的很好.推荐还在苦恼 c 编辑器的可以一试.</li>
<li>下一篇vscode的 python 配置.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vscode 1.20.x&lt;/li&gt;
&lt;li&gt;ubuntu&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul
    
    </summary>
    
      <category term="Linux笔记" scheme="http://yoursite.com/categories/Linux%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>面试题汇总—java</title>
    <link href="http://yoursite.com/2018/03/07/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB-java/"/>
    <id>http://yoursite.com/2018/03/07/面试汇总-java/</id>
    <published>2018-03-07T04:00:00.000Z</published>
    <updated>2018-04-06T06:42:47.935Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>资料来源如下</p>
<blockquote>
<p><a href="https://github.com/AweiLoveAndroid/CommonDevKnowledge" target="_blank" rel="external">常用的Android开发的一些技能点以及BAT公司面试题汇集</a></p>
</blockquote>
<ul>
<li><p>感觉自己白学了////😂////</p>
</li>
<li><p>一道一道的找答案..</p>
</li>
</ul>
<hr>
<h1 id="java面试题汇总"><a href="#java面试题汇总" class="headerlink" title="java面试题汇总"></a>java面试题汇总</h1><p>熟练掌握java是很关键的，大公司不仅仅要求你会使用几个api，更多的是要你熟悉源码实现原理，甚至要你知道有哪些不足，怎么改进，还有一些java有关的一些算法，设计模式等等。</p>
<h2 id="一、java基础面试知识点"><a href="#一、java基础面试知识点" class="headerlink" title="一、java基础面试知识点"></a>一、java基础面试知识点</h2><ul>
<li><p>java中==和equals和hashCode的区别</p>
<ul>
<li>关系操作符 ==：<ul>
<li>基本数据类型，== 判断的是左右两边操作数的值是否相等</li>
<li>引用数据类型，== 判断的是左右两边操作数的内存地址是否相同,是否是同一个对象。</li>
</ul>
</li>
<li>equals方法 基类Object中的实例方法<ul>
<li>本质是期望比较 对象的内容</li>
</ul>
</li>
<li>hashCode方法,基类Object中的实例方法,返回一个int类型 hash值.<ul>
<li>重写上述两个方法,必须保证hashCode与equals的结果一致性,内容相同的对象,hash值相同,比较返回 true</li>
<li>hash值为确定对象在哈希表中位置的标识.</li>
</ul>
</li>
</ul>
</li>
<li><p>int、char、long各占多少字节数</p>
<ul>
<li>int 4字节</li>
<li>char 2个字节</li>
<li>long 8个字节</li>
</ul>
</li>
<li><p>int与integer的区别</p>
<ul>
<li>int为java的内置基本类型</li>
<li>integer 为int的包装类</li>
</ul>
</li>
<li><p>探探对java多态的理解</p>
<ul>
<li>类之间存在继承关系,子类可以重写父类相同的方法名.</li>
<li>调用时 子类直接调用自己实现的同命方法.</li>
</ul>
</li>
<li><p>String、StringBuffer、StringBuilder区别</p>
<ul>
<li>String 是不可变对象,所有操作都会生成新的String对象</li>
<li>StringBuffer StringBuilder 为可变对象.<ul>
<li>StringBufferd 线程安全</li>
<li>StringBuilder 线程不安全,但是单线程性能好</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是内部类？内部类的作用</p>
<ul>
<li><p>内部类主要定义在类的内部</p>
<ul>
<li>成员内部类<ul>
<li>作为外部类的成员，可以直接使用外部类的所有成员和方法，即使是private</li>
<li>外部类要访问内部类的所有成员变量或方法，则需要通过内部类的对象来获取</li>
<li>成员内部类不能含有 static 的变量和方法</li>
</ul>
</li>
<li>局部内部类 <ul>
<li>指内部类定义在方法和作用域内，就是在外部类的方法中定义的内部类就是局部内部类</li>
<li>局部内部类由于是在方法中定义的，其作用域也是在方法内部中，方法外执行到，则被JVM回收。局部内部类的实例化也只能在方法中进行</li>
<li>局部内部类方法中想要使用局部变量，该变量必须声明为 final 类型</li>
</ul>
</li>
<li>静态内部类<ul>
<li>修饰为static的内部类</li>
<li>直接引用 <code>外部类.内部类</code></li>
<li>实例化: <code>外部类.内部类 对象 = new 外部类.内部类()</code></li>
</ul>
</li>
<li>匿名内部类<ul>
<li>局部内部类一种</li>
<li>没有名称,只能使用new声明<code>new &lt;类或接口&gt; &lt;类的主体&gt;</code></li>
<li>使用最多的实例(创建线程):<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">                    System.out.print(i + <span class="string">" "</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        t.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内部类能独立地继承自一个类（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。</p>
</li>
</ul>
</li>
<li><p>抽象类和接口区别</p>
<ul>
<li>抽象类是对事物的抽象,接口是对行为的抽象</li>
</ul>
</li>
<li><p>抽象类的意义</p>
<ul>
<li>更利于代码的维护和重用</li>
</ul>
</li>
<li><p>抽象类与接口的应用场景</p>
<ul>
<li>接口是为了使用它规范的某一个行为</li>
<li>抽象类是为了使用这个类属性和行为</li>
</ul>
</li>
<li><p>抽象类是否可以没有方法和属性？</p>
<ul>
<li>可以</li>
</ul>
</li>
<li><p>接口的意义</p>
<ul>
<li>补足多重继承关系.</li>
<li>赋予多态更多的实现方式</li>
</ul>
</li>
<li><p>泛型中extends和super的区别</p>
<ul>
<li><code>&lt;? super T&gt;</code> 代表泛型T及其父类 ?的下界</li>
<li><code>&lt;? extends T&gt;</code> 代表泛型T及其子类 ?的上界</li>
<li>频繁往外读取内容的，适合用上界Extends。</li>
<li>经常往里插入的，适合用下界Super。</li>
</ul>
</li>
<li><p>父类的静态方法能否被子类重写</p>
<ul>
<li>否 静态方法与对象无关</li>
</ul>
</li>
<li><p>进程和线程的区别</p>
<ul>
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</li>
<li>线程是进程的一个实体, 是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</li>
<li>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</li>
<li>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序 健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</li>
</ul>
</li>
<li><p>final，finally，finalize的区别</p>
<ul>
<li>final 修饰符 修饰类标识无法再被继承</li>
<li>finally 用于错误处理</li>
<li>finalize 析构函数,但调用后 资源回收时间由 jvm决定</li>
</ul>
</li>
<li><p>序列化的方式(<strong>待考</strong>)</p>
<ul>
<li>序列化，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地</li>
<li>Json,Serializable,Parcelable,ObjectOutputStream</li>
</ul>
</li>
<li><p>Serializable 和Parcelable 的区别</p>
<ul>
<li>Serializable是java api，Parcelable是Android api;</li>
<li>Serializable过程需要大量的I/O操作,开销大,效率低</li>
<li>Parcelable过程不需要大量的I/O操作,开销小,效率高</li>
</ul>
</li>
<li><p>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</p>
<ul>
<li>可以被继承,但不能被重写,静态方法和静态属性是属于类.</li>
</ul>
</li>
<li><p>静态内部类的设计意图</p>
<ul>
<li>静态内部类可以独立存在，又希望只被外部类使用，private修饰的时候不被同一个包下的其他类使用。</li>
<li>非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。</li>
<li>静态内部类的作用：</li>
<li>只是为了降低包的深度，方便类的使用，</li>
<li>静态内部类适用于包含类当中，但又不依赖与外在的类，不能使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。</li>
<li>在创建静态内部类的时候，不需要外部类对象的引用。</li>
<li>非静态内部类有一个很大的优点：可以自由使用外部类的所有变量和方法</li>
</ul>
</li>
<li><p>成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用</p>
<ul>
<li>见上内部类</li>
</ul>
</li>
<li><p>谈谈对kotlin的理解</p>
<ul>
<li>代码量下降</li>
<li>语法糖</li>
<li>与java 100%兼容</li>
<li>函数式编程</li>
</ul>
</li>
<li><p>闭包和局部内部类的区别</p>
</li>
</ul>
<ul>
<li>string 转换成 integer的方式及原理</li>
</ul>
<h2 id="二、java深入源码级的面试题（有难度）"><a href="#二、java深入源码级的面试题（有难度）" class="headerlink" title="二、java深入源码级的面试题（有难度）"></a>二、java深入源码级的面试题（有难度）</h2><ul>
<li>哪些情况下的对象会被垃圾回收机制处理掉？</li>
<li>讲一下常见编码方式？</li>
<li>utf-8编码中的中文占几个字节；int型几个字节？</li>
<li>静态代理和动态代理的区别，什么场景使用？</li>
<li>Java的异常体系</li>
<li>谈谈你对解析与分派的认识。</li>
<li>修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？</li>
<li>Java中实现多态的机制是什么？</li>
<li>如何将一个Java对象序列化到文件里？</li>
<li>说说你对Java反射的理解</li>
<li>说说你对Java注解的理解</li>
<li>说说你对依赖注入的理解</li>
<li>说一下泛型原理，并举例说明</li>
<li>Java中String的了解</li>
<li>String为什么要设计成不可变的？</li>
<li>Object类的equal和hashCode方法重写，为什么？</li>
</ul>
<h2 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h2><ul>
<li><p>常用数据结构简介</p>
</li>
<li><p>并发集合了解哪些？</p>
</li>
<li>列举java的集合以及集合之间的继承关系</li>
<li>集合类以及集合框架</li>
<li>容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 <a href="http://alexyyek.github.io/2015/04/06/Collection/" target="_blank" rel="external">Java容器类</a>）</li>
<li>List,Set,Map的区别</li>
<li>List和Map的实现方式以及存储方式</li>
<li>HashMap的实现原理</li>
<li>HashMap数据结构？</li>
<li>HashMap源码理解</li>
<li>HashMap如何put数据（从HashMap源码角度讲解）？</li>
<li>HashMap怎么手写实现？</li>
<li>ConcurrentHashMap的实现原理</li>
<li>ArrayMap和HashMap的对比</li>
<li>HashTable实现原理</li>
<li>TreeMap具体实现</li>
<li>HashMap和HashTable的区别</li>
<li>HashMap与HashSet的区别</li>
<li>HashSet与HashMap怎么判断集合元素重复？</li>
<li>集合Set实现Hash怎么防止碰撞</li>
<li>ArrayList和LinkedList的区别，以及应用场景</li>
<li>数组和链表的区别</li>
<li>二叉树的深度优先遍历和广度优先遍历的具体实现</li>
<li>堆的结构</li>
<li>堆和树的区别</li>
<li>堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？</li>
<li>什么是深拷贝和浅拷贝</li>
<li>手写链表逆序代码</li>
<li>讲一下对树，B+树的理解</li>
<li>讲一下对图的理解</li>
<li>判断单链表成环与否？</li>
<li>链表翻转（即：翻转一个单项链表）</li>
<li>合并多个单有序链表（假设都是递增的）</li>
</ul>
<h2 id="四、线程、多线程和线程池"><a href="#四、线程、多线程和线程池" class="headerlink" title="四、线程、多线程和线程池"></a>四、线程、多线程和线程池</h2><ul>
<li>开启线程的三种方式？</li>
<li>线程和进程的区别？</li>
<li>为什么要有线程，而不是仅仅用进程？</li>
<li>run()和start()方法区别</li>
<li>如何控制某个方法允许并发访问线程的个数？</li>
<li>在Java中wait和seelp方法的不同；</li>
<li>谈谈wait/notify关键字的理解</li>
<li>什么导致线程阻塞？</li>
<li>线程如何关闭？</li>
<li>讲一下java中的同步的方法</li>
<li>数据一致性如何保证？</li>
<li>如何保证线程安全？</li>
<li>如何实现线程同步？</li>
<li>两个进程同时要求写或者读，能不能实现？如何防止进程的同步？</li>
<li>线程间操作List</li>
<li>Java中对象的生命周期</li>
<li>Synchronized用法</li>
<li>synchronize的原理</li>
<li>谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解</li>
<li>static synchronized 方法的多线程访问和作用</li>
<li>同一个类里面两个synchronized方法，两个线程同时访问的问题</li>
<li>volatile的原理</li>
<li>谈谈volatile关键字的用法</li>
<li>谈谈volatile关键字的作用</li>
<li>谈谈NIO的理解</li>
<li>synchronized 和volatile 关键字的区别</li>
<li>synchronized与Lock的区别</li>
<li>ReentrantLock 、synchronized和volatile比较</li>
<li>ReentrantLock的内部实现</li>
<li>lock原理</li>
<li>死锁的四个必要条件？</li>
<li>怎么避免死锁？</li>
<li>对象锁和类锁是否会互相影响？</li>
<li>什么是线程池，如何使用?</li>
<li>Java的并发、多线程、线程模型</li>
<li>谈谈对多线程的理解</li>
<li>多线程有什么要注意的问题？</li>
<li>谈谈你对并发编程的理解并举例说明</li>
<li>谈谈你对多线程同步机制的理解？</li>
<li>如何保证多线程读写文件的安全？</li>
<li>多线程断点续传原理</li>
<li>断点续传的实现</li>
</ul>
<h2 id="并发编程有关知识点（这个是一般Android开发用的少的，所以建议多去看看）："><a href="#并发编程有关知识点（这个是一般Android开发用的少的，所以建议多去看看）：" class="headerlink" title="并发编程有关知识点（这个是一般Android开发用的少的，所以建议多去看看）："></a>并发编程有关知识点（这个是一般Android开发用的少的，所以建议多去看看）：</h2><p>平时Android开发中对并发编程可以做得比较少，Thread这个类经常会用到，但是我们想提升自己的话，一定不能停留在表面，,我们也应该去了解一下java的关于线程相关的源码级别的东西。</p>
<hr>
<p><strong>学习的参考资料如下：</strong></p>
<blockquote>
<p>Java 内存模型</p>
</blockquote>
<ul>
<li><a href="http://www.iteye.com/topic/806990" target="_blank" rel="external">java线程安全总结</a></li>
<li><a href="http://ifeve.com/java-memory-model-0/" target="_blank" rel="external">深入理解java内存模型系列文章</a></li>
</ul>
<blockquote>
<p>线程状态：</p>
</blockquote>
<ul>
<li><a href="https://my.oschina.net/mingdongcheng/blog/139263" target="_blank" rel="external">一张图让你看懂JAVA线程间的状态转换</a></li>
</ul>
<blockquote>
<p>锁：</p>
</blockquote>
<ul>
<li><a href="http://blog.csdn.net/vking_wang/article/details/9952063" target="_blank" rel="external">锁机制：synchronized、Lock、Condition</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-concurrent/locks-in-java.html" target="_blank" rel="external">Java 中的锁</a></li>
</ul>
<blockquote>
<p>并发编程：</p>
</blockquote>
<ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920357.html" target="_blank" rel="external">Java并发编程：Thread类的使用</a></li>
<li><a href="http://blog.51cto.com/lavasoft/27069" target="_blank" rel="external">Java多线程编程总结</a></li>
<li><a href="https://www.jianshu.com/p/053943a425c3#" target="_blank" rel="external">Java并发编程的总结与思考</a></li>
<li><a href="http://www.cnblogs.com/chenssy/p/4701027.html" target="_blank" rel="external">Java并发编程实战—–synchronized</a></li>
<li><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap#" target="_blank" rel="external">深入分析ConcurrentHashMap</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;资料来源如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/AweiLoveAndroid/CommonDevKnowledge&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;常用的Android
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>总结</title>
    <link href="http://yoursite.com/2018/01/22/2017%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/22/2017总结/</id>
    <published>2018-01-22T04:00:11.000Z</published>
    <updated>2018-01-22T13:15:40.622Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h3><ul>
<li>找到了兴趣-Android开始正式学习。</li>
<li>搭建了自己的blog，虽然周围人没人关注，有一篇日子的阅读量过了1万，还是很惊喜的</li>
<li>嵌入式工作没用找到满意的，只能说等春招 Andoid的实习，这段时间努力提高自己，</li>
<li>放弃了考研</li>
<li>心情走过了类似抑郁的经历，对体制种种各有看法，是对是错，让时间见证</li>
</ul>
<hr>
<h3 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h3><ul>
<li>希望有自己的收入，经济相对自由一点</li>
<li>谈一段恋爱，遇到合适的女孩吧</li>
<li>Android的路上，顺利一点吧</li>
<li>不给自己设定限制，走一步再走一步</li>
</ul>
<h3 id="2017-1"><a href="#2017-1" class="headerlink" title="2017"></a>2017</h3><ul>
<li>工作了,有了一点自己的收入</li>
<li>有喜欢的人,却很无力的选择遗忘</li>
<li>在从事android以外的工作,2018准备转行.</li>
</ul>
<hr>
<h3 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h3><ul>
<li>迟到的终结</li>
<li>转行android,补足基础.</li>
<li>日常迁移到linux下,熟悉python,提升效率.</li>
<li>博客不要断,记清楚自己的目标</li>
<li>体制重重,守护好家人,除此之外,别无他求.</li>
<li>保持自己对环境的体察,珍惜剩下的时间.</li>
<li>要记得 有过的梦想,即使已经遥不可及,不等于要违背自己的底线.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2016&quot;&gt;&lt;a href=&quot;#2016&quot; class=&quot;headerlink&quot; title=&quot;2016&quot;&gt;&lt;/a&gt;2016&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;找到了兴趣-Android开始正式学习。&lt;/li&gt;
&lt;li&gt;搭建了自己的blog，虽然周围人没人关注，有一篇日子
    
    </summary>
    
      <category term="随" scheme="http://yoursite.com/categories/%E9%9A%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>python—模块</title>
    <link href="http://yoursite.com/2018/01/19/python%E2%80%94%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/01/19/python—模块/</id>
    <published>2018-01-19T02:17:11.000Z</published>
    <updated>2018-01-19T15:01:52.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul>
<li>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</li>
<li><p>涉及到概念 包(Package) 和 模块(Module)</p>
</li>
<li><p>创建自己的模块时，要注意：</p>
<ul>
<li>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</li>
<li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。</li>
</ul>
</li>
</ul>
<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><ul>
<li><p>示例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="string">' a test module '</span></div><div class="line"></div><div class="line">__author__ = <span class="string">'Michael Liao'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></div><div class="line">    args = sys.argv</div><div class="line">    <span class="keyword">if</span> len(args)==<span class="number">1</span>:</div><div class="line">        print(<span class="string">'Hello, world!'</span>)</div><div class="line">    <span class="keyword">elif</span> len(args)==<span class="number">2</span>:</div><div class="line">        print(<span class="string">'Hello, %s!'</span> % args[<span class="number">1</span>])</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'Too many arguments!'</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    test()</div></pre></td></tr></table></figure>
</li>
<li><p>注释:</p>
<ul>
<li>第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行</li>
<li>第2行注释表示.py文件本身使用标准UTF-8编码；</li>
<li>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释</li>
<li>第6行使用<strong>author</strong>变量把作者写进去</li>
</ul>
</li>
<li><p>重点<code>if __name__==&#39;__main__&#39;:</code></p>
</li>
<li>Python解释器把一个特殊变量<strong>name</strong>置为<strong>main</strong>，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试.</li>
</ul>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li>Python中，是通过<code>_</code>前缀 标记 private </li>
<li>note: <strong>python中语法没有限制 <code>_</code>开头的变量/函数!</strong></li>
</ul>
<h3 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h3><ul>
<li><p><code>pip</code>命令 </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install xxx</div></pre></td></tr></table></figure>
</li>
<li><p>或者在文件中自定义路径.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模块&quot;&gt;&lt;a href=&quot;#模块&quot; class=&quot;headerlink&quot; title=&quot;模块&quot;&gt;&lt;/a&gt;模块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;涉及到概念 包(Packag
    
    </summary>
    
      <category term="python笔记" scheme="http://yoursite.com/categories/python%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python—面向对象</title>
    <link href="http://yoursite.com/2018/01/19/python%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/01/19/python—面向对象/</id>
    <published>2018-01-19T02:17:11.000Z</published>
    <updated>2018-01-19T15:00:27.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>类 方法 实例</li>
<li>封装 继承 多态</li>
</ul>
<h3 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h3><ul>
<li><p>示例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></div><div class="line">      self.name = name</div><div class="line">      self.score = score</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span></div><div class="line">      print(<span class="string">'%s: %s'</span> % (self.name, self.score))</div><div class="line"></div><div class="line">bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>定义类的关键词与java一样 <code>class</code> 括号内为继承的父类.没有父类时,选择 <code>object</code> 作为基类.(<code>object</code>是所有类的基类)</p>
</li>
<li><p>变量比较特殊,不像java中有单独字段.python 类中变量定义是在<code>__init__</code>方法</p>
</li>
<li><p>方法的声明和函数类似. <code>def 方法名 (参数)</code></p>
<ul>
<li>类中 第一个参数必须是<code>self</code>,意为创建的实例自身.方法中调用类中其他变量都要通过 <code>self.xxx</code> 访问.</li>
</ul>
</li>
<li><p>一些必须实现的属性在<code>__init__</code>方法中定义.如示例.第一个参数是 <code>self</code> 之后是具体变量值,在方法内 使用self访问类中定义的变量.</p>
</li>
<li><p>Python允许对实例变量绑定任何数据,so just do it😈</p>
</li>
</ul>
<h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><ul>
<li>类似java private 字段的python实现</li>
<li>属性的名称前加上两个下划线 <code>__</code> 该属性就成为了类的私有属性,只能在实例的内部访问.(<code>self.xxx</code>) </li>
<li><p>获取/修改,使用 <code>get/set</code> 获取或修改对应属性.(一般在set中可以添加类型检查)</p>
</li>
<li><p>类似<code>__xxx__</code>的变量，双下划线开头，并且以双下划线结尾的，是特殊变量.特殊变量是可以直接访问的，不是private变量.也<strong>最好不要定义<code>__xxx__</code>变量名</strong></p>
</li>
<li><p>以下划线开头的实例变量名，例如<code>_name</code>.可以在外部访问的，但是，约定俗成,请直接忽视.</p>
</li>
<li><p>特例:</p>
<ul>
<li>双下划线开头的实例变量不能直接访问是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>.<strong>仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量</strong>.</li>
<li><p>一个错误设置示例:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.get_name()</div><div class="line"><span class="string">'Bart Simpson'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.__name = <span class="string">'New Name'</span> <span class="comment"># 设置__name变量！</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.__name</div><div class="line"><span class="string">'New Name'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bart.get_name() <span class="comment"># get_name()内部返回self.__name</span></div><div class="line"><span class="string">'Bart Simpson'</span></div></pre></td></tr></table></figure>
</li>
<li><p>如同示例,外部代码直接赋给 <code>bart.__name</code> 不会影响实例中原有属性,只会新增一个属性.究其原因,实例中的属性已经被解释器重命名为了<code>bart._Student__name</code>.</p>
</li>
</ul>
</li>
</ul>
<h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><ul>
<li>继承和多态概念与java类似.不多语了.</li>
<li>那么重点来了:</li>
<li>python本身是动态语言,体现在变量/类等各个方面,自由度极高.在继承上,亦是如此.<ul>
<li>java中定义一个su方法,调用model类实例实现的run方法.su方法可传入的只有 model类或其子类的实例</li>
<li>但python中 只要是定义了 run方法(别管内容/功能一样不一样)类的实例,都可以作为参数传入 su 方法.</li>
</ul>
</li>
<li>java中对类的类型的处理,相当于照猫🐱画虎🐯,传入的起码要是个猫科动物. python 中对类的类型处理,额头写个<code>王</code>字,哪怕传入具体对象是个猫头鹰🦉,也当作猫科处理了.</li>
</ul>
<hr>
<ul>
<li>note:<br>判断一个变量是否是某个类型可以用isinstance()<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(a, list)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h3><hr>
<h2 id="让我想起了java反射-不过能获取的信息要全多了"><a href="#让我想起了java反射-不过能获取的信息要全多了" class="headerlink" title="* 让我想起了java反射..不过能获取的信息要全多了."></a>* 让我想起了java反射..不过能获取的信息要全多了.</h2><h4 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h4><ul>
<li><p>示例:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; type(123)</div><div class="line">&lt;class 'int'&gt;</div><div class="line"></div><div class="line">&gt;&gt;&gt; type(a)</div><div class="line">&lt;class '__main__.Animal'&gt;</div><div class="line"></div><div class="line">&gt;&gt;&gt; type(123)==type(456)</div><div class="line">True</div></pre></td></tr></table></figure>
</li>
<li><p>判断对象类型</p>
</li>
<li>由变量指向函数或者类，也可以用type()判断</li>
<li><p>type返回对应的Class类型,可直接 <code>== 类型</code>判断</p>
</li>
<li><p>判断一个对象是否是函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import types</div><div class="line">&gt;&gt;&gt; def fn():</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; type(fn)==types.FunctionType</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType</div><div class="line">True</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h4><ul>
<li><p>示例:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(h, Husky)</div><div class="line"><span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (list, tuple))</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
</li>
<li><p>判断继承关系,一打一个准.</p>
</li>
<li>能用type()判断的基本类型也可以用isinstance()判断</li>
<li>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</li>
</ul>
<h4 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h4><ul>
<li><p>示例:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(<span class="string">'ABC'</span>)</div><div class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>,..., <span class="string">'__subclasshook__'</span>, <span class="string">'capitalize'</span>, <span class="string">'casefold'</span>,..., <span class="string">'zfill'</span>]</div></pre></td></tr></table></figure>
</li>
<li><p>获得一个对象的所有属性和方法.直接返回一个字符串list.</p>
</li>
<li><p>配合getattr()、setattr()以及hasattr()，可以直接操作一个对象的状态.</p>
</li>
<li><p>示例:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'x'</span>) <span class="comment"># 有属性'x'吗？</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性'y'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'y'</span>) <span class="comment"># 获取属性'y'</span></div><div class="line"><span class="number">19</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj.y <span class="comment"># 获取属性'y'</span></div><div class="line"><span class="number">19</span></div></pre></td></tr></table></figure>
</li>
<li><p>不存在的属性，会抛出AttributeError的错误,可以传入一个default参数，如果属性不存在，就返回默认值.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'z'</span>, <span class="number">404</span>) <span class="comment"># 获取属性'z'，如果不存在，返回默认值404</span></div><div class="line"><span class="number">404</span></div></pre></td></tr></table></figure>
</li>
<li><p>也可以获得对象的方法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'power'</span>) <span class="comment"># 有属性'power'吗？</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'</span></div><div class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fn = getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'并赋值到变量fn</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span></div><div class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span></div><div class="line"><span class="number">81</span></div></pre></td></tr></table></figure>
</li>
<li><p>只有在不知道对象信息的时候，才会去获取对象信息.谨记,谨记.</p>
</li>
</ul>
<h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><ul>
<li>类似java类中静态变量 与 普通变量区别.</li>
<li><p>类的属性,直接在类的cclass中声明.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">  name = <span class="string">'Student'</span></div></pre></td></tr></table></figure>
</li>
<li><p>访问时,类的属性会被实例的同名属性覆盖,但不会被修改,互相独立.</p>
</li>
<li>删除实例属性后，再使用相同的名称，访问到的将是类属性</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;类 方法 实例&lt;/li&gt;
&lt;li&gt;封装 继承 多态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类和实例&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="python笔记" scheme="http://yoursite.com/categories/python%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
</feed>
